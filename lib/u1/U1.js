'use strict';
var libtess;
(function (libtess) {
    class DictNode {
        constructor(opt_key = null, opt_nextNode = null, opt_prevNode = null) {
            this.key = opt_key || null;
            this.next = opt_nextNode || this;
            this.prev = opt_prevNode || this;
        }
        getKey() {
            return this.key;
        }
        getSuccessor() {
            return this.next;
        }
        getPredecessor() {
            return this.prev;
        }
        ;
    }
    libtess.DictNode = DictNode;
})(libtess || (libtess = {}));
var libtess;
(function (libtess) {
    class Dict {
        constructor(frame, leq) {
            this.head_ = new libtess.DictNode();
            this.frame_ = frame;
            this.leq_ = leq;
        }
        ;
        deleteDict_() {
        }
        ;
        insertBefore(node, key) {
            do {
                node = node.prev;
            } while (node.key !== null && !this.leq_(this.frame_, node.key, key));
            var newNode = new libtess.DictNode(key, node.next, node);
            node.next.prev = newNode;
            node.next = newNode;
            return newNode;
        }
        ;
        insert(key) {
            return this.insertBefore(this.head_, key);
        }
        ;
        deleteNode(node) {
            node.next.prev = node.prev;
            node.prev.next = node.next;
        }
        ;
        search(key) {
            var node = this.head_;
            do {
                node = node.next;
            } while (node.key !== null && !this.leq_(this.frame_, key, node.key));
            return node;
        }
        ;
        getMin() {
            return this.head_.next;
        }
        ;
        getMax() {
            return this.head_.prev;
        }
        ;
    }
    libtess.Dict = Dict;
})(libtess || (libtess = {}));
if (typeof String.prototype.EndsWith !== 'function') {
    String.prototype.EndsWith = function (suffix, isgnoreCase) {
        var v = this;
        if (isgnoreCase) {
            v = this.toUpperCase();
            suffix = suffix.toUpperCase();
        }
        return v.indexOf(suffix, v.length - suffix.length) !== -1;
    };
}
if (typeof String.prototype.StartsWith !== 'function') {
    String.prototype.StartsWith = function (prefix, isgnoreCase) {
        var v = this;
        if (isgnoreCase) {
            v = this.toUpperCase();
            prefix = prefix.toUpperCase();
        }
        return v.indexOf(prefix) === 0;
    };
}
if (typeof String.IsNullOrEmpty !== 'function') {
    String.IsNullOrEmpty = function (value) {
        return value === undefined || value === null || value == "";
    };
}
if (typeof String.Compare !== 'function') {
    String.Compare = function (a, b, ignoreCase = false) {
        if (a == null && b == null)
            return 0;
        if (a == null)
            return -1;
        if (b == null)
            return 1;
        if (ignoreCase) {
            a = a.toUpperCase();
            b = b.toUpperCase();
        }
        return a.localeCompare(b);
    };
}
if (typeof Array.prototype.Contains !== 'function') {
    Array.prototype.Contains = function (value) {
        return this.indexOf(value) > -1;
    };
}
if (typeof Array.prototype.AddRange !== 'function') {
    Array.prototype.AddRange = function (items) {
        for (var i = 0; i < items.length; i++) {
            this.push(items[i]);
        }
    };
}
if (typeof Array.prototype.OrderBy !== 'function') {
    Array.prototype.OrderBy = function (func) {
        var compare_func = (a, b) => {
            var va = func(a);
            var vb = func(b);
            if (va == vb)
                return 0;
            if (va < vb)
                return -1;
            return 1;
        };
        var arr = this.slice();
        arr.sort(compare_func);
        return arr;
    };
}
if (typeof Array.ArrayCopy !== 'function') {
    Array.ArrayCopy = function arraycopy(src, srcstart, tgt, tgtstar, length) {
        for (var k = 0; k < length; k++) {
            tgt[tgtstar + k] = src[k + srcstart];
        }
    };
}
if (typeof Boolean.Parse !== 'function') {
    Boolean.Parse = function (value) {
        if (value == null)
            return null;
        value = value.toUpperCase();
        if (value == "TRUE")
            return true;
        if (value == "FALSE")
            return false;
        return null;
    };
}
var U1;
(function (U1) {
    class UValueUtil {
        static ConvertArrFromString(ctor, str) {
            var items = new Array();
            if (str == null)
                return items;
            var sb = "";
            var depth = 0;
            for (var i = 0; i < str.length; i++) {
                var ch = str[i];
                if (ch == ",") {
                    if (depth == 1) {
                        var item = new ctor();
                        item.ConvertFromStr(sb);
                        items.push(item);
                        sb = "";
                    }
                    else {
                        sb = sb.concat(ch);
                    }
                }
                else if (ch == '(') {
                    if (depth > 0)
                        sb = sb.concat(ch);
                    ++depth;
                }
                else if (ch == ')') {
                    --depth;
                    if (depth == 0) {
                        var item = new ctor();
                        item.ConvertFromStr(sb);
                        items.push(item);
                        sb = "";
                        break;
                    }
                    else {
                        sb = sb.concat(ch);
                    }
                }
                else {
                    sb = sb.concat(ch);
                }
            }
            return items;
        }
        static ConvertArrToString(val) {
            var result = "(";
            for (var i = 0; i < val.length; i++) {
                if (i > 0)
                    result += ",";
                result += val[i].ConvertToStr();
            }
            result += ")";
            return result;
        }
        static ConvertNumberArrFromString(str) {
            var items = new Array();
            if (str == null)
                return items;
            var sb = "";
            var depth = 0;
            for (var i = 0; i < str.length; i++) {
                var ch = str[i];
                if (ch == ",") {
                    if (depth == 1) {
                        var num = parseFloat(sb);
                        if (isNaN(num))
                            num = 0;
                        items.push(num);
                        sb = "";
                    }
                    else {
                        sb = sb.concat(ch);
                    }
                }
                else if (ch == '(') {
                    if (depth > 0)
                        sb = sb.concat(ch);
                    ++depth;
                }
                else if (ch == ')') {
                    --depth;
                    if (depth == 0) {
                        var num = parseFloat(sb);
                        if (isNaN(num))
                            num = 0;
                        items.push(num);
                        sb = "";
                        break;
                    }
                    else {
                        sb = sb.concat(ch);
                    }
                }
                else {
                    sb = sb.concat(ch);
                }
            }
            return items;
        }
        static ConvertNumberArrToString(...val) {
            var result = "(";
            for (var i = 0; i < val.length; i++) {
                if (i > 0)
                    result += ",";
                result += val[i];
            }
            result += ")";
            return result;
        }
        static ConvertTypedArrayToString(val) {
            var result = "(";
            for (var i = 0; i < val.length; i++) {
                if (i > 0)
                    result += ",";
                result += val[i];
            }
            result += ")";
            return result;
        }
        static ConvertStrArrFromString(str) {
            if (str == null || str == "")
                return [];
            return str.split("~EoL!");
        }
        static ConvertStrArrToString(...val) {
            if (val == null || val.length == 0)
                return "";
            return val.join("~EoL!");
        }
        static Fill_A_With_B(a, b) {
            if (a == b)
                return;
            a.splice(0, a.length);
            for (var i = 0; i < b.length; i++) {
                a.push(b[i]);
            }
        }
    }
    U1.UValueUtil = UValueUtil;
    class LogService {
        static WriteException(err) {
            console.log(err);
            if (LogService.WriteExceptionFunc != null) {
                LogService.WriteExceptionFunc(err);
            }
        }
        static WriteLogs(...logs) {
            var msg = logs.join("\r\n");
            console.log(msg);
            if (LogService.WriteLogsFunc != null) {
                LogService.WriteLogsFunc(logs);
            }
        }
    }
    U1.LogService = LogService;
    class Event1 {
        Add(thisArg, listener) {
            if (this.listeners == null) {
                this.listeners = [];
            }
            this.listeners.push({ thisArg: thisArg, listener: listener });
        }
        Remove(thisArg, listener) {
            if (this.listeners == null)
                return;
            for (var idx = this.listeners.length - 1; idx >= 0; idx--) {
                var item = this.listeners[idx];
                if (item.thisArg == thisArg &&
                    (listener == null || item.listener == listener)) {
                    this.listeners.splice(idx, 1);
                }
            }
        }
        Invoke(arg1) {
            if (this.listeners == null)
                return;
            for (var idx = 0; idx < this.listeners.length; idx++) {
                var item = this.listeners[idx];
                this.listeners[idx].listener.call(item.thisArg, arg1);
            }
        }
        Clear() {
            this.listeners = null;
        }
    }
    U1.Event1 = Event1;
    class Event2 {
        Add(thisArg, listener) {
            if (this.listeners == null) {
                this.listeners = [];
            }
            this.listeners.push({ thisArg: thisArg, listener: listener });
        }
        Remove(thisArg, listener) {
            if (this.listeners == null)
                return;
            for (var idx = this.listeners.length - 1; idx >= 0; idx--) {
                var item = this.listeners[idx];
                if (item.thisArg == thisArg &&
                    (listener == null || item.listener == listener)) {
                    this.listeners.splice(idx, 1);
                }
            }
        }
        Invoke(arg1, arg2) {
            if (this.listeners == null)
                return;
            for (var idx = this.listeners.length - 1; this.listeners != null && idx >= 0; --idx) {
                var item = this.listeners[idx];
                this.listeners[idx].listener.call(item.thisArg, arg1, arg2);
            }
        }
        Clear() {
            this.listeners = null;
        }
    }
    U1.Event2 = Event2;
    class Event3 {
        Add(thisArg, listener) {
            if (this.listeners == null) {
                this.listeners = [];
            }
            this.listeners.push({ thisArg: thisArg, listener: listener });
        }
        Remove(thisArg, listener) {
            if (this.listeners == null)
                return;
            for (var idx = this.listeners.length - 1; idx >= 0; idx--) {
                var item = this.listeners[idx];
                if (item.thisArg == thisArg &&
                    (listener == null || item.listener == listener)) {
                    this.listeners.splice(idx, 1);
                }
            }
        }
        Invoke(arg1, arg2, arg3) {
            if (this.listeners == null)
                return;
            for (var idx = 0; idx < this.listeners.length; idx++) {
                var item = this.listeners[idx];
                this.listeners[idx].listener.call(item.thisArg, arg1, arg2, arg3);
            }
        }
        Clear() {
            this.listeners = null;
        }
    }
    U1.Event3 = Event3;
    class PropertyChangedEvent extends Event2 {
    }
    U1.PropertyChangedEvent = PropertyChangedEvent;
    class UCommand {
        constructor(data = null) {
            this.PropertyChanged = new PropertyChangedEvent();
            this._key = "" + UCommand._key++;
            if (data != null) {
                this._canExecuteFunc = data.CanExecuteFunc;
                this._executeFunc = data.ExecuteFunc;
                this._toolTip = data.ToolTip;
                this._label = data.Label;
                this._id = data.ID;
            }
        }
        get CanExecuteFunc() {
            return this._canExecuteFunc;
        }
        set CanExecuteFunc(value) {
            this._canExecuteFunc = value;
            this.InvokeCanExecuteChanged();
        }
        get ExecuteFunc() {
            return this._executeFunc;
        }
        set ExecuteFunc(value) {
            this._executeFunc = value;
        }
        get Key() {
            return this._key;
        }
        set Key(value) {
            if (this._key === value)
                return;
            this._key = value;
        }
        get ID() {
            return this._id;
        }
        set ID(value) {
            if (this._id === value)
                return;
            this._id = value;
            this.InvokePropertyChanged("ID");
        }
        get ToolTip() {
            return this._toolTip;
        }
        set ToolTip(value) {
            if (this._toolTip === value)
                return;
            this._toolTip = value;
            this.InvokePropertyChanged("ToolTip");
        }
        get Label() {
            return this._label;
        }
        set Label(value) {
            if (this._label === value)
                return;
            this._label = value;
            this.InvokePropertyChanged("Label");
        }
        CanExecute(parameter) {
            if (this._canExecuteFunc != null)
                return this._canExecuteFunc();
            return true;
        }
        Execute(arg) {
            if (this.ExecuteFunc != null)
                this.ExecuteFunc(arg);
        }
        InvokeCanExecuteChanged() {
            if (this.CanExecuteChanged != null)
                this.CanExecuteChanged.Invoke(this);
            this.InvokePropertyChanged("CanExecute");
        }
        InvokePropertyChanged(prop) {
            if (this.PropertyChanged != null) {
                this.PropertyChanged.Invoke(this, prop);
            }
        }
        Dispose() {
            if (this.PropertyChanged != null) {
                this.PropertyChanged.Clear();
                delete this.PropertyChanged;
            }
            if (this._canExecuteFunc != null)
                delete this._canExecuteFunc;
            if (this._executeFunc != null)
                delete this._executeFunc;
        }
    }
    UCommand._key = 0;
    U1.UCommand = UCommand;
    class StringUtil {
        static IsWhiteSpace(char) {
            return ' \t\n\r\v'.indexOf(char) >= 0;
        }
        static IsDigit(char) {
            return char >= '0' && char <= '9';
        }
        static IsLetterOrDigit(char) {
            return (char >= '0' && char <= '9') ||
                (char >= 'a' && char <= 'z') ||
                (char >= 'A' && char <= 'Z');
        }
        static IsLetter(char) {
            return (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z');
        }
    }
    U1.StringUtil = StringUtil;
    class StringBuilder {
        constructor() {
            this.buffer = new Array();
            this.length = 0;
        }
        Append(value) {
            this.buffer.push(value);
            this.length += value.length;
        }
        toString() {
            return this.buffer.join("");
        }
        get Length() {
            return this.length;
        }
    }
    U1.StringBuilder = StringBuilder;
    class Utf8Util {
        static Utf8Encode(strUni) {
            var strUtf = strUni.replace(/[\u0080-\u07ff]/g, function (c) {
                var cc = c.charCodeAt(0);
                return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);
            });
            strUtf = strUtf.replace(/[\u0800-\uffff]/g, function (c) {
                var cc = c.charCodeAt(0);
                return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);
            });
            return strUtf;
        }
        static Utf8Decode(strUtf) {
            var strUni = strUtf.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function (c) {
                var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);
                return String.fromCharCode(cc);
            });
            strUni = strUni.replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function (c) {
                var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;
                return String.fromCharCode(cc);
            });
            return strUni;
        }
    }
    U1.Utf8Util = Utf8Util;
    function utf8_to_b64(str) {
        var unescape = unescape || ((a_) => { return a_; });
        return window.btoa(unescape(encodeURIComponent(str)));
    }
    U1.utf8_to_b64 = utf8_to_b64;
    function b64_to_utf8(str) {
        var escape = escape || ((a_) => { return a_; });
        return decodeURIComponent(escape(window.atob(str)));
    }
    U1.b64_to_utf8 = b64_to_utf8;
    var _fileInput;
    var _afterLoaded;
    var _link;
    var _imglink;
    function decimalToHex(d, padding) {
        var hex = d.toString(16);
        padding = typeof (padding) === "undefined" || padding === null ? padding = 2 : padding;
        while (hex.length < padding) {
            hex = "0" + hex;
        }
        return hex;
    }
    U1.decimalToHex = decimalToHex;
    function OpenFileDialog(calback, accept = null) {
        if (_fileInput == null) {
            _fileInput = document.createElement('input');
            _fileInput.type = 'file';
            _fileInput.style.visibility = "hidden";
            $(document).find("body").append(_fileInput);
        }
        _fileInput.accept = accept;
        if (_afterLoaded != null)
            _fileInput.removeEventListener('change', _afterLoaded);
        _afterLoaded = (event) => {
            calback(_fileInput.files);
        };
        if (_fileInput.addEventListener) {
            _fileInput.addEventListener('change', _afterLoaded);
        }
        _fileInput.click();
    }
    U1.OpenFileDialog = OpenFileDialog;
    function SaveTextFile(output, type = 'text/xml', file = 'test.xml') {
        var blob = new Blob([output], { type: type });
        var objectURL = URL.createObjectURL(blob);
        if (_link == null) {
            _link = document.createElement('a');
            _link.style.display = 'none';
            document.body.appendChild(_link);
        }
        if (navigator.msSaveBlob) {
            var blob = new Blob([output], {
                "type": type + ";charset=utf-8;"
            });
            navigator.msSaveBlob(blob, file);
        }
        else {
            _link.href = objectURL;
            _link.download = file;
            _link.target = '_blank';
            var event = document.createEvent("MouseEvents");
            event.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            _link.click();
        }
    }
    U1.SaveTextFile = SaveTextFile;
    function SaveImageFile(canvas, file = 'image.png') {
        if (navigator.msSaveBlob) {
            canvas.style.background = "1";
        }
        else {
            var lnk = document.createElement('a');
            lnk.download = file;
            lnk.href = canvas.toDataURL('image / png');
            if (document.createEvent) {
                var e = document.createEvent("MouseEvents");
                e.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                lnk.dispatchEvent(e);
            }
            else if (lnk.fireEvent) {
                lnk.fireEvent("onclick");
            }
        }
    }
    U1.SaveImageFile = SaveImageFile;
    let MessageBoxButton;
    (function (MessageBoxButton) {
        MessageBoxButton[MessageBoxButton["OK"] = 0] = "OK";
        MessageBoxButton[MessageBoxButton["OKCancel"] = 1] = "OKCancel";
    })(MessageBoxButton = U1.MessageBoxButton || (U1.MessageBoxButton = {}));
    let MessageBoxResult;
    (function (MessageBoxResult) {
        MessageBoxResult[MessageBoxResult["None"] = 0] = "None";
        MessageBoxResult[MessageBoxResult["OK"] = 1] = "OK";
        MessageBoxResult[MessageBoxResult["Cancel"] = 2] = "Cancel";
        MessageBoxResult[MessageBoxResult["Yes"] = 6] = "Yes";
        MessageBoxResult[MessageBoxResult["No"] = 7] = "No";
    })(MessageBoxResult = U1.MessageBoxResult || (U1.MessageBoxResult = {}));
    class MessageBox {
        static Show(message, title = "", button = MessageBoxButton.OK) {
            alert(message + title);
            return MessageBoxResult.OK;
        }
    }
    U1.MessageBox = MessageBox;
    class UDispatcher {
        static BeginInvoke(func, ...arg) {
            setTimeout(func, 10, arg);
        }
        static BeginInvokeDelay(func, delay, ...arg) {
            setTimeout(func, delay, arg);
        }
    }
    U1.UDispatcher = UDispatcher;
    class AddressParams {
        static getParameter(name) {
            var rtnval = '';
            var nowAddress = decodeURI(location.href);
            var parameters = (nowAddress.slice(nowAddress.indexOf('?') + 1, nowAddress.length)).split('&');
            for (var i = 0; i < parameters.length; i++) {
                var varName = parameters[i].split('=')[0];
                if (varName.toUpperCase() == name.toUpperCase()) {
                    rtnval = parameters[i].split('=')[1];
                    break;
                }
            }
            return rtnval;
        }
        static getParameters() {
            var result = {};
            var nowAddress = decodeURI(location.href);
            var startParams = nowAddress.indexOf('?') + 1;
            if (startParams <= 0)
                return result;
            var parameters = (nowAddress.slice(startParams, nowAddress.length)).split('&');
            for (var i = 0; i < parameters.length; i++) {
                var varName = parameters[i].split('=')[0];
                if (varName == null || varName == "")
                    continue;
                var varValue = parameters[i].split('=')[1] || "";
                result[varName] = varValue;
            }
            return result;
        }
    }
    U1.AddressParams = AddressParams;
    function isIE9() {
        var agent = navigator.userAgent.toLowerCase();
        if ((agent.indexOf("msie 9") != -1)) {
            return true;
        }
        return false;
    }
    U1.isIE9 = isIE9;
    function IsLeftMouseDown(event) {
        if (event.type !== "mousedown")
            return false;
        if ('buttons' in event) {
            return (event.buttons & 1) === 1;
        }
        else if ('which' in event) {
            return event.which === 1;
        }
        else {
            return (event.button & 1) === 1;
        }
    }
    U1.IsLeftMouseDown = IsLeftMouseDown;
    function IsRightMouseDown(event) {
        if (event.type !== "mousedown")
            return false;
        if ('buttons' in event) {
            return (event.buttons & 2) === 2;
        }
        else if ('which' in event) {
            return event.which === 3;
        }
        else {
            return (event.button & 2) === 2;
        }
    }
    U1.IsRightMouseDown = IsRightMouseDown;
    function IsMiddleMouseDown(event) {
        if (event.type !== "mousedown")
            return false;
        if ('buttons' in event) {
            return (event.buttons & 4) === 4;
        }
        else if ('which' in event) {
            return event.which === 2;
        }
        else {
            return (event.button & 4) === 4;
        }
    }
    U1.IsMiddleMouseDown = IsMiddleMouseDown;
    function IsLeftMouseDrag(event) {
        if (event.type !== "mousemove")
            return false;
        if ('buttons' in event) {
            return (event.buttons & 1) === 1;
        }
        else if ('which' in event) {
            return event.which === 1;
        }
        else {
            return (event.button & 1) === 1;
        }
    }
    U1.IsLeftMouseDrag = IsLeftMouseDrag;
    function IsRightMouseDrag(event) {
        if (event.type !== "mousemove")
            return false;
        if ('buttons' in event) {
            return (event.buttons & 2) === 2;
        }
        else if ('which' in event) {
            return event.which === 3;
        }
        else {
            return (event.button & 2) === 2;
        }
    }
    U1.IsRightMouseDrag = IsRightMouseDrag;
    function IsMiddleMouseDrag(event) {
        if (event.type !== "mousemove")
            return false;
        if ('which' in event) {
            return event.which === 2;
        }
        else if ('buttons' in event) {
            return (event.buttons & 4) === 4;
        }
        else {
            return (event.button & 4) === 4;
        }
    }
    U1.IsMiddleMouseDrag = IsMiddleMouseDrag;
    function IsLeftMouseUp(event) {
        if (event.type !== "mouseup")
            return false;
        if ('which' in event) {
            return event.which === 1;
        }
        else if ('buttons' in event) {
            return (event.buttons & 1) === 1;
        }
        else {
            return (event.button & 1) === 1;
        }
    }
    U1.IsLeftMouseUp = IsLeftMouseUp;
    function IsRightMouseUp(event) {
        if (event.type !== "mouseup")
            return false;
        if ('which' in event) {
            return event.which === 3;
        }
        else if ('buttons' in event) {
            return (event.buttons & 2) === 2;
        }
        else {
            return (event.button & 2) === 2;
        }
    }
    U1.IsRightMouseUp = IsRightMouseUp;
    function IsMiddleMouseUp(event) {
        if (event.type !== "mouseup")
            return false;
        if ('which' in event) {
            return event.which === 2;
        }
        else if ('buttons' in event) {
            return (event.buttons & 4) === 4;
        }
        else {
            return (event.button & 4) === 4;
        }
    }
    U1.IsMiddleMouseUp = IsMiddleMouseUp;
    class Random {
        constructor(seed) {
            this.seed = 1;
            seed = seed || 1;
        }
        next() {
            var x = Math.sin(this.seed++) * 10000;
            return x - Math.floor(x);
        }
    }
    U1.Random = Random;
    class BinaryReader {
        constructor(buffer) {
            this._loc = 0;
            if (buffer instanceof DataView) {
                this._dataView = buffer;
            }
            else {
                this._dataView = new DataView(buffer);
            }
        }
        get Location() {
            return this._loc;
        }
        set Location(value) {
            this._loc = value;
        }
        get Length() {
            return this._dataView.buffer.byteLength;
        }
        get IsEOF() {
            return this._loc >= this._dataView.buffer.byteLength;
        }
        ReadInt8() {
            var res = this._dataView.getInt8(this._loc);
            this._loc += 1;
            return res;
        }
        ReadInt16() {
            var res = this._dataView.getInt16(this._loc, true);
            this._loc += 2;
            return res;
        }
        ReadInt32() {
            var res = this._dataView.getInt32(this._loc, true);
            this._loc += 4;
            return res;
        }
        ReadUint8() {
            var res = this._dataView.getUint8(this._loc);
            this._loc += 1;
            return res;
        }
        ReadUint16() {
            var res = this._dataView.getUint16(this._loc, true);
            this._loc += 2;
            return res;
        }
        ReadUint32() {
            var res = this._dataView.getUint32(this._loc, true);
            this._loc += 4;
            return res;
        }
        ReadFloat32() {
            var res = this._dataView.getFloat32(this._loc, true);
            this._loc += 4;
            return res;
        }
        ReadFloat64() {
            var res = this._dataView.getFloat64(this._loc, true);
            this._loc += 8;
            return res;
        }
        Slice(begin, end) {
            return this._dataView.buffer.slice(begin, end);
        }
    }
    U1.BinaryReader = BinaryReader;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UDocument {
        constructor() {
            this._last_id = 0;
            this.m_elementsByTypes = {};
            this._elements = {};
            this._undoStack = [];
            this._redoStack = [];
            this._selection = new USelection(this);
            this.PropertyChanged = new U1.PropertyChangedEvent();
            this.ElementAdded = new U1.Event2();
            this.ElementRemoving = new U1.Event2();
            this.AfterUndoRedo = new U1.Event2();
            this.BeforeEndTransaction = new U1.Event1();
            this.AfterEndTransaction = new U1.Event1();
            this.AfterAbortTransaction = new U1.Event1();
            this.ElementChanged = new U1.Event3();
            this.BeforeClear = new U1.Event1();
            this.AfterClear = new U1.Event1();
            this.BeforeLoading = new U1.Event1();
            this.AfterLoaded = new U1.Event1();
            this.AfterChanged = new U1.Event1();
        }
        static Register(name, c = null) {
            if (typeof name === "string") {
                UDocument.Creaters[name] = c;
            }
            else {
                var funcNameRegex = /function (.{1,})\(/;
                var results = (funcNameRegex).exec(c.toString());
                var key = (results && results.length > 1) ? results[1] : "";
                UDocument.Creaters[key] = name;
            }
        }
        AddMaterial(name) {
            if (name == null || name == "")
                return;
            var matset = this.GetElementsByType(U1.MaterialSet)[0];
            if (matset == null) {
                matset = new U1.MaterialSet();
                this.Append(matset);
            }
            return matset.AddItemByName(U1.Material, name);
        }
        GetMaterialById(id) {
            if (id < 0)
                return null;
            var matset = this.GetElementsByType(U1.MaterialSet)[0];
            if (matset == null)
                return null;
            return matset.GetItemByID(U1.Material, id);
        }
        GetMaterialByName(name) {
            var matset = this.GetElementsByType(U1.MaterialSet)[0];
            if (matset == null)
                return null;
            return matset.GetItemByName(U1.Material, name);
        }
        GetMaterialItems() {
            var matset = this.GetElementsByType(U1.MaterialSet)[0];
            if (matset == null)
                return new Array();
            var materials = new Array();
            return matset.Items(U1.Material).filter(o_ => o_);
        }
        AddTexture(name) {
            if (name == null || name == "")
                return;
            var txtset = this.GetElementsByType(U1.TextureSet)[0];
            if (txtset == null) {
                txtset = new U1.TextureSet();
                this.Append(txtset);
            }
            return txtset.AddItemByName(U1.MTexture, name);
        }
        GetTextureById(id) {
            if (id < 0)
                return null;
            var txtset = this.GetElementsByType(U1.TextureSet)[0];
            if (txtset == null)
                return null;
            return txtset.GetItemByID(U1.MTexture, id);
        }
        GetTextureByName(name) {
            var txtset = this.GetElementsByType(U1.TextureSet)[0];
            if (txtset == null)
                return null;
            return txtset.GetItemByName(U1.MTexture, name);
        }
        GetTextureItems() {
            var txtset = this.GetElementsByType(U1.TextureSet)[0];
            if (txtset == null)
                return new Array();
            return txtset.Items(U1.MTexture).filter(o_ => o_);
        }
        get CurrentTransaction() {
            return this._currentTransaction;
        }
        get IsLoading() {
            return this.isLoading;
        }
        get IsUndoRedo() {
            return this.isUndoRedo;
        }
        get Elements() {
            let res = [];
            for (let idx in this._elements) {
                let elm = this._elements[idx];
                if (elm instanceof U1.UElement)
                    res.push(elm);
            }
            return res;
        }
        GetElementsByType(ctor) {
            var result = [];
            for (var id in UDocument.m_element_dumy_instancs) {
                var dumy_obj = UDocument.m_element_dumy_instancs[id];
                if (dumy_obj instanceof ctor) {
                    result.push(...this.m_elementsByTypes[id]);
                }
            }
            return result;
        }
        get Selection() {
            return this._selection;
        }
        get CanUndo() {
            return this._undoStack.length > 0;
        }
        get CanRedo() {
            return this._redoStack.length > 0;
        }
        GetElement(id) {
            return this._elements[id];
        }
        Append(element) {
            this.AssignDocument(element);
            if (this._currentTransaction != null) {
                let cmd = new U1.UUndoCmdAppend(this, element);
                this._currentTransaction.AddCommand(cmd);
            }
        }
        Remove(element) {
            if (element.Document != this)
                return;
            this.WithdrawDocument(element);
            if (this._currentTransaction != null) {
                let cmd = new U1.UUndoCmdRemove(this, element);
                this._currentTransaction.AddCommand(cmd);
            }
        }
        AddInstance(typeName, id) {
            let creater = UDocument.Creaters[typeName];
            let inst = new creater();
            inst["_id"] = id;
            inst["_document"] = this;
            this._elements[inst.ID] = inst;
            this._last_id = Math.max(id, this._last_id);
        }
        AssignDocument(element) {
            if (element.ID != null && this._elements[element.ID] != null)
                throw "The document already contains same id.";
            if (element.Document != null)
                throw "The element already has a document.";
            if (element.ID == null || element.ID == 0) {
                element["_id"] = ++this._last_id;
            }
            else {
                this._last_id = Math.max(this._last_id, element.ID);
            }
            element["_document"] = this;
            this._elements[element.ID] = element;
            this.AddElementToTypeTable(element);
            if (element instanceof U1.UNode) {
                for (var ch of element.Children)
                    this.AssignDocument(ch);
            }
            this.InvokeElementAttached(element);
        }
        WithdrawDocument(element) {
            if (element.Document != this)
                return;
            if (element instanceof U1.UNode) {
                for (var ch of element.Children)
                    this.WithdrawDocument(ch);
            }
            element.InvokeRemoving();
            this.InvokeElementRemoving(element);
            element["_document"] = undefined;
            this.RemoveElementFromTypeTable(element);
            delete this._elements[element.ID];
        }
        AddElementToTypeTable(instance) {
            if (!instance.ClassifiedByType())
                return;
            var ctor = instance.constructor;
            if (ctor.U_TYPE_ID == null) {
                ctor.U_TYPE_ID = ++UDocument.last_type_id;
                UDocument.m_element_dumy_instancs[ctor.U_TYPE_ID] = new ctor();
            }
            ;
            if (this.m_elementsByTypes[ctor.U_TYPE_ID] == null) {
                this.m_elementsByTypes[ctor.U_TYPE_ID] = [];
            }
            this.m_elementsByTypes[ctor.U_TYPE_ID].push(instance);
        }
        RemoveElementFromTypeTable(element) {
            if (!element.ClassifiedByType())
                return;
            var ctor = element.constructor;
            if (this.m_elementsByTypes[ctor.U_TYPE_ID] != null) {
                var idx = this.m_elementsByTypes[ctor.U_TYPE_ID].indexOf(element);
                this.m_elementsByTypes[ctor.U_TYPE_ID].splice(idx, 1);
            }
        }
        BeginTransaction() {
            var tr = new U1.UTransactoin();
            if (this._currentTransaction != null) {
                this._currentTransaction.Append(tr);
            }
            this._currentTransaction = tr;
            if (this._rootTransaction == null) {
                this._rootTransaction = this._currentTransaction;
            }
            return tr;
        }
        EndTransaction(transaction) {
            if (transaction == null)
                transaction = this._currentTransaction;
            let tmp = this._currentTransaction;
            while (tmp != transaction) {
                tmp = tmp.Parent;
            }
            if (tmp != transaction)
                return;
            this.InvokeBeforeEndTransaction();
            if (transaction != null) {
                transaction.OnEnd();
                this._currentTransaction = transaction.Parent;
            }
            else {
                this._currentTransaction = null;
            }
            if (this._currentTransaction == null) {
                if (this._rootTransaction != null) {
                    if (this._rootTransaction.HasCommands()) {
                        this._undoStack.push(this._rootTransaction);
                        this._redoStack.length = 0;
                        this._rootTransaction = null;
                        this.InvokePropertyChanged("Undo");
                        this.InvokePropertyChanged("Redo");
                    }
                    else {
                        this._rootTransaction = null;
                    }
                }
            }
            this.InvokeAfterEndTransaction();
        }
        AbortTransaction(transaction) {
            if (transaction == null)
                transaction = this._currentTransaction;
            if (this._rootTransaction == null)
                return;
            let tmp = transaction;
            while (tmp != this._rootTransaction) {
                tmp = tmp.Parent;
            }
            if (tmp != this._rootTransaction)
                return;
            if (transaction != null) {
                this._currentTransaction = null;
                transaction.Cancel();
                this._currentTransaction = transaction.Parent;
            }
            if (this._currentTransaction == null) {
                this._rootTransaction = null;
            }
            this.InvokeAfterAbortTransaction();
        }
        Undo() {
            this.isUndoRedo = true;
            if (this._undoStack.length > 0) {
                var cmd = this._undoStack.pop();
                cmd.Undo();
                this._redoStack.push(cmd);
            }
            this.isUndoRedo = false;
            this.InvokeAfterUndoRedo(true);
        }
        Redo() {
            this.isUndoRedo = true;
            if (this._redoStack.length > 0) {
                var cmd = this._redoStack.pop();
                cmd.Redo();
                this._undoStack.push(cmd);
            }
            this.isUndoRedo = false;
            this.InvokeAfterUndoRedo(false);
        }
        Clear() {
            this._elements = {};
            this._last_id = 0;
            this._undoStack = [];
            this._redoStack = [];
            this._rootTransaction = undefined;
            this._currentTransaction = undefined;
            this.isLoading = false;
            this.isUndoRedo = false;
            this.InvokeBeforeClear();
            this.Selection.Clear();
            this.InvokeAfterClear();
        }
        ClearUndoHistory() {
            this._undoStack.length = 0;
            this._redoStack.length = 0;
        }
        BeginLoad() {
            this.Clear();
            this.isLoading = true;
            this.BeforeLoading.Invoke(this);
        }
        EndLoad() {
            this.isLoading = false;
            for (var elm of this.Elements) {
                elm.OnInitAfterLoaded();
            }
            this.AfterLoaded.Invoke(this);
        }
        InvokeElementAttached(element) {
            if (this.isLoading)
                return;
            this.ElementAdded.Invoke(this, element);
        }
        InvokeElementRemoving(element) {
            if (this.isLoading)
                return;
            this.Selection.Remove(element);
            this.ElementRemoving.Invoke(this, element);
        }
        InvokeAfterUndoRedo(isUndo) {
            if (this.isLoading)
                return;
            this.AfterUndoRedo.Invoke(this, isUndo);
            this.InvokeAfterChanged();
        }
        InvokeBeforeEndTransaction() {
            if (this.isLoading)
                return;
            this.BeforeEndTransaction.Invoke(this);
        }
        InvokeAfterEndTransaction() {
            if (this.isLoading)
                return;
            this.AfterEndTransaction.Invoke(this);
            this.InvokeAfterChanged();
        }
        InvokeAfterAbortTransaction() {
            if (this.isLoading)
                return;
            this.AfterAbortTransaction.Invoke(this);
            this.InvokeAfterChanged();
        }
        InvokeElementChanged(element, prop) {
            if (this.isLoading)
                return;
            this.ElementChanged.Invoke(this, element, prop);
        }
        InvokeBeforeClear() {
            this.BeforeClear.Invoke(this);
        }
        InvokeAfterClear() {
            this.AfterClear.Invoke(this);
            this.InvokeAfterChanged();
        }
        InvokeAfterChanged() {
            this.AfterChanged.Invoke(this);
        }
        InvokePropertyChanged(prop) {
            this.PropertyChanged.Invoke(this, prop);
        }
        ReadFromFile(file) {
            this.Clear();
            this.file = file.name;
            var extension = file.name.split('.').pop().toLowerCase();
            var reader = new FileReader();
            reader.onload = (evt) => {
                var xmlText = reader.result;
                var xdoc = new DOMParser().parseFromString(xmlText, "text/xml");
                this.ReadFromXMLDocument(xdoc);
            };
            reader.readAsText(file);
        }
        ReadFromXMLDocument(xml, callback = null) {
            var ubimXml = xml.getElementsByTagName("UBim")[0];
            var ubimZip = xml.getElementsByTagName("UBimZip")[0];
            if (ubimXml != null) {
                this.BeginLoad();
                this.ReadXmlDocument(xml);
                this.EndLoad();
                if (callback != null)
                    callback();
            }
            else if (ubimZip != null) {
                this.ReadXmlDocumentZip(xml, callback);
            }
        }
        ReadXmlDocumentZip(xml, callback = null) {
            this.BeginLoad();
            var xContent = xml.getElementsByTagName("Content")[0];
            var content = xContent.textContent;
            var opt = {
                base64: true
            };
            var new_zip = new JSZip();
            new_zip.loadAsync(content, opt)
                .then(function (zip) {
                return zip.file("document.xml")
                    .async("text");
            })
                .then((xmlText) => {
                var xdoc = new DOMParser().parseFromString(xmlText, "text/xml");
                this.ReadXmlDocument(xdoc);
                if (callback != null)
                    callback();
                this.EndLoad();
            });
        }
        Load(xDoc) {
            this.BeginLoad();
            this.ReadXmlDocument(xDoc);
            this.EndLoad();
        }
        ReadXmlDocument_(xml) {
            var xElements = xml.getElementsByTagName("Elements")[0];
            var elmNodes = xElements.childNodes;
            let bags = {};
            this._last_id = 0;
            for (var i = 0; i < elmNodes.length; i++) {
                var xelm = elmNodes[i];
                var typeName = xelm.nodeName;
                if (typeName == "#text")
                    continue;
                let id = 0;
                var data = {};
                if (xelm.attributes.getNamedItem("id"))
                    id = parseInt(xelm.attributes.getNamedItem("id").value);
                let attr_len = xelm.attributes.length;
                for (let i = 0; i < attr_len; i++) {
                    let attr = xelm.attributes.item(i);
                    if (attr.name == "id")
                        continue;
                    data[attr.name] = attr.value;
                }
                var prnodes = xelm.childNodes;
                for (var j = 0; j < prnodes.length; j++) {
                    var pr_node = prnodes[j];
                    var prname = pr_node.nodeName;
                    if (prname == "#text")
                        continue;
                    data[prname] = pr_node.textContent;
                }
                let bag = new U1.UPropertyStrBag();
                bag.Props = data;
                bags[id] = bag;
                let creater = UDocument.Creaters[typeName];
                let inst = new creater();
                this.AddInstance(typeName, id);
            }
            for (let elm of this.Elements) {
                let bag = bags[elm.ID];
                elm.ReadProps(bag);
            }
        }
        ReadXmlDocument(xml) {
            var xElements = xml.getElementsByTagName("Elm");
            let bags = {};
            this._last_id = 0;
            let elements = {};
            for (var i = 0; i < xElements.length; i++) {
                var xelm = xElements[i];
                let id = 0;
                let ty = "";
                var data = {};
                if (xelm.attributes.getNamedItem("ID"))
                    id = parseInt(xelm.attributes.getNamedItem("ID").value);
                if (xelm.attributes.getNamedItem("Ty"))
                    ty = xelm.attributes.getNamedItem("Ty").value;
                let attr_len = xelm.attributes.length;
                for (let i = 0; i < attr_len; i++) {
                    let attr = xelm.attributes.item(i);
                    if (attr.name == "ID")
                        continue;
                    if (attr.name == "Ty")
                        continue;
                    var strName = attr.name;
                    var strVal = attr.value;
                    if (strName.StartsWith("_")) {
                        strName = strName.substr(1);
                    }
                    data[strName] = strVal;
                }
                let bag = new U1.UPropertyStrBag();
                bag.Props = data;
                bags[id] = bag;
                this.AddInstance(ty, id);
            }
            for (let elm of this.Elements) {
                let bag = bags[elm.ID];
                elm.ReadProps(bag);
            }
        }
        static formatXml(xml) {
            var formatted = '';
            var reg = /(>)(<)(\/*)/g;
            xml = xml.replace(reg, '$1\r\n$2$3');
            var pad = 0;
            jQuery.each(xml.split('\r\n'), function (index, node) {
                var indent = 0;
                if (node.match(/.+<\/\w[^>]*>$/)) {
                    indent = 0;
                }
                else if (node.match(/^<\/\w/)) {
                    if (pad != 0) {
                        pad -= 1;
                    }
                }
                else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {
                    indent = 1;
                }
                else {
                    indent = 0;
                }
                var padding = '';
                for (var i = 0; i < pad; i++) {
                    padding += '  ';
                }
                formatted += padding + node + '\r\n';
                pad += indent;
            });
            return formatted;
        }
        ToXmlString() {
            var xmlText = `<?xml version="1.0" encoding="UTF-8"?>
<UBim></UBim>`;
            var xdoc = new DOMParser().parseFromString(xmlText, "text/xml");
            var xelems = xdoc.createElement("Elements");
            xdoc.documentElement.appendChild(xelems);
            for (var elm of this.Elements) {
                var xelm = xdoc.createElement(elm.GetTypeName());
                var idAttr = xdoc.createAttribute("id");
                idAttr.value = "" + elm.ID;
                xelm.attributes.setNamedItem(idAttr);
                xelems.appendChild(xelm);
                let bag = new U1.UPropertyStrBag();
                bag.Doc = this;
                elm.WriteProps(bag);
                let props = bag.Props;
                for (let prop in props) {
                    var valText = props[prop];
                    if (valText != null && valText != "") {
                        let attr = xdoc.createAttribute(prop);
                        attr.value = valText;
                        xelm.attributes.setNamedItem(attr);
                    }
                }
            }
            var result = new XMLSerializer().serializeToString(xdoc);
            result = UDocument.formatXml(result);
            return result;
        }
        getXmlZipStringAsync(callback) {
            var xmlText = `<?xml version="1.0" encoding="UTF-8"?>
<UBimZip></UBimZip>`;
            var xdoc = new DOMParser().parseFromString(xmlText, "text/xml");
            var content = this.ToXmlString();
            var opt = {
                type: "base64",
                compression: "DEFLATE"
            };
            var zip = new JSZip();
            zip.file("document.xml", content);
            zip
                .generateAsync(opt)
                .then(function (base64) {
                var text = xdoc.createTextNode(base64);
                var zipContent = xdoc.createElement("Content");
                zipContent.appendChild(text);
                xdoc.documentElement.appendChild(zipContent);
                var result = new XMLSerializer().serializeToString(xdoc);
                result = UDocument.formatXml(result);
                callback(result);
            });
        }
    }
    UDocument.last_type_id = 0;
    UDocument.m_element_dumy_instancs = {};
    UDocument.Creaters = {};
    U1.UDocument = UDocument;
    class UEditor {
        PickPoint() {
            return null;
        }
    }
    U1.UEditor = UEditor;
    class USelection {
        constructor(doc) {
            this.SelectionChanged = new U1.Event1();
            this._selection = new Array();
            this._document = doc;
        }
        InvokeSelectionChanged() {
            this.SelectionChanged.Invoke(this);
        }
        get Document() {
            return this._document;
        }
        get Count() {
            return this._selection.length;
        }
        get SelectedElements() {
            var result = new Array();
            this._selection.forEach((eid_) => {
                var elm = this._document.GetElement(eid_);
                if (elm != null)
                    result.push(elm);
            });
            return result;
        }
        get SelectionFilter() {
            return this._selectionFilter;
        }
        set SelectionFilter(value) {
            this._selectionFilter = value;
            if (this._selectionFilter != null) {
                var selection = new Array();
                var isChanged = false;
                for (var eid of this._selection) {
                    var elm = this._document.GetElement(eid);
                    if (elm == null || !this._selectionFilter(elm)) {
                        isChanged = true;
                        continue;
                    }
                    selection.push(elm.ID);
                }
                if (isChanged) {
                    this._selection = selection;
                    this.InvokeSelectionChanged();
                }
            }
        }
        Contains(element) {
            if (this._selection.indexOf(element.ID) > -1)
                return true;
            return false;
        }
        Add(element, clear) {
            if (this.SelectionFilter != null && !this.SelectionFilter(element))
                return;
            var isChanged = false;
            if (clear && this._selection.length > 0) {
                if (this._selection.length == 1 && this._selection.indexOf(element.ID) > -1)
                    return;
                isChanged = true;
                this.UnSelect();
            }
            if (this._selection.indexOf(element.ID) == -1) {
                isChanged = true;
                this._selection.push(element.ID);
            }
            if (isChanged) {
                this.InvokeSelectionChanged();
            }
        }
        Remove(element) {
            var isChanged = false;
            var idx = this._selection.indexOf(element.ID);
            if (idx >= 0) {
                isChanged = true;
                this._selection.splice(idx, 1);
            }
            if (isChanged) {
                this.InvokeSelectionChanged();
            }
        }
        RemoveRange(elements) {
            var isChanged = false;
            for (var element of elements) {
                var selection = this._selection;
                if (!selection.Contains(element.ID))
                    continue;
                var idx = selection.indexOf(element.ID);
                selection.splice(idx, 1);
                isChanged = true;
            }
            if (isChanged) {
                this.InvokeSelectionChanged();
            }
        }
        AddRange(elements, clear) {
            var isChanged = false;
            if (clear) {
                isChanged = this._selection.length > 0;
                this.UnSelect();
            }
            for (var elm of elements) {
                if (this.SelectionFilter != null && !this.SelectionFilter(elm))
                    continue;
                if (this._selection.indexOf(elm.ID) == -1) {
                    this._selection.push(elm.ID);
                    isChanged = true;
                }
            }
            if (isChanged) {
                this.InvokeSelectionChanged();
            }
        }
        Clear() {
            if (this._selection.length == 0)
                return;
            this.UnSelect();
            this.InvokeSelectionChanged();
        }
        UnSelect() {
            this._selection.splice(0, this._selection.length);
        }
    }
    U1.USelection = USelection;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Vector2 {
        constructor(x = 0, y) {
            this.X = x;
            this.Y = (y == undefined ? 0 : y);
        }
        ConvertFromStr(value) {
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            this.X = items.length > 0 ? items[0] : 0;
            this.Y = items.length > 1 ? items[1] : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this.X, this.Y);
        }
        CopyFrom(other) {
            this.X = other.X;
            this.Y = other.Y;
            return this;
        }
        toString() {
            return "(" + this.X + "," + this.Y + ")";
        }
        Clone() {
            return new Vector2(this.X, this.Y);
        }
        get Left() {
            return Vector2.Create(-this.Y, this.X);
        }
        get Right() {
            return Vector2.Create(this.Y, -this.X);
        }
        LeftRef(ref) {
            var x = -this.Y;
            var y = this.X;
            ref.X = x;
            ref.Y = y;
            return ref;
        }
        RightRef(ref) {
            var x = this.Y;
            var y = -this.X;
            ref.X = x;
            ref.Y = y;
            return ref;
        }
        static LeftTop(ps) {
            var result = new Vector2(Number.MAX_VALUE, Number.MIN_VALUE);
            for (var p of ps) {
                if (p.X < result.X)
                    result.X = p.X;
                if (p.Y > result.Y)
                    result.Y = p.Y;
            }
            return result;
        }
        static RightTop(ps) {
            var result = Vector2.MinValue;
            for (var p of ps) {
                if (p.X > result.X)
                    result.X = p.X;
                if (p.Y > result.Y)
                    result.Y = p.Y;
            }
            return result;
        }
        static RightBottom(ps) {
            var result = new Vector2(Number.MIN_VALUE, Number.MAX_VALUE);
            for (var p of ps) {
                if (p.X > result.X)
                    result.X = p.X;
                if (p.Y < result.Y)
                    result.Y = p.Y;
            }
            return result;
        }
        static LeftBottom(ps) {
            var result = Vector2.MaxValue;
            for (var p of ps) {
                if (p.X < result.X)
                    result.X = p.X;
                if (p.Y < result.Y)
                    result.Y = p.Y;
            }
            return result;
        }
        static get MaxValue() {
            return new Vector2(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        static get MinValue() {
            return new Vector2(Number.MIN_VALUE, Number.MIN_VALUE);
        }
        SetMaxValue() {
            this.X = Number.MAX_VALUE;
            this.Y = Number.MAX_VALUE;
            return this;
        }
        SetMinValue() {
            this.X = Number.MIN_VALUE;
            this.Y = Number.MIN_VALUE;
            return this;
        }
        Set(x, y) {
            if (x instanceof Vector2) {
                this.X = x.X;
                this.Y = x.Y;
            }
            else {
                this.X = x;
                this.Y = y;
            }
            return this;
        }
        Equals(other) {
            return ((this.X === other.X) && (this.Y === other.Y));
        }
        EpsilonEquals(point1, epsilon = U1.Epsilon) {
            if (Math.abs(point1.X - this.X) > epsilon)
                return false;
            if (Math.abs(point1.Y - this.Y) > epsilon)
                return false;
            return true;
        }
        static EpsilonEquals(point0, point1, epsilon = U1.Epsilon) {
            if (Math.abs(point1.X - point0.X) > epsilon)
                return false;
            if (Math.abs(point1.Y - point0.Y) > epsilon)
                return false;
            return true;
        }
        Length() {
            var num = (this.X * this.X) + (this.Y * this.Y);
            return Math.sqrt(num);
        }
        LengthSquareduared() {
            return ((this.X * this.X) + (this.Y * this.Y));
        }
        static Distance(value1, value2) {
            var num2 = +(value1.X - value2.X);
            var num = +(value1.Y - value2.Y);
            var num3 = +((num2 * num2) + (num * num));
            return +Math.sqrt(num3);
        }
        static DistanceSquared(value1, value2) {
            var num2 = value1.X - value2.X;
            var num = value1.Y - value2.Y;
            return ((num2 * num2) + (num * num));
        }
        static Dot(a, b) {
            return a.X * b.X + a.Y * b.Y;
        }
        Normalize() {
            var num2 = (this.X * this.X) + (this.Y * this.Y);
            var num = 1 / (Math.sqrt(num2));
            this.X *= num;
            this.Y *= num;
            return this;
        }
        static Normalize(value, result = null) {
            if (result == null)
                result = new Vector2();
            var num2 = (value.X * value.X) + (value.Y * value.Y);
            var num = 1 / (Math.sqrt(num2));
            return result.Set(value.X * num, value.Y * num);
        }
        SetNormalize(value) {
            var num2 = (value.X * value.X) + (value.Y * value.Y);
            var num = 1 / (Math.sqrt(num2));
            this.X = value.X * num;
            this.Y = value.Y * num;
            return this;
        }
        static Reflect(vector, normal, result = null) {
            if (result == null)
                result = new Vector2();
            var num = (vector.X * normal.X) + (vector.Y * normal.Y);
            return result.Set(vector.X - ((2 * num) * normal.X), vector.Y - ((2 * num) * normal.Y));
        }
        SetReflect(vector, normal) {
            var num = (vector.X * normal.X) + (vector.Y * normal.Y);
            this.X = vector.X - ((2 * num) * normal.X);
            this.Y = vector.Y - ((2 * num) * normal.Y);
            return this;
        }
        static Min(value1, value2, result = null) {
            if (result == null)
                result = new Vector2();
            result.X = (value1.X < value2.X) ? value1.X : value2.X;
            result.Y = (value1.Y < value2.Y) ? value1.Y : value2.Y;
            return result;
        }
        SetMin(value1, value2) {
            this.X = (value1.X < value2.X) ? value1.X : value2.X;
            this.Y = (value1.Y < value2.Y) ? value1.Y : value2.Y;
            return this;
        }
        static Max(value1, value2, result = null) {
            if (result == null)
                result = new Vector2();
            result.X = (value1.X > value2.X) ? value1.X : value2.X;
            result.Y = (value1.Y > value2.Y) ? value1.Y : value2.Y;
            return result;
        }
        SetMax(value1, value2) {
            this.X = (value1.X > value2.X) ? value1.X : value2.X;
            this.Y = (value1.Y > value2.Y) ? value1.Y : value2.Y;
            return this;
        }
        static Clamp(value1, min, max, result = null) {
            if (result == null)
                result = new Vector2();
            var x = value1.X;
            x = (x > max.X) ? max.X : x;
            x = (x < min.X) ? min.X : x;
            var y = value1.Y;
            y = (y > max.Y) ? max.Y : y;
            y = (y < min.Y) ? min.Y : y;
            result.X = x;
            result.Y = y;
            return result;
        }
        SetClamp(value1, min, max) {
            var x = value1.X;
            x = (x > max.X) ? max.X : x;
            x = (x < min.X) ? min.X : x;
            var y = value1.Y;
            y = (y > max.Y) ? max.Y : y;
            y = (y < min.Y) ? min.Y : y;
            this.X = x;
            this.Y = y;
            return this;
        }
        static Lerp(value1, value2, amount, result = null) {
            if (result == null)
                result = new Vector2();
            result.X = value1.X + ((value2.X - value1.X) * amount);
            result.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            return result;
        }
        SetLerp(value1, value2, amount) {
            this.X = value1.X + ((value2.X - value1.X) * amount);
            this.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            return this;
        }
        static Barycentric(value1, value2, value3, amount1, amount2, result = null) {
            var vector = result != null ? result : new Vector2();
            vector.X = (value1.X + (amount1 * (value2.X - value1.X))) + (amount2 * (value3.X - value1.X));
            vector.Y = (value1.Y + (amount1 * (value2.Y - value1.Y))) + (amount2 * (value3.Y - value1.Y));
            return vector;
        }
        SetBarycentric(value1, value2, value3, amount1, amount2) {
            this.X = (value1.X + (amount1 * (value2.X - value1.X))) + (amount2 * (value3.X - value1.X));
            this.Y = (value1.Y + (amount1 * (value2.Y - value1.Y))) + (amount2 * (value3.Y - value1.Y));
            return this;
        }
        static SmoothStep(value1, value2, amount, result = null) {
            var vector = result != null ? result : new Vector2();
            amount = (amount > 1) ? 1 : ((amount < 0) ? 0 : amount);
            amount = (amount * amount) * (3 - (2 * amount));
            vector.X = value1.X + ((value2.X - value1.X) * amount);
            vector.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            return vector;
        }
        SetSmoothStep(value1, value2, amount) {
            amount = (amount > 1) ? 1 : ((amount < 0) ? 0 : amount);
            amount = (amount * amount) * (3 - (2 * amount));
            this.X = value1.X + ((value2.X - value1.X) * amount);
            this.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            return this;
        }
        static CatmullRom(value1, value2, value3, value4, amount, result) {
            var vector = result != null ? result : new Vector2();
            var num = amount * amount;
            var num2 = amount * num;
            vector.X = 0.5 * ((((2 * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2 * value1.X) - (5 * value2.X)) + (4 * value3.X)) - value4.X) * num)) + ((((-value1.X + (3 * value2.X)) - (3 * value3.X)) + value4.X) * num2));
            vector.Y = 0.5 * ((((2 * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2 * value1.Y) - (5 * value2.Y)) + (4 * value3.Y)) - value4.Y) * num)) + ((((-value1.Y + (3 * value2.Y)) - (3 * value3.Y)) + value4.Y) * num2));
            return vector;
        }
        SetCatmullRom(value1, value2, value3, value4, amount) {
            var num = amount * amount;
            var num2 = amount * num;
            var X = 0.5 * ((((2 * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2 * value1.X) - (5 * value2.X)) + (4 * value3.X)) - value4.X) * num)) + ((((-value1.X + (3 * value2.X)) - (3 * value3.X)) + value4.X) * num2));
            var Y = 0.5 * ((((2 * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2 * value1.Y) - (5 * value2.Y)) + (4 * value3.Y)) - value4.Y) * num)) + ((((-value1.Y + (3 * value2.Y)) - (3 * value3.Y)) + value4.Y) * num2));
            this.X = X;
            this.Y = Y;
            return this;
        }
        static Hermite(value1, tangent1, value2, tangent2, amount, result = null) {
            var vector = result != null ? result : new Vector2();
            var num = amount * amount;
            var num2 = amount * num;
            var num6 = ((2 * num2) - (3 * num)) + 1;
            var num5 = (-2 * num2) + (3 * num);
            var num4 = (num2 - (2 * num)) + amount;
            var num3 = num2 - num;
            vector.X = (((value1.X * num6) + (value2.X * num5)) + (tangent1.X * num4)) + (tangent2.X * num3);
            vector.Y = (((value1.Y * num6) + (value2.Y * num5)) + (tangent1.Y * num4)) + (tangent2.Y * num3);
            return vector;
        }
        SetHermite(value1, tangent1, value2, tangent2, amount) {
            var num = amount * amount;
            var num2 = amount * num;
            var num6 = ((2 * num2) - (3 * num)) + 1;
            var num5 = (-2 * num2) + (3 * num);
            var num4 = (num2 - (2 * num)) + amount;
            var num3 = num2 - num;
            var X = (((value1.X * num6) + (value2.X * num5)) + (tangent1.X * num4)) + (tangent2.X * num3);
            var Y = (((value1.Y * num6) + (value2.Y * num5)) + (tangent1.Y * num4)) + (tangent2.Y * num3);
            this.X = X;
            this.Y = Y;
            return this;
        }
        Transform(matrix) {
            var num2 = ((this.X * matrix.M11) + (this.Y * matrix.M21)) + matrix.M41;
            var num = ((this.X * matrix.M12) + (this.Y * matrix.M22)) + matrix.M42;
            this.X = num2;
            this.Y = num;
        }
        static Transform(position, matrix, result = null) {
            var vector = result != null ? result : new Vector2();
            var num2 = ((position.X * matrix.M11) + (position.Y * matrix.M21)) + matrix.M41;
            var num = ((position.X * matrix.M12) + (position.Y * matrix.M22)) + matrix.M42;
            vector.X = num2;
            vector.Y = num;
            return vector;
        }
        SetTransform(position, matrix) {
            var num2 = ((position.X * matrix.M11) + (position.Y * matrix.M21)) + matrix.M41;
            var num = ((position.X * matrix.M12) + (position.Y * matrix.M22)) + matrix.M42;
            this.X = num2;
            this.Y = num;
            return this;
        }
        static TransformNormal(normal, matrix, result = null) {
            var vector = result != null ? result : new Vector2();
            var num2 = (normal.X * matrix.M11) + (normal.Y * matrix.M21);
            var num = (normal.X * matrix.M12) + (normal.Y * matrix.M22);
            vector.X = num2;
            vector.Y = num;
            return vector;
        }
        SetTransformNormal(normal, matrix) {
            var num2 = (normal.X * matrix.M11) + (normal.Y * matrix.M21);
            var num = (normal.X * matrix.M12) + (normal.Y * matrix.M22);
            this.X = num2;
            this.Y = num;
            return this;
        }
        static TransformQuaternion(value, rotation, result = null) {
            var vector = result != null ? result : new Vector2();
            var num10 = rotation.X + rotation.X;
            var num5 = rotation.Y + rotation.Y;
            var num4 = rotation.Z + rotation.Z;
            var num3 = rotation.W * num4;
            var num9 = rotation.X * num10;
            var num2 = rotation.X * num5;
            var num8 = rotation.Y * num5;
            var num = rotation.Z * num4;
            var num7 = (value.X * ((1 - num8) - num)) + (value.Y * (num2 - num3));
            var num6 = (value.X * (num2 + num3)) + (value.Y * ((1 - num9) - num));
            vector.X = num7;
            vector.Y = num6;
            return vector;
        }
        SetTransformQuaternion(value, rotation) {
            var num10 = rotation.X + rotation.X;
            var num5 = rotation.Y + rotation.Y;
            var num4 = rotation.Z + rotation.Z;
            var num3 = rotation.W * num4;
            var num9 = rotation.X * num10;
            var num2 = rotation.X * num5;
            var num8 = rotation.Y * num5;
            var num = rotation.Z * num4;
            var num7 = (value.X * ((1 - num8) - num)) + (value.Y * (num2 - num3));
            var num6 = (value.X * (num2 + num3)) + (value.Y * ((1 - num9) - num));
            this.X = num7;
            this.Y = num6;
            return this;
        }
        Negate() {
            this.X *= -1;
            this.Y *= -1;
            return this;
        }
        static Negate(value, result = null) {
            var vector = result != null ? result : new Vector2();
            return vector.Set(-value.X, -value.Y);
        }
        SetNegate(value) {
            this.X = -value.X;
            this.Y = -value.Y;
            return this;
        }
        Add(value1) {
            this.X += value1.X;
            this.Y += value1.Y;
            return this;
        }
        static Add(value1, value2, result = null) {
            var vector = result != null ? result : new Vector2();
            return vector.Set(value1.X + value2.X, value1.Y + value2.Y);
        }
        SetAdd(value1, value2) {
            var ref = this;
            ref.X = value1.X + value2.X;
            ref.Y = value1.Y + value2.Y;
            return ref;
        }
        ScaleAdd(scale, dir) {
            this.X = this.X + scale * dir.X;
            this.Y = this.Y + scale * dir.Y;
            return this;
        }
        static ScaleAdd(pos, scale, dir, result = null) {
            if (result == null)
                result = new Vector2();
            result.X = pos.X + scale * dir.X;
            result.Y = pos.Y + scale * dir.Y;
            return result;
        }
        SetScaleAdd(pos, scale, dir) {
            this.X = pos.X + scale * dir.X;
            this.Y = pos.Y + scale * dir.Y;
            return this;
        }
        Subtract(value1) {
            this.X -= value1.X;
            this.Y -= value1.Y;
            return this;
        }
        static Subtract(value1, value2, result = null) {
            if (result == null)
                result = new Vector2();
            return result.Set(value1.X - value2.X, value1.Y - value2.Y);
        }
        SetSubtract(value1, value2) {
            var ref = this;
            ref.X = value1.X - value2.X;
            ref.Y = value1.Y - value2.Y;
            return ref;
        }
        Multiply(value1) {
            this.X *= value1.X;
            this.Y *= value1.Y;
            return this;
        }
        static Multiply(value1, value2, result = null) {
            return (result != null ? result : new Vector2()).Set(value1.X * value2.X, value1.Y * value2.Y);
        }
        SetMultiply(value1, value2) {
            var ref = this;
            ref.X = value1.X * value2.X;
            ref.Y = value1.Y * value2.Y;
            return ref;
        }
        Scale(scaleFactor) {
            this.X *= scaleFactor;
            this.Y *= scaleFactor;
            return this;
        }
        static Scale(value1, scaleFactor, result = null) {
            return (result != null ? result : new Vector2()).Set(value1.X * scaleFactor, value1.Y * scaleFactor);
        }
        SetScale(value1, scaleFactor) {
            var X = value1.X * scaleFactor;
            var Y = value1.Y * scaleFactor;
            this.X = X;
            this.Y = Y;
            return this;
        }
        Divide(value1) {
            this.X /= value1.X;
            this.Y /= value1.Y;
            return this;
        }
        static Divide(value1, value2, result = null) {
            return (result != null ? result : new Vector2()).Set(value1.X / value2.X, value1.Y / value2.Y);
        }
        SetDivide(value1, value2) {
            this.X = value1.X / value2.X;
            this.Y = value1.Y / value2.Y;
            return this;
        }
        Minimize(other) {
            if (other instanceof Vector2) {
                if (other.X < this.X)
                    this.X = other.X;
                if (other.Y < this.Y)
                    this.Y = other.Y;
            }
            else if (other instanceof Array) {
                for (var p of other) {
                    if (p.X < this.X)
                        this.X = p.X;
                    if (p.Y < this.Y)
                        this.Y = p.Y;
                }
            }
            return this;
        }
        static Minimize(left, right, result = null) {
            var x = (left.X < right.X) ? left.X : right.X;
            var y = (left.Y < right.Y) ? left.Y : right.Y;
            return (result != null ? result : new Vector2()).Set(x, y);
        }
        SetMinimize(left, right) {
            this.X = (left.X < right.X) ? left.X : right.X;
            this.Y = (left.Y < right.Y) ? left.Y : right.Y;
            return this;
        }
        Maximize(other) {
            if (other instanceof Vector2) {
                if (other.X > this.X)
                    this.X = other.X;
                if (other.Y > this.Y)
                    this.Y = other.Y;
            }
            else if (other instanceof Array) {
                for (var p of other) {
                    if (p.X > this.X)
                        this.X = p.X;
                    if (p.Y > this.Y)
                        this.Y = p.Y;
                }
            }
            return this;
        }
        static Maximize(left, right, result = null) {
            var x = (left.X > right.X) ? left.X : right.X;
            var y = (left.Y > right.Y) ? left.Y : right.Y;
            return (result != null ? result : new Vector2()).Set(x, y);
        }
        SetMaximize(left, right) {
            this.X = (left.X > right.X) ? left.X : right.X;
            this.Y = (left.Y > right.Y) ? left.Y : right.Y;
            return this;
        }
        FromArray(array, index = 0) {
            this.X = array[index];
            this.Y = array[index + 1];
            return this;
        }
        ToArray(array, index = 0) {
            array[index] = this.X;
            array[index + 1] = this.Y;
            return this;
        }
        AsArray() {
            var result = new Array();
            this.ToArray(result, 0);
            return result;
        }
        static Create(x, y) {
            var result = new Vector2();
            result.X = x;
            result.Y = y;
            return result;
        }
        static get Zero() {
            return new Vector2(0, 0);
        }
        static get One() {
            return new Vector2(1, 1);
        }
        static get UnitX() {
            return new Vector2(1, 0);
        }
        static get UnitY() {
            return new Vector2(0, 1);
        }
        SetZero() {
            this.X = 0;
            this.Y = 0;
            return this;
        }
        SetOne() {
            this.X = 1;
            this.Y = 1;
            return this;
        }
        SetUnitX() {
            this.X = 1;
            this.Y = 0;
            return this;
        }
        SetUnitY() {
            this.X = 0;
            this.Y = 1;
            return this;
        }
        get IsZero() {
            return this.X == 0 && this.Y == 0;
        }
        static TransformValues(values, matrix) {
            for (var i = 0; i < values.length; i += 2) {
                var x = values[i];
                var y = values[i + 1];
                var x1 = ((x * matrix.M11) + (y * matrix.M21)) + matrix.M41;
                var y1 = ((x * matrix.M12) + (y * matrix.M22)) + matrix.M42;
                values[i] = x1;
                values[i + 1] = y1;
            }
        }
        static NormalizeValues(values, matrix) {
            for (var i = 0; i < values.length; i += 2) {
                var x = values[i];
                var y = values[i + 1];
                var num2 = x * x + y * y;
                var num = 1 / (Math.sqrt(num2));
                x *= num;
                y *= num;
                values[i] = x;
                values[i + 1] = y;
            }
        }
    }
    U1.Vector2 = Vector2;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Vector3 {
        constructor(x = 0, y, z) {
            if (x instanceof Vector3) {
                this.X = x.X;
                this.Y = x.Y;
                this.Z = x.Z;
            }
            else if (x instanceof U1.Vector2) {
                this.X = x.X;
                this.Y = x.Y;
                this.Z = y;
            }
            else {
                this.X = x;
                this.Y = (y == undefined ? 0 : y);
                this.Z = (z == undefined ? 0 : z);
            }
        }
        static Dot(a, b) {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
        }
        Dot(b) {
            var a = this;
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
        }
        ConvertFromStr(value) {
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            this.X = items.length > 0 ? items[0] : 0;
            this.Y = items.length > 1 ? items[1] : 0;
            this.Z = items.length > 2 ? items[2] : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this.X, this.Y, this.Z);
        }
        toString() {
            return "(" + this.X + "," + this.Y + "," + this.Z + ")";
        }
        static Create(x, y, z) {
            var result = new Vector3(x, y, z);
            return result;
        }
        Set(x, y, z) {
            if (x instanceof Vector3) {
                this.X = x.X;
                this.Y = x.Y;
                this.Z = x.Z;
            }
            else {
                this.X = x;
                this.Y = y || 0;
                this.Z = z || 0;
            }
            return this;
        }
        Clone() {
            return new Vector3(this.X, this.Y, this.Z);
        }
        CopyFrom(source) {
            if (source != null) {
                this.X = source.X;
                this.Y = source.Y;
                this.Z = source.Z;
            }
            return this;
        }
        static get Zero() {
            return new Vector3(0, 0, 0);
        }
        SetZero() {
            this.X = 0;
            this.Y = 0;
            this.Z = 0;
            return this;
        }
        get IsZero() {
            return (this.X == 0 && this.Y == 0 && this.Z == 0);
        }
        static get One() {
            return new Vector3(1, 1, 1);
        }
        SetOne() {
            this.X = 1;
            this.Y = 1;
            this.Z = 1;
            return this;
        }
        get IsOne() {
            return (this.X === 1 && this.Y === 1 && this.Z === 1);
        }
        static get UnitX() {
            return new Vector3(1, 0, 0);
        }
        SetUnitX() {
            this.X = 1;
            this.Y = 0;
            this.Z = 0;
            return this;
        }
        get IsUnitX() {
            return (this.X === 1 && this.Y === 0 && this.Z === 0);
        }
        static get UnitY() {
            return new Vector3(0, 1, 0);
        }
        SetUnitY() {
            this.X = 0;
            this.Y = 1;
            this.Z = 0;
            return this;
        }
        get IsUnitY() {
            return (this.X === 0 && this.Y === 1 && this.Z === 0);
        }
        static get UnitZ() {
            return new Vector3(0, 0, 1);
        }
        SetUnitZ() {
            this.X = 0;
            this.Y = 0;
            this.Z = 1;
            return this;
        }
        get IsUnitZ() {
            return (this.X === 0 && this.Y === 0 && this.Z === 1);
        }
        static get Up() {
            return new Vector3(0, 1, 0);
        }
        SetUp() {
            this.X = 0;
            this.Y = 1;
            this.Z = 0;
            return this;
        }
        static get Down() {
            return new Vector3(0, -1, 0);
        }
        SetDown() {
            this.X = 0;
            this.Y = -1;
            this.Z = 0;
            return this;
        }
        static get Right() {
            return new Vector3(1, 0, 0);
        }
        SetRight() {
            this.X = 1;
            this.Y = 0;
            this.Z = 0;
            return this;
        }
        static get Left() {
            return new Vector3(-1, 0, 0);
        }
        SetLeft() {
            this.X = -1;
            this.Y = 0;
            this.Z = 0;
            return this;
        }
        static get Forward() {
            return new Vector3(0, 0, -1);
        }
        SetForward() {
            this.X = 0;
            this.Y = 0;
            this.Z = -1;
            return this;
        }
        static get Backward() {
            return new Vector3(0, 0, 1);
        }
        SetBackward() {
            this.X = 0;
            this.Y = 0;
            this.Z = 1;
            return this;
        }
        get IsMaxValue() {
            return this.X === Number.MAX_VALUE &&
                this.Y === Number.MAX_VALUE &&
                this.Z === Number.MAX_VALUE;
        }
        static get MaxValue() {
            return new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        }
        SetMaxValue() {
            this.X = Number.MAX_VALUE;
            this.Y = Number.MAX_VALUE;
            this.Z = Number.MAX_VALUE;
            return this;
        }
        static get MinValue() {
            return new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        }
        SetMinValue() {
            this.X = -Number.MAX_VALUE;
            this.Y = -Number.MAX_VALUE;
            this.Z = -Number.MAX_VALUE;
            return this;
        }
        get IsMinValue() {
            return this.X === -Number.MAX_VALUE &&
                this.Y === -Number.MAX_VALUE &&
                this.Z === -Number.MAX_VALUE;
        }
        Equals(other) {
            return this.X === other.X
                && this.Y === other.Y
                && this.Z === other.Z;
        }
        static Equals(value1, value2) {
            return value1.X === value2.X
                && value1.Y === value2.Y
                && value1.Z === value2.Z;
        }
        EpsilonEquals(other, epsilon) {
            var num3 = this.X - other.X;
            var num2 = this.Y - other.Y;
            var num = this.Z - other.Z;
            return (((num3 * num3) + (num2 * num2)) + (num * num)) <= epsilon * epsilon;
        }
        static EpsilonEquals(point0, point1, epsilon = U1.Epsilon) {
            if (Math.abs(point1.X - point0.X) > epsilon)
                return false;
            if (Math.abs(point1.Y - point0.Y) > epsilon)
                return false;
            if (Math.abs(point1.Z - point0.Z) > epsilon)
                return false;
            return true;
        }
        static Length(offset) {
            return offset.Length();
        }
        Length() {
            var num = ((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z);
            return Math.sqrt(num);
        }
        LengthSquareduared() {
            return (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z));
        }
        static Distance(value1, value2) {
            var num3 = value1.X - value2.X;
            var num2 = value1.Y - value2.Y;
            var num = value1.Z - value2.Z;
            var num4 = ((num3 * num3) + (num2 * num2)) + (num * num);
            return Math.sqrt(num4);
        }
        Distance(value2) {
            var num3 = this.X - value2.X;
            var num2 = this.Y - value2.Y;
            var num = this.Z - value2.Z;
            var num4 = ((num3 * num3) + (num2 * num2)) + (num * num);
            return Math.sqrt(num4);
        }
        static DistanceSquared(value1, value2) {
            var num3 = value1.X - value2.X;
            var num2 = value1.Y - value2.Y;
            var num = value1.Z - value2.Z;
            return (((num3 * num3) + (num2 * num2)) + (num * num));
        }
        DistanceSquared(value2) {
            var num3 = this.X - value2.X;
            var num2 = this.Y - value2.Y;
            var num = this.Z - value2.Z;
            return (((num3 * num3) + (num2 * num2)) + (num * num));
        }
        Normalize() {
            if (this.X == 0 && this.Y == 0 && this.Z == 0) {
                return this;
            }
            var num2 = ((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z);
            var num = 1 / (Math.sqrt(num2));
            this.X *= num;
            this.Y *= num;
            this.Z *= num;
            return this;
        }
        static Normalize(value, result) {
            result = value || new Vector3();
            if (value.IsZero)
                return result.CopyFrom(value);
            var num2 = ((value.X * value.X) + (value.Y * value.Y)) + (value.Z * value.Z);
            var num = 1 / (Math.sqrt(num2));
            result.X = value.X * num;
            result.Y = value.Y * num;
            result.Z = value.Z * num;
            return result;
        }
        SetNormalize(value) {
            if (value.IsZero) {
                return this.SetZero();
            }
            var num2 = ((value.X * value.X) + (value.Y * value.Y)) + (value.Z * value.Z);
            var num = 1 / (Math.sqrt(num2));
            this.X = value.X * num;
            this.Y = value.Y * num;
            this.Z = value.Z * num;
            return this;
        }
        static Cross(vector1, vector2, result = null) {
            if (result == null)
                result = new Vector3();
            var X = (vector1.Y * vector2.Z) - (vector1.Z * vector2.Y);
            var Y = (vector1.Z * vector2.X) - (vector1.X * vector2.Z);
            var Z = (vector1.X * vector2.Y) - (vector1.Y * vector2.X);
            result.X = X;
            result.Y = Y;
            result.Z = Z;
            return result;
        }
        SetCross(vector1, vector2) {
            var X = (vector1.Y * vector2.Z) - (vector1.Z * vector2.Y);
            var Y = (vector1.Z * vector2.X) - (vector1.X * vector2.Z);
            var Z = (vector1.X * vector2.Y) - (vector1.Y * vector2.X);
            this.X = X;
            this.Y = Y;
            this.Z = Z;
            return this;
        }
        Cross(vector2) {
            var X = (this.Y * vector2.Z) - (this.Z * vector2.Y);
            var Y = (this.Z * vector2.X) - (this.X * vector2.Z);
            var Z = (this.X * vector2.Y) - (this.Y * vector2.X);
            this.X = X;
            this.Y = Y;
            this.Z = Z;
            return this;
        }
        static Reflect(vector, normal, result = null) {
            if (result == null)
                result = new Vector3();
            var num = ((vector.X * normal.X) + (vector.Y * normal.Y)) + (vector.Z * normal.Z);
            result.X = vector.X - ((2 * num) * normal.X);
            result.Y = vector.Y - ((2 * num) * normal.Y);
            result.Z = vector.Z - ((2 * num) * normal.Z);
            return result;
        }
        SetReflect(vector, normal) {
            var num = ((vector.X * normal.X) + (vector.Y * normal.Y)) + (vector.Z * normal.Z);
            this.X = vector.X - ((2 * num) * normal.X);
            this.Y = vector.Y - ((2 * num) * normal.Y);
            this.Z = vector.Z - ((2 * num) * normal.Z);
            return this;
        }
        Reflect(normal) {
            var num = ((this.X * normal.X) + (this.Y * normal.Y)) + (this.Z * normal.Z);
            this.X = this.X - ((2 * num) * normal.X);
            this.Y = this.Y - ((2 * num) * normal.Y);
            this.Z = this.Z - ((2 * num) * normal.Z);
            return this;
        }
        static Min(v1, v2, result) {
            if (result == null)
                result = new Vector3();
            result.X = (v1.X < v2.X) ? v1.X : v2.X;
            result.Y = (v1.Y < v2.Y) ? v1.Y : v2.Y;
            result.Z = (v1.Z < v2.Z) ? v1.Z : v2.Z;
            return result;
        }
        static Min1(vs, res) {
            if (res == null)
                res = new Vector3();
            res.Set(vs[0]);
            for (var p of vs) {
                res.X = (res.X < p.X) ? res.X : p.X;
                res.Y = (res.Y < p.Y) ? res.Y : p.Y;
                res.Z = (res.Z < p.Z) ? res.Z : p.Z;
            }
            return res;
        }
        SetMin(v1, v2) {
            this.X = (v1.X < v2.X) ? v1.X : v2.X;
            this.Y = (v1.Y < v2.Y) ? v1.Y : v2.Y;
            this.Z = (v1.Z < v2.Z) ? v1.Z : v2.Z;
            return this;
        }
        static Max(v1, v2, res) {
            if (res == null)
                res = new Vector3();
            res.X = (v1.X > v2.X) ? v1.X : v2.X;
            res.Y = (v1.Y > v2.Y) ? v1.Y : v2.Y;
            res.Z = (v1.Z > v2.Z) ? v1.Z : v2.Z;
            return res;
        }
        static Max1(vs, result) {
            result = result || new Vector3();
            var r = result;
            r.Set(vs[0]);
            for (var p of vs) {
                r.X = (r.X > p.X) ? r.X : p.X;
                r.Y = (r.Y > p.Y) ? r.Y : p.Y;
                r.Z = (r.Z > p.Z) ? r.Z : p.Z;
            }
            return r;
        }
        SetMax(value1, value2) {
            this.X = (value1.X > value2.X) ? value1.X : value2.X;
            this.Y = (value1.Y > value2.Y) ? value1.Y : value2.Y;
            this.Z = (value1.Z > value2.Z) ? value1.Z : value2.Z;
            return this;
        }
        static Clamp(value1, min, max, result) {
            if (result == null)
                result = new Vector3();
            var x = value1.X;
            x = (x > max.X) ? max.X : x;
            x = (x < min.X) ? min.X : x;
            var y = value1.Y;
            y = (y > max.Y) ? max.Y : y;
            y = (y < min.Y) ? min.Y : y;
            var z = value1.Z;
            z = (z > max.Z) ? max.Z : z;
            z = (z < min.Z) ? min.Z : z;
            return result.Set(x, y, z);
        }
        SetClamp(value1, min, max) {
            var x = value1.X;
            x = (x > max.X) ? max.X : x;
            x = (x < min.X) ? min.X : x;
            var y = value1.Y;
            y = (y > max.Y) ? max.Y : y;
            y = (y < min.Y) ? min.Y : y;
            var z = value1.Z;
            z = (z > max.Z) ? max.Z : z;
            z = (z < min.Z) ? min.Z : z;
            this.X = x;
            this.Y = y;
            this.Z = z;
            return this;
        }
        static Lerp(value1, value2, amount, result = null) {
            if (result == null)
                result = new Vector3();
            var x = value1.X + ((value2.X - value1.X) * amount);
            var y = value1.Y + ((value2.Y - value1.Y) * amount);
            var z = value1.Z + ((value2.Z - value1.Z) * amount);
            return result.Set(x, y, z);
        }
        SetLerp(value1, value2, amount) {
            this.X = value1.X + ((value2.X - value1.X) * amount);
            this.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            this.Z = value1.Z + ((value2.Z - value1.Z) * amount);
            return this;
        }
        Lerp(value2, amount) {
            this.X = this.X + ((value2.X - this.X) * amount);
            this.Y = this.Y + ((value2.Y - this.Y) * amount);
            this.Z = this.Z + ((value2.Z - this.Z) * amount);
            return this;
        }
        static Barycentric(value1, value2, value3, amount1, amount2, result = null) {
            if (result == null)
                result = new Vector3();
            var x = (value1.X + (amount1 * (value2.X - value1.X))) + (amount2 * (value3.X - value1.X));
            var y = (value1.Y + (amount1 * (value2.Y - value1.Y))) + (amount2 * (value3.Y - value1.Y));
            var z = (value1.Z + (amount1 * (value2.Z - value1.Z))) + (amount2 * (value3.Z - value1.Z));
            return result.Set(x, y, z);
        }
        SetBarycentric(value1, value2, value3, amount1, amount2) {
            this.X = (value1.X + (amount1 * (value2.X - value1.X))) + (amount2 * (value3.X - value1.X));
            this.Y = (value1.Y + (amount1 * (value2.Y - value1.Y))) + (amount2 * (value3.Y - value1.Y));
            this.Z = (value1.Z + (amount1 * (value2.Z - value1.Z))) + (amount2 * (value3.Z - value1.Z));
            return this;
        }
        Barycentric(value2, value3, amount1, amount2) {
            this.X = (this.X + (amount1 * (value2.X - this.X))) + (amount2 * (value3.X - this.X));
            this.Y = (this.Y + (amount1 * (value2.Y - this.Y))) + (amount2 * (value3.Y - this.Y));
            this.Z = (this.Z + (amount1 * (value2.Z - this.Z))) + (amount2 * (value3.Z - this.Z));
            return this;
        }
        static SmoothStep(value1, value2, amount, result = null) {
            if (result == null)
                result = new Vector3();
            amount = (amount > 1) ? 1 : ((amount < 0) ? 0 : amount);
            amount = (amount * amount) * (3 - (2 * amount));
            result.X = value1.X + ((value2.X - value1.X) * amount);
            result.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            result.Z = value1.Z + ((value2.Z - value1.Z) * amount);
            return result;
        }
        SetSmoothStep(value1, value2, amount) {
            amount = (amount > 1) ? 1 : ((amount < 0) ? 0 : amount);
            amount = (amount * amount) * (3 - (2 * amount));
            this.X = value1.X + ((value2.X - value1.X) * amount);
            this.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            this.Z = value1.Z + ((value2.Z - value1.Z) * amount);
            return this;
        }
        SmoothStep(value2, amount) {
            amount = (amount > 1) ? 1 : ((amount < 0) ? 0 : amount);
            amount = (amount * amount) * (3 - (2 * amount));
            this.X = this.X + ((value2.X - this.X) * amount);
            this.Y = this.Y + ((value2.Y - this.Y) * amount);
            this.Z = this.Z + ((value2.Z - this.Z) * amount);
            return this;
        }
        static CatmullRom(value1, value2, value3, value4, amount, result = null) {
            if (result == null)
                result = new Vector3();
            var num = amount * amount;
            var num2 = amount * num;
            var x = 0.5 * ((((2 * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2 * value1.X) - (5 * value2.X)) + (4 * value3.X)) - value4.X) * num)) + ((((-value1.X + (3 * value2.X)) - (3 * value3.X)) + value4.X) * num2));
            var y = 0.5 * ((((2 * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2 * value1.Y) - (5 * value2.Y)) + (4 * value3.Y)) - value4.Y) * num)) + ((((-value1.Y + (3 * value2.Y)) - (3 * value3.Y)) + value4.Y) * num2));
            var z = 0.5 * ((((2 * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2 * value1.Z) - (5 * value2.Z)) + (4 * value3.Z)) - value4.Z) * num)) + ((((-value1.Z + (3 * value2.Z)) - (3 * value3.Z)) + value4.Z) * num2));
            return result.Set(x, y, z);
        }
        SetCatmullRom(value1, value2, value3, value4, amount) {
            var num = amount * amount;
            var num2 = amount * num;
            this.X = 0.5 * ((((2 * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2 * value1.X) - (5 * value2.X)) + (4 * value3.X)) - value4.X) * num)) + ((((-value1.X + (3 * value2.X)) - (3 * value3.X)) + value4.X) * num2));
            this.Y = 0.5 * ((((2 * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2 * value1.Y) - (5 * value2.Y)) + (4 * value3.Y)) - value4.Y) * num)) + ((((-value1.Y + (3 * value2.Y)) - (3 * value3.Y)) + value4.Y) * num2));
            this.Z = 0.5 * ((((2 * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2 * value1.Z) - (5 * value2.Z)) + (4 * value3.Z)) - value4.Z) * num)) + ((((-value1.Z + (3 * value2.Z)) - (3 * value3.Z)) + value4.Z) * num2));
            return this;
        }
        CatmullRom(value2, value3, value4, amount) {
            var num = amount * amount;
            var num2 = amount * num;
            this.X = 0.5 * ((((2 * value2.X) + ((-this.X + value3.X) * amount)) + (((((2 * this.X) - (5 * value2.X)) + (4 * value3.X)) - value4.X) * num)) + ((((-this.X + (3 * value2.X)) - (3 * value3.X)) + value4.X) * num2));
            this.Y = 0.5 * ((((2 * value2.Y) + ((-this.Y + value3.Y) * amount)) + (((((2 * this.Y) - (5 * value2.Y)) + (4 * value3.Y)) - value4.Y) * num)) + ((((-this.Y + (3 * value2.Y)) - (3 * value3.Y)) + value4.Y) * num2));
            this.Z = 0.5 * ((((2 * value2.Z) + ((-this.Z + value3.Z) * amount)) + (((((2 * this.Z) - (5 * value2.Z)) + (4 * value3.Z)) - value4.Z) * num)) + ((((-this.Z + (3 * value2.Z)) - (3 * value3.Z)) + value4.Z) * num2));
            return this;
        }
        static Hermite(value1, tangent1, value2, tangent2, amount, result = null) {
            if (result == null)
                result = new Vector3();
            var num = amount * amount;
            var num2 = amount * num;
            var num6 = ((2 * num2) - (3 * num)) + 1;
            var num5 = (-2 * num2) + (3 * num);
            var num4 = (num2 - (2 * num)) + amount;
            var num3 = num2 - num;
            var X = (((value1.X * num6) + (value2.X * num5)) + (tangent1.X * num4)) + (tangent2.X * num3);
            var Y = (((value1.Y * num6) + (value2.Y * num5)) + (tangent1.Y * num4)) + (tangent2.Y * num3);
            var Z = (((value1.Z * num6) + (value2.Z * num5)) + (tangent1.Z * num4)) + (tangent2.Z * num3);
            return result.Set(X, Y, Z);
        }
        SetHermite(value1, tangent1, value2, tangent2, amount) {
            var num = amount * amount;
            var num2 = amount * num;
            var num6 = ((2 * num2) - (3 * num)) + 1;
            var num5 = (-2 * num2) + (3 * num);
            var num4 = (num2 - (2 * num)) + amount;
            var num3 = num2 - num;
            this.X = (((value1.X * num6) + (value2.X * num5)) + (tangent1.X * num4)) + (tangent2.X * num3);
            this.Y = (((value1.Y * num6) + (value2.Y * num5)) + (tangent1.Y * num4)) + (tangent2.Y * num3);
            this.Z = (((value1.Z * num6) + (value2.Z * num5)) + (tangent1.Z * num4)) + (tangent2.Z * num3);
            return this;
        }
        static Transform(position, matrix, result = null) {
            if (result == null)
                result = new Vector3();
            var x = (((position.X * matrix.M11) + (position.Y * matrix.M21)) + (position.Z * matrix.M31)) + matrix.M41;
            var y = (((position.X * matrix.M12) + (position.Y * matrix.M22)) + (position.Z * matrix.M32)) + matrix.M42;
            var z = (((position.X * matrix.M13) + (position.Y * matrix.M23)) + (position.Z * matrix.M33)) + matrix.M43;
            return result.Set(x, y, z);
        }
        SetTransform(position, matrix) {
            var X = (((position.X * matrix.M11) + (position.Y * matrix.M21)) + (position.Z * matrix.M31)) + matrix.M41;
            var Y = (((position.X * matrix.M12) + (position.Y * matrix.M22)) + (position.Z * matrix.M32)) + matrix.M42;
            var Z = (((position.X * matrix.M13) + (position.Y * matrix.M23)) + (position.Z * matrix.M33)) + matrix.M43;
            this.X = X;
            this.Y = Y;
            this.Z = Z;
            return this;
        }
        Transform(matrix) {
            var x = (((this.X * matrix.M11) + (this.Y * matrix.M21)) + (this.Z * matrix.M31)) + matrix.M41;
            var y = (((this.X * matrix.M12) + (this.Y * matrix.M22)) + (this.Z * matrix.M32)) + matrix.M42;
            var z = (((this.X * matrix.M13) + (this.Y * matrix.M23)) + (this.Z * matrix.M33)) + matrix.M43;
            this.X = x;
            this.Y = y;
            this.Z = z;
            return this;
        }
        static TransformNormal(normal, matrix, result = null) {
            if (result == null)
                result = new Vector3();
            var x = ((normal.X * matrix.M11) + (normal.Y * matrix.M21)) + (normal.Z * matrix.M31);
            var y = ((normal.X * matrix.M12) + (normal.Y * matrix.M22)) + (normal.Z * matrix.M32);
            var z = ((normal.X * matrix.M13) + (normal.Y * matrix.M23)) + (normal.Z * matrix.M33);
            return result.Set(x, y, z);
        }
        SetTransformNormal(normal, matrix) {
            var X = ((normal.X * matrix.M11) + (normal.Y * matrix.M21)) + (normal.Z * matrix.M31);
            var Y = ((normal.X * matrix.M12) + (normal.Y * matrix.M22)) + (normal.Z * matrix.M32);
            var Z = ((normal.X * matrix.M13) + (normal.Y * matrix.M23)) + (normal.Z * matrix.M33);
            this.X = X;
            this.Y = Y;
            this.Z = Z;
            return this;
        }
        TransformNormal(matrix) {
            var x = ((this.X * matrix.M11) + (this.Y * matrix.M21)) + (this.Z * matrix.M31);
            var y = ((this.X * matrix.M12) + (this.Y * matrix.M22)) + (this.Z * matrix.M32);
            var z = ((this.X * matrix.M13) + (this.Y * matrix.M23)) + (this.Z * matrix.M33);
            this.X = x;
            this.Y = y;
            this.Z = z;
            return this;
        }
        static Negate(value, result = null) {
            if (result == null)
                result = new Vector3();
            return result.Set(-value.X, -value.Y, -value.Z);
        }
        SetNegate(value) {
            this.X = -value.X;
            this.Y = -value.Y;
            this.Z = -value.Z;
            return this;
        }
        Negate() {
            this.X *= -1;
            this.Y *= -1;
            this.Z *= -1;
            return this;
        }
        static Add(value1, value2, result = null) {
            if (result == null)
                result = new Vector3();
            return result.Set(value1.X + value2.X, value1.Y + value2.Y, value1.Z + value2.Z);
        }
        SetAdd(value1, value2) {
            this.X = value1.X + value2.X;
            this.Y = value1.Y + value2.Y;
            this.Z = value1.Z + value2.Z;
            return this;
        }
        Add(value2) {
            this.X += value2.X;
            this.Y += value2.Y;
            this.Z += value2.Z;
            return this;
        }
        static Subtract(value1, value2, result = null) {
            if (result == null)
                result = new Vector3();
            return result.Set(value1.X - value2.X, value1.Y - value2.Y, value1.Z - value2.Z);
        }
        SetSubtract(value1, value2) {
            this.Set(value1.X - value2.X, value1.Y - value2.Y, value1.Z - value2.Z);
            return this;
        }
        Subtract(value2) {
            this.X -= value2.X;
            this.Y -= value2.Y;
            this.Z -= value2.Z;
            return this;
        }
        static Multiply(value1, value2, result = null) {
            if (result == null)
                result = new Vector3();
            return result.Set(value1.X * value2.X, value1.Y * value2.Y, value1.Z * value2.Z);
        }
        SetMultiply(value1, value2) {
            this.X = value1.X * value2.X;
            this.Y = value1.Y * value2.Y;
            this.Z = value1.Z * value2.Z;
            return this;
        }
        Multiply(value2) {
            this.X *= value2.X;
            this.Y *= value2.Y;
            this.Z *= value2.Z;
            return this;
        }
        static Scale(value1, scaleFactor, result = null) {
            if (result == null)
                result = new Vector3();
            result.X = value1.X * scaleFactor;
            result.Y = value1.Y * scaleFactor;
            result.Z = value1.Z * scaleFactor;
            return result;
        }
        SetScale(value1, scaleFactor) {
            this.X = value1.X * scaleFactor;
            this.Y = value1.Y * scaleFactor;
            this.Z = value1.Z * scaleFactor;
            return this;
        }
        Scale(scaleFactor) {
            this.X = this.X * scaleFactor;
            this.Y = this.Y * scaleFactor;
            this.Z = this.Z * scaleFactor;
            return this;
        }
        static ScaleAdd(pos, scale, dir, result = null) {
            if (result == null)
                result = new Vector3();
            return result.Set(pos.X + scale * dir.X, pos.Y + scale * dir.Y, pos.Z + scale * dir.Z);
        }
        SetScaleAdd(pos, scale, dir) {
            this.X = pos.X + scale * dir.X;
            this.Y = pos.Y + scale * dir.Y;
            this.Z = pos.Z + scale * dir.Z;
            return this;
        }
        ScaleAdd(scale, dir) {
            this.X = this.X + scale * dir.X;
            this.Y = this.Y + scale * dir.Y;
            this.Z = this.Z + scale * dir.Z;
            return this;
        }
        static Divide(value1, value2, result = null) {
            if (result == null)
                result = new Vector3();
            return result.Set(value1.X / value2.X, value1.Y / value2.Y, value1.Z / value2.Z);
        }
        SetDivide(value1, value2) {
            this.X = value1.X / value2.X;
            this.Y = value1.Y / value2.Y;
            this.Z = value1.Z / value2.Z;
            return this;
        }
        Divide(value2) {
            this.X /= value2.X;
            this.Y /= value2.Y;
            this.Z /= value2.Z;
            return this;
        }
        static Project(source, projection, view, world, screenSize, mindepth, maxdepth, result = null) {
            if (result == null)
                result = new Vector3();
            var matrix = Vector3[".pj.m"] || (Vector3[".pj.m"] = new U1.Matrix4());
            matrix.SetMultiply(world, view).Multiply(projection);
            result.SetTransform(source, matrix);
            var a = (((source.X * matrix.M14) + (source.Y * matrix.M24)) + (source.Z * matrix.M34)) + matrix.M44;
            if (!U1.WithinEpsilon(a, 1)) {
                result.Scale(1 / a);
            }
            result.X = (((result.X + 1) * 0.5) * screenSize.X);
            result.Y = (((-result.Y + 1) * 0.5) * screenSize.Y);
            result.Z = (result.Z * (maxdepth - mindepth)) + mindepth;
            return result;
        }
        SetProject(source, projection, view, world, screenSize, mindepth, maxdepth) {
            var matrix = Vector3[".sp.m"] || (Vector3[".sp.m"] = new U1.Matrix4());
            matrix.SetMultiply(world, view).Multiply(projection);
            this.SetTransform(source, matrix);
            var a = (((source.X * matrix.M14) + (source.Y * matrix.M24)) + (source.Z * matrix.M34)) + matrix.M44;
            if (!U1.WithinEpsilon(a, 1)) {
                this.Scale(1 / a);
            }
            this.X = (((this.X + 1) * 0.5) * screenSize.X);
            this.Y = (((-this.Y + 1) * 0.5) * screenSize.Y);
            this.Z = (this.Z * (maxdepth - mindepth)) + mindepth;
            return this;
        }
        Minimize(other) {
            if (other instanceof Vector3) {
                if (other.X < this.X)
                    this.X = other.X;
                if (other.Y < this.Y)
                    this.Y = other.Y;
                if (other.Z < this.Z)
                    this.Z = other.Z;
            }
            else if (other instanceof Array) {
                for (var p of other) {
                    if (p.X < this.X)
                        this.X = p.X;
                    if (p.Y < this.Y)
                        this.Y = p.Y;
                    if (p.Z < this.Z)
                        this.Z = p.Z;
                }
            }
            return this;
        }
        static Minimize(left, right, result = null) {
            if (result == null)
                result = new Vector3();
            result.CopyFrom(left);
            result.Minimize(right);
            return result;
        }
        SetMinimize(left, right) {
            this.X = (left.X < right.X) ? left.X : right.X;
            this.Y = (left.Y < right.Y) ? left.Y : right.Y;
            this.Z = (left.Z < right.Z) ? left.Z : right.Z;
            return this;
        }
        Maximize(other) {
            if (other instanceof Vector3) {
                if (other.X > this.X)
                    this.X = other.X;
                if (other.Y > this.Y)
                    this.Y = other.Y;
                if (other.Z > this.Z)
                    this.Z = other.Z;
            }
            else if (other instanceof Array) {
                for (var p of other) {
                    if (p.X > this.X)
                        this.X = p.X;
                    if (p.Y > this.Y)
                        this.Y = p.Y;
                    if (p.Z > this.Z)
                        this.Z = p.Z;
                }
            }
            return this;
        }
        static Maximize(left, right, result) {
            if (result == null)
                result = new Vector3();
            result.CopyFrom(left);
            result.Maximize(right);
            return result;
        }
        SetMaximize(left, right) {
            this.X = (left.X > right.X) ? left.X : right.X;
            this.Y = (left.Y > right.Y) ? left.Y : right.Y;
            this.Z = (left.Z > right.Z) ? left.Z : right.Z;
            return this;
        }
        XY(result = null) {
            if (result == null)
                result = new U1.Vector2();
            return result.Set(this.X, this.Y);
        }
        YZ(result = null) {
            if (result == null)
                result = new U1.Vector2();
            return result.Set(this.Y, this.Z);
        }
        FromArray(array, index = 0) {
            this.X = array[index];
            this.Y = array[index + 1];
            this.Z = array[index + 2];
            return this;
        }
        ToArray(array, index = 0) {
            array[index] = this.X;
            array[index + 1] = this.Y;
            array[index + 2] = this.Z;
            return this;
        }
        static TransformValues(values, matrix) {
            for (var i = 0; i < values.length; i += 3) {
                var x = values[i];
                var y = values[i + 1];
                var z = values[i + 2];
                var x1 = x * matrix.M11 + y * matrix.M21 + z * matrix.M31 + matrix.M41;
                var y1 = x * matrix.M12 + y * matrix.M22 + z * matrix.M32 + matrix.M42;
                var z1 = x * matrix.M13 + y * matrix.M23 + z * matrix.M33 + matrix.M43;
                values[i] = x1;
                values[i + 1] = y1;
                values[i + 2] = z1;
            }
        }
        static TransformNormalValues(values, matrix) {
            for (var i = 0; i < values.length; i += 3) {
                var x = values[i];
                var y = values[i + 1];
                var z = values[i + 2];
                var x1 = ((x * matrix.M11) + (y * matrix.M21)) + (z * matrix.M31);
                var y1 = ((x * matrix.M12) + (y * matrix.M22)) + (z * matrix.M32);
                var z1 = ((x * matrix.M13) + (y * matrix.M23)) + (z * matrix.M33);
                values[i] = x1;
                values[i + 1] = y1;
                values[i + 2] = z1;
            }
        }
        static NormalizeValues(values, matrix) {
            for (var i = 0; i < values.length; i += 3) {
                var x = values[i];
                var y = values[i + 1];
                var z = values[i + 2];
                if (x == 0 && y == 0 && z == 0) {
                    continue;
                }
                var num2 = ((x * x) + (y * y)) + (z * z);
                var num = 1 / (Math.sqrt(num2));
                x *= num;
                y *= num;
                z *= num;
                values[i] = x;
                values[i + 1] = y;
                values[i + 2] = z;
            }
        }
    }
    U1.Vector3 = Vector3;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Vector4 {
        constructor(x = 0, y = 0, z = 0, w = 0) {
            this.X = x;
            this.Y = y;
            this.Z = z;
            this.W = w;
        }
        ConvertFromStr(value) {
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            this.X = items.length > 0 ? items[0] : 0;
            this.Y = items.length > 1 ? items[1] : 0;
            this.Z = items.length > 2 ? items[2] : 0;
            this.W = items.length > 3 ? items[3] : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this.X, this.Y, this.Z, this.W);
        }
        toString() {
            return "(" + this.X + "," + this.Y + "," + this.Z + "," + this.W + ")";
        }
        Set(x = 0, y = 0, z = 0, w = 0) {
            this.X = x;
            this.Y = y;
            this.Z = z;
            this.W = w;
            return this;
        }
        static get Zero() {
            return new Vector4();
        }
        static ZeroRef(ref) {
            ref.X = 0;
            ref.Y = 0;
            ref.Z = 0;
            ref.W = 0;
            return ref;
        }
        SetZero() {
            this.X = 0;
            this.Y = 0;
            this.Z = 0;
            this.W = 0;
            return this;
        }
        static get One() {
            return new Vector4(1, 1, 1, 1);
        }
        SetOne() {
            this.X = 1;
            this.Y = 1;
            this.Z = 1;
            this.W = 1;
            return this;
        }
        static get UnitX() {
            return new Vector4(1, 0, 0, 0);
        }
        SetUnitX() {
            this.X = 1;
            this.Y = 0;
            this.Z = 0;
            this.W = 0;
            return this;
        }
        static get UnitY() {
            return new Vector4(0, 1, 0, 0);
        }
        SetUnitY(ref) {
            this.X = 0;
            this.Y = 1;
            this.Z = 0;
            this.W = 0;
            return this;
        }
        static get UnitZ() {
            return new Vector4(0, 0, 1, 0);
        }
        SetUnitZ(ref) {
            this.X = 0;
            this.Y = 0;
            this.Z = 1;
            this.W = 0;
            return this;
        }
        static get UnitW() {
            return new Vector4(0, 0, 0, 1);
        }
        SetUnitW(ref) {
            this.X = 0;
            this.Y = 0;
            this.Z = 0;
            this.W = 1;
            return this;
        }
        GetXYZ(result) {
            result = result || new U1.Vector3();
            result.Set(this.X, this.Y, this.Z);
            return result;
        }
        Clone() {
            return new Vector4(this.X, this.Y, this.Z, this.W);
        }
        CopyFrom(source) {
            this.X = source.X;
            this.Y = source.Y;
            this.Z = source.Z;
            this.W = source.W;
            return this;
        }
        static FromArray(array, offset) {
            if (!offset) {
                offset = 0;
            }
            return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
        }
        Equals(other) {
            return ((((this.X == other.X) && (this.Y == other.Y)) && (this.Z == other.Z)) && (this.W == other.W));
        }
        EpsilonEquals(other, epsilon) {
            var num3 = this.X - other.X;
            var num2 = this.Y - other.Y;
            var num1 = this.Z - other.Z;
            var num0 = this.W - other.W;
            return (((num3 * num3) + (num2 * num2)) + (num1 * num1) + (num0 * num0)) <= epsilon * epsilon;
        }
        static EpsilonEquals(point0, point1, epsilon = U1.Epsilon) {
            if (Math.abs(point1.X - point0.X) > epsilon)
                return false;
            if (Math.abs(point1.Y - point0.Y) > epsilon)
                return false;
            if (Math.abs(point1.Z - point0.Z) > epsilon)
                return false;
            if (Math.abs(point1.W - point0.W) > epsilon)
                return false;
            return true;
        }
        Length() {
            var num = (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z)) + (this.W * this.W);
            return Math.sqrt(num);
        }
        LengthXYZ() {
            var num = (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z));
            return Math.sqrt(num);
        }
        LengthSquareduared() {
            return ((((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z)) + (this.W * this.W));
        }
        LengthSquareduaredXYZ() {
            return (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z));
        }
        static Distance(value1, value2) {
            var num4 = value1.X - value2.X;
            var num3 = value1.Y - value2.Y;
            var num2 = value1.Z - value2.Z;
            var num = value1.W - value2.W;
            var num5 = (((num4 * num4) + (num3 * num3)) + (num2 * num2)) + (num * num);
            return Math.sqrt(num5);
        }
        static DistanceSquared(value1, value2) {
            var num4 = value1.X - value2.X;
            var num3 = value1.Y - value2.Y;
            var num2 = value1.Z - value2.Z;
            var num = value1.W - value2.W;
            return num4 * num4 + num3 * num3 + num2 * num2 + num * num;
        }
        static Dot(vector1, vector2) {
            return ((((vector1.X * vector2.X) + (vector1.Y * vector2.Y)) + (vector1.Z * vector2.Z)) + (vector1.W * vector2.W));
        }
        Normalize() {
            var num2 = (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z)) + (this.W * this.W);
            var num = 1 / (Math.sqrt(num2));
            this.X *= num;
            this.Y *= num;
            this.Z *= num;
            this.W *= num;
        }
        static Normalize(vector, result = null) {
            if (result == null)
                result = new Vector4();
            var num2 = (((vector.X * vector.X) + (vector.Y * vector.Y)) + (vector.Z * vector.Z)) + (vector.W * vector.W);
            var num = 1 / (Math.sqrt(num2));
            result.X = vector.X * num;
            result.Y = vector.Y * num;
            result.Z = vector.Z * num;
            result.W = vector.W * num;
            return result;
        }
        SetNormalize(vector) {
            var num2 = (((vector.X * vector.X) + (vector.Y * vector.Y)) + (vector.Z * vector.Z)) + (vector.W * vector.W);
            var num = 1 / (Math.sqrt(num2));
            this.X = vector.X * num;
            this.Y = vector.Y * num;
            this.Z = vector.Z * num;
            this.W = vector.W * num;
            return this;
        }
        static Min(value1, value2, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = (value1.X < value2.X) ? value1.X : value2.X;
            result.Y = (value1.Y < value2.Y) ? value1.Y : value2.Y;
            result.Z = (value1.Z < value2.Z) ? value1.Z : value2.Z;
            result.W = (value1.W < value2.W) ? value1.W : value2.W;
            return result;
        }
        SetMin(value1, value2) {
            this.X = (value1.X < value2.X) ? value1.X : value2.X;
            this.Y = (value1.Y < value2.Y) ? value1.Y : value2.Y;
            this.Z = (value1.Z < value2.Z) ? value1.Z : value2.Z;
            this.W = (value1.W < value2.W) ? value1.W : value2.W;
            return this;
        }
        static Max(value1, value2, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = (value1.X > value2.X) ? value1.X : value2.X;
            result.Y = (value1.Y > value2.Y) ? value1.Y : value2.Y;
            result.Z = (value1.Z > value2.Z) ? value1.Z : value2.Z;
            result.W = (value1.W > value2.W) ? value1.W : value2.W;
            return result;
        }
        SetMax(value1, value2) {
            this.X = (value1.X > value2.X) ? value1.X : value2.X;
            this.Y = (value1.Y > value2.Y) ? value1.Y : value2.Y;
            this.Z = (value1.Z > value2.Z) ? value1.Z : value2.Z;
            this.W = (value1.W > value2.W) ? value1.W : value2.W;
            return this;
        }
        static Clamp(value1, min, max, result = null) {
            var x = value1.X;
            x = (x > max.X) ? max.X : x;
            x = (x < min.X) ? min.X : x;
            var y = value1.Y;
            y = (y > max.Y) ? max.Y : y;
            y = (y < min.Y) ? min.Y : y;
            var z = value1.Z;
            z = (z > max.Z) ? max.Z : z;
            z = (z < min.Z) ? min.Z : z;
            var w = value1.W;
            w = (w > max.W) ? max.W : w;
            w = (w < min.W) ? min.W : w;
            if (result == null)
                result = new Vector4();
            result.X = x;
            result.Y = y;
            result.Z = z;
            result.W = w;
            return result;
        }
        SetClamp(value1, min, max) {
            var x = value1.X;
            x = (x > max.X) ? max.X : x;
            x = (x < min.X) ? min.X : x;
            var y = value1.Y;
            y = (y > max.Y) ? max.Y : y;
            y = (y < min.Y) ? min.Y : y;
            var z = value1.Z;
            z = (z > max.Z) ? max.Z : z;
            z = (z < min.Z) ? min.Z : z;
            var w = value1.W;
            w = (w > max.W) ? max.W : w;
            w = (w < min.W) ? min.W : w;
            this.X = x;
            this.Y = y;
            this.Z = z;
            this.W = w;
            return this;
        }
        static Lerp(value1, value2, amount, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = value1.X + ((value2.X - value1.X) * amount);
            result.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            result.Z = value1.Z + ((value2.Z - value1.Z) * amount);
            result.W = value1.W + ((value2.W - value1.W) * amount);
            return result;
        }
        SetLerp(value1, value2, amount) {
            this.X = value1.X + ((value2.X - value1.X) * amount);
            this.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            this.Z = value1.Z + ((value2.Z - value1.Z) * amount);
            this.W = value1.W + ((value2.W - value1.W) * amount);
            return this;
        }
        static Barycentric(value1, value2, value3, amount1, amount2, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = (value1.X + (amount1 * (value2.X - value1.X))) + (amount2 * (value3.X - value1.X));
            result.Y = (value1.Y + (amount1 * (value2.Y - value1.Y))) + (amount2 * (value3.Y - value1.Y));
            result.Z = (value1.Z + (amount1 * (value2.Z - value1.Z))) + (amount2 * (value3.Z - value1.Z));
            result.W = (value1.W + (amount1 * (value2.W - value1.W))) + (amount2 * (value3.W - value1.W));
            return result;
        }
        SetBarycentric(value1, value2, value3, amount1, amount2) {
            this.X = (value1.X + (amount1 * (value2.X - value1.X))) + (amount2 * (value3.X - value1.X));
            this.Y = (value1.Y + (amount1 * (value2.Y - value1.Y))) + (amount2 * (value3.Y - value1.Y));
            this.Z = (value1.Z + (amount1 * (value2.Z - value1.Z))) + (amount2 * (value3.Z - value1.Z));
            this.W = (value1.W + (amount1 * (value2.W - value1.W))) + (amount2 * (value3.W - value1.W));
            return this;
        }
        static SmoothStepRef(value1, value2, amount, result = null) {
            amount = (amount > 1) ? 1 : ((amount < 0) ? 0 : amount);
            amount = (amount * amount) * (3 - (2 * amount));
            if (result == null)
                result = new Vector4();
            result.X = value1.X + ((value2.X - value1.X) * amount);
            result.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            result.Z = value1.Z + ((value2.Z - value1.Z) * amount);
            result.W = value1.W + ((value2.W - value1.W) * amount);
            return result;
        }
        SetSmoothStep(value1, value2, amount) {
            amount = (amount > 1) ? 1 : ((amount < 0) ? 0 : amount);
            amount = (amount * amount) * (3 - (2 * amount));
            this.X = value1.X + ((value2.X - value1.X) * amount);
            this.Y = value1.Y + ((value2.Y - value1.Y) * amount);
            this.Z = value1.Z + ((value2.Z - value1.Z) * amount);
            this.W = value1.W + ((value2.W - value1.W) * amount);
            return this;
        }
        static CatmullRomRef(value1, value2, value3, value4, amount, result = null) {
            var num = amount * amount;
            var num2 = amount * num;
            if (result == null)
                result = new Vector4();
            result.X = 0.5 * ((((2 * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2 * value1.X) - (5 * value2.X)) + (4 * value3.X)) - value4.X) * num)) + ((((-value1.X + (3 * value2.X)) - (3 * value3.X)) + value4.X) * num2));
            result.Y = 0.5 * ((((2 * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2 * value1.Y) - (5 * value2.Y)) + (4 * value3.Y)) - value4.Y) * num)) + ((((-value1.Y + (3 * value2.Y)) - (3 * value3.Y)) + value4.Y) * num2));
            result.Z = 0.5 * ((((2 * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2 * value1.Z) - (5 * value2.Z)) + (4 * value3.Z)) - value4.Z) * num)) + ((((-value1.Z + (3 * value2.Z)) - (3 * value3.Z)) + value4.Z) * num2));
            result.W = 0.5 * ((((2 * value2.W) + ((-value1.W + value3.W) * amount)) + (((((2 * value1.W) - (5 * value2.W)) + (4 * value3.W)) - value4.W) * num)) + ((((-value1.W + (3 * value2.W)) - (3 * value3.W)) + value4.W) * num2));
            return result;
        }
        SetCatmullRom(value1, value2, value3, value4, amount) {
            var num = amount * amount;
            var num2 = amount * num;
            this.X = 0.5 * ((((2 * value2.X) + ((-value1.X + value3.X) * amount)) + (((((2 * value1.X) - (5 * value2.X)) + (4 * value3.X)) - value4.X) * num)) + ((((-value1.X + (3 * value2.X)) - (3 * value3.X)) + value4.X) * num2));
            this.Y = 0.5 * ((((2 * value2.Y) + ((-value1.Y + value3.Y) * amount)) + (((((2 * value1.Y) - (5 * value2.Y)) + (4 * value3.Y)) - value4.Y) * num)) + ((((-value1.Y + (3 * value2.Y)) - (3 * value3.Y)) + value4.Y) * num2));
            this.Z = 0.5 * ((((2 * value2.Z) + ((-value1.Z + value3.Z) * amount)) + (((((2 * value1.Z) - (5 * value2.Z)) + (4 * value3.Z)) - value4.Z) * num)) + ((((-value1.Z + (3 * value2.Z)) - (3 * value3.Z)) + value4.Z) * num2));
            this.W = 0.5 * ((((2 * value2.W) + ((-value1.W + value3.W) * amount)) + (((((2 * value1.W) - (5 * value2.W)) + (4 * value3.W)) - value4.W) * num)) + ((((-value1.W + (3 * value2.W)) - (3 * value3.W)) + value4.W) * num2));
            return this;
        }
        static HermiteRef(value1, tangent1, value2, tangent2, amount, result = null) {
            var num = amount * amount;
            var num6 = amount * num;
            var num5 = ((2 * num6) - (3 * num)) + 1;
            var num4 = (-2 * num6) + (3 * num);
            var num3 = (num6 - (2 * num)) + amount;
            var num2 = num6 - num;
            if (result == null)
                result = new Vector4();
            result.X = (((value1.X * num5) + (value2.X * num4)) + (tangent1.X * num3)) + (tangent2.X * num2);
            result.Y = (((value1.Y * num5) + (value2.Y * num4)) + (tangent1.Y * num3)) + (tangent2.Y * num2);
            result.Z = (((value1.Z * num5) + (value2.Z * num4)) + (tangent1.Z * num3)) + (tangent2.Z * num2);
            result.W = (((value1.W * num5) + (value2.W * num4)) + (tangent1.W * num3)) + (tangent2.W * num2);
            return result;
        }
        SetHermite(value1, tangent1, value2, tangent2, amount) {
            var num = amount * amount;
            var num6 = amount * num;
            var num5 = ((2 * num6) - (3 * num)) + 1;
            var num4 = (-2 * num6) + (3 * num);
            var num3 = (num6 - (2 * num)) + amount;
            var num2 = num6 - num;
            this.X = (((value1.X * num5) + (value2.X * num4)) + (tangent1.X * num3)) + (tangent2.X * num2);
            this.Y = (((value1.Y * num5) + (value2.Y * num4)) + (tangent1.Y * num3)) + (tangent2.Y * num2);
            this.Z = (((value1.Z * num5) + (value2.Z * num4)) + (tangent1.Z * num3)) + (tangent2.Z * num2);
            this.W = (((value1.W * num5) + (value2.W * num4)) + (tangent1.W * num3)) + (tangent2.W * num2);
            return this;
        }
        static TransformVector2(position, matrix, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = ((position.X * matrix.M11) + (position.Y * matrix.M21)) + matrix.M41;
            result.Y = ((position.X * matrix.M12) + (position.Y * matrix.M22)) + matrix.M42;
            result.Z = ((position.X * matrix.M13) + (position.Y * matrix.M23)) + matrix.M43;
            result.W = ((position.X * matrix.M14) + (position.Y * matrix.M24)) + matrix.M44;
            return result;
        }
        SetTransformVector2(position, matrix) {
            this.X = ((position.X * matrix.M11) + (position.Y * matrix.M21)) + matrix.M41;
            this.Y = ((position.X * matrix.M12) + (position.Y * matrix.M22)) + matrix.M42;
            this.Z = ((position.X * matrix.M13) + (position.Y * matrix.M23)) + matrix.M43;
            this.W = ((position.X * matrix.M14) + (position.Y * matrix.M24)) + matrix.M44;
            return this;
        }
        static TransformVector3(position, matrix, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = (((position.X * matrix.M11) + (position.Y * matrix.M21)) + (position.Z * matrix.M31)) + matrix.M41;
            result.Y = (((position.X * matrix.M12) + (position.Y * matrix.M22)) + (position.Z * matrix.M32)) + matrix.M42;
            result.Z = (((position.X * matrix.M13) + (position.Y * matrix.M23)) + (position.Z * matrix.M33)) + matrix.M43;
            result.W = (((position.X * matrix.M14) + (position.Y * matrix.M24)) + (position.Z * matrix.M34)) + matrix.M44;
            return result;
        }
        SetTransformVector3(position, matrix) {
            this.X = (((position.X * matrix.M11) + (position.Y * matrix.M21)) + (position.Z * matrix.M31)) + matrix.M41;
            this.Y = (((position.X * matrix.M12) + (position.Y * matrix.M22)) + (position.Z * matrix.M32)) + matrix.M42;
            this.Z = (((position.X * matrix.M13) + (position.Y * matrix.M23)) + (position.Z * matrix.M33)) + matrix.M43;
            this.W = (((position.X * matrix.M14) + (position.Y * matrix.M24)) + (position.Z * matrix.M34)) + matrix.M44;
            return this;
        }
        static Transform(vector, matrix, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = (((vector.X * matrix.M11) + (vector.Y * matrix.M21)) + (vector.Z * matrix.M31)) + (vector.W * matrix.M41);
            result.Y = (((vector.X * matrix.M12) + (vector.Y * matrix.M22)) + (vector.Z * matrix.M32)) + (vector.W * matrix.M42);
            result.Z = (((vector.X * matrix.M13) + (vector.Y * matrix.M23)) + (vector.Z * matrix.M33)) + (vector.W * matrix.M43);
            result.W = (((vector.X * matrix.M14) + (vector.Y * matrix.M24)) + (vector.Z * matrix.M34)) + (vector.W * matrix.M44);
            return result;
        }
        SetTransform(vector, matrix) {
            this.X = (((vector.X * matrix.M11) + (vector.Y * matrix.M21)) + (vector.Z * matrix.M31)) + (vector.W * matrix.M41);
            this.Y = (((vector.X * matrix.M12) + (vector.Y * matrix.M22)) + (vector.Z * matrix.M32)) + (vector.W * matrix.M42);
            this.Z = (((vector.X * matrix.M13) + (vector.Y * matrix.M23)) + (vector.Z * matrix.M33)) + (vector.W * matrix.M43);
            this.W = (((vector.X * matrix.M14) + (vector.Y * matrix.M24)) + (vector.Z * matrix.M34)) + (vector.W * matrix.M44);
            return this;
        }
        static TransformVector2Quaternion(value, rotation, result = null) {
            if (result == null)
                result = new Vector4();
            var num6 = rotation.X + rotation.X;
            var num2 = rotation.Y + rotation.Y;
            var num = rotation.Z + rotation.Z;
            var num15 = rotation.W * num6;
            var num14 = rotation.W * num2;
            var num5 = rotation.W * num;
            var num13 = rotation.X * num6;
            var num4 = rotation.X * num2;
            var num12 = rotation.X * num;
            var num11 = rotation.Y * num2;
            var num10 = rotation.Y * num;
            var num3 = rotation.Z * num;
            var num9 = (value.X * ((1 - num11) - num3)) + (value.Y * (num4 - num5));
            var num8 = (value.X * (num4 + num5)) + (value.Y * ((1 - num13) - num3));
            var num7 = (value.X * (num12 - num14)) + (value.Y * (num10 + num15));
            result.X = num9;
            result.Y = num8;
            result.Z = num7;
            result.W = 1;
            return result;
        }
        SetTransformVector2Quaternion(value, rotation) {
            var num6 = rotation.X + rotation.X;
            var num2 = rotation.Y + rotation.Y;
            var num = rotation.Z + rotation.Z;
            var num15 = rotation.W * num6;
            var num14 = rotation.W * num2;
            var num5 = rotation.W * num;
            var num13 = rotation.X * num6;
            var num4 = rotation.X * num2;
            var num12 = rotation.X * num;
            var num11 = rotation.Y * num2;
            var num10 = rotation.Y * num;
            var num3 = rotation.Z * num;
            var num9 = (value.X * ((1 - num11) - num3)) + (value.Y * (num4 - num5));
            var num8 = (value.X * (num4 + num5)) + (value.Y * ((1 - num13) - num3));
            var num7 = (value.X * (num12 - num14)) + (value.Y * (num10 + num15));
            this.X = num9;
            this.Y = num8;
            this.Z = num7;
            this.W = 1;
            return this;
        }
        static TransformVector3Quaternion(value, rotation, result = null) {
            if (result == null)
                result = new Vector4();
            var num12 = rotation.X + rotation.X;
            var num2 = rotation.Y + rotation.Y;
            var num = rotation.Z + rotation.Z;
            var num11 = rotation.W * num12;
            var num10 = rotation.W * num2;
            var num9 = rotation.W * num;
            var num8 = rotation.X * num12;
            var num7 = rotation.X * num2;
            var num6 = rotation.X * num;
            var num5 = rotation.Y * num2;
            var num4 = rotation.Y * num;
            var num3 = rotation.Z * num;
            var num15 = ((value.X * ((1 - num5) - num3)) + (value.Y * (num7 - num9))) + (value.Z * (num6 + num10));
            var num14 = ((value.X * (num7 + num9)) + (value.Y * ((1 - num8) - num3))) + (value.Z * (num4 - num11));
            var num13 = ((value.X * (num6 - num10)) + (value.Y * (num4 + num11))) + (value.Z * ((1 - num8) - num5));
            result.X = num15;
            result.Y = num14;
            result.Z = num13;
            result.W = 1;
            return result;
        }
        SetTransformVector3Quaternion(value, rotation) {
            var num12 = rotation.X + rotation.X;
            var num2 = rotation.Y + rotation.Y;
            var num = rotation.Z + rotation.Z;
            var num11 = rotation.W * num12;
            var num10 = rotation.W * num2;
            var num9 = rotation.W * num;
            var num8 = rotation.X * num12;
            var num7 = rotation.X * num2;
            var num6 = rotation.X * num;
            var num5 = rotation.Y * num2;
            var num4 = rotation.Y * num;
            var num3 = rotation.Z * num;
            var num15 = ((value.X * ((1 - num5) - num3)) + (value.Y * (num7 - num9))) + (value.Z * (num6 + num10));
            var num14 = ((value.X * (num7 + num9)) + (value.Y * ((1 - num8) - num3))) + (value.Z * (num4 - num11));
            var num13 = ((value.X * (num6 - num10)) + (value.Y * (num4 + num11))) + (value.Z * ((1 - num8) - num5));
            this.X = num15;
            this.Y = num14;
            this.Z = num13;
            this.W = 1;
            return this;
        }
        static TransformVector4Quaternion(value, rotation, result = null) {
            if (result == null)
                result = new Vector4();
            var num12 = rotation.X + rotation.X;
            var num2 = rotation.Y + rotation.Y;
            var num = rotation.Z + rotation.Z;
            var num11 = rotation.W * num12;
            var num10 = rotation.W * num2;
            var num9 = rotation.W * num;
            var num8 = rotation.X * num12;
            var num7 = rotation.X * num2;
            var num6 = rotation.X * num;
            var num5 = rotation.Y * num2;
            var num4 = rotation.Y * num;
            var num3 = rotation.Z * num;
            var num15 = ((value.X * ((1 - num5) - num3)) + (value.Y * (num7 - num9))) + (value.Z * (num6 + num10));
            var num14 = ((value.X * (num7 + num9)) + (value.Y * ((1 - num8) - num3))) + (value.Z * (num4 - num11));
            var num13 = ((value.X * (num6 - num10)) + (value.Y * (num4 + num11))) + (value.Z * ((1 - num8) - num5));
            result.X = num15;
            result.Y = num14;
            result.Z = num13;
            result.W = value.W;
            return result;
        }
        SetTransformVector4Quaternion(value, rotation) {
            var num12 = rotation.X + rotation.X;
            var num2 = rotation.Y + rotation.Y;
            var num = rotation.Z + rotation.Z;
            var num11 = rotation.W * num12;
            var num10 = rotation.W * num2;
            var num9 = rotation.W * num;
            var num8 = rotation.X * num12;
            var num7 = rotation.X * num2;
            var num6 = rotation.X * num;
            var num5 = rotation.Y * num2;
            var num4 = rotation.Y * num;
            var num3 = rotation.Z * num;
            var num15 = ((value.X * ((1 - num5) - num3)) + (value.Y * (num7 - num9))) + (value.Z * (num6 + num10));
            var num14 = ((value.X * (num7 + num9)) + (value.Y * ((1 - num8) - num3))) + (value.Z * (num4 - num11));
            var num13 = ((value.X * (num6 - num10)) + (value.Y * (num4 + num11))) + (value.Z * ((1 - num8) - num5));
            this.X = num15;
            this.Y = num14;
            this.Z = num13;
            this.W = value.W;
            return this;
        }
        static Negate(value, result) {
            if (result == null)
                result = new Vector4();
            result.X = -value.X;
            result.Y = -value.Y;
            result.Z = -value.Z;
            result.W = -value.W;
            return result;
        }
        SetNegate(value) {
            this.X = -value.X;
            this.Y = -value.Y;
            this.Z = -value.Z;
            this.W = -value.W;
            return this;
        }
        Negate() {
            this.X = -this.X;
            this.Y = -this.Y;
            this.Z = -this.Z;
            this.W = -this.W;
            return this;
        }
        static Add(value1, value2, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = value1.X + value2.X;
            result.Y = value1.Y + value2.Y;
            result.Z = value1.Z + value2.Z;
            result.W = value1.W + value2.W;
            return result;
        }
        SetAdd(value1, value2) {
            this.X = value1.X + value2.X;
            this.Y = value1.Y + value2.Y;
            this.Z = value1.Z + value2.Z;
            this.W = value1.W + value2.W;
            return this;
        }
        Add(value1) {
            this.X = value1.X + this.X;
            this.Y = value1.Y + this.Y;
            this.Z = value1.Z + this.Z;
            this.W = value1.W + this.W;
            return this;
        }
        static Subtract(value1, value2, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = value1.X - value2.X;
            result.Y = value1.Y - value2.Y;
            result.Z = value1.Z - value2.Z;
            result.W = value1.W - value2.W;
            return result;
        }
        SetSubtract(value1, value2) {
            this.X = value1.X - value2.X;
            this.Y = value1.Y - value2.Y;
            this.Z = value1.Z - value2.Z;
            this.W = value1.W - value2.W;
            return this;
        }
        Subtract(value2) {
            this.X = this.X - value2.X;
            this.Y = this.Y - value2.Y;
            this.Z = this.Z - value2.Z;
            this.W = this.W - value2.W;
            return this;
        }
        static Multiply(value1, value2, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = value1.X * value2.X;
            result.Y = value1.Y * value2.Y;
            result.Z = value1.Z * value2.Z;
            result.W = value1.W * value2.W;
            return result;
        }
        SetMultiply(value1, value2) {
            this.X = value1.X * value2.X;
            this.Y = value1.Y * value2.Y;
            this.Z = value1.Z * value2.Z;
            this.W = value1.W * value2.W;
            return this;
        }
        Multiply(value2) {
            this.X = this.X * value2.X;
            this.Y = this.Y * value2.Y;
            this.Z = this.Z * value2.Z;
            this.W = this.W * value2.W;
            return this;
        }
        static Scale(value1, scaleFactor, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = value1.X * scaleFactor;
            result.Y = value1.Y * scaleFactor;
            result.Z = value1.Z * scaleFactor;
            result.W = value1.W * scaleFactor;
            return result;
        }
        SetScale(value1, scaleFactor) {
            this.X = value1.X * scaleFactor;
            this.Y = value1.Y * scaleFactor;
            this.Z = value1.Z * scaleFactor;
            this.W = value1.W * scaleFactor;
            return this;
        }
        Scale(scaleFactor) {
            this.X = this.X * scaleFactor;
            this.Y = this.Y * scaleFactor;
            this.Z = this.Z * scaleFactor;
            this.W = this.W * scaleFactor;
            return this;
        }
        static Divide(value1, value2, result = null) {
            if (result == null)
                result = new Vector4();
            result.X = value1.X / value2.X;
            result.Y = value1.Y / value2.Y;
            result.Z = value1.Z / value2.Z;
            result.W = value1.W / value2.W;
            return result;
        }
        SetDivide(value1, value2) {
            this.X = value1.X / value2.X;
            this.Y = value1.Y / value2.Y;
            this.Z = value1.Z / value2.Z;
            this.W = value1.W / value2.W;
            return this;
        }
        Divide(value2) {
            this.X = this.X / value2.X;
            this.Y = this.Y / value2.Y;
            this.Z = this.Z / value2.Z;
            this.W = this.W / value2.W;
            return this;
        }
        FromArray(array, index = 0) {
            this.X = array[index];
            this.Y = array[index + 1];
            this.Z = array[index + 2];
            this.W = array[index + 3];
            return this;
        }
        ToArray(array, index = 0) {
            array[index] = this.X;
            array[index + 1] = this.Y;
            array[index + 2] = this.Z;
            array[index + 3] = this.W;
            return this;
        }
    }
    U1.Vector4 = Vector4;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Ray2 {
        constructor(position = U1.Vector2.Zero, direction = U1.Vector2.UnitX) {
            this.Position = position;
            this.Direction = direction;
        }
        Clone() {
            var copy = new Ray2();
            copy.Position.CopyFrom(this.Position);
            copy.Direction.CopyFrom(this.Direction);
            return copy;
        }
        ConvertFromStr(value) {
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            var idx = 0;
            this.Position.X = items.length > idx ? (items[idx++]) : 0;
            this.Position.Y = items.length > idx ? (items[idx++]) : 0;
            this.Direction.X = items.length > idx ? (items[idx++]) : 0;
            this.Direction.Y = items.length > idx ? (items[idx++]) : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this.Position.X, this.Position.Y, this.Direction.X, this.Direction.Y);
        }
        CopyFrom(source) {
            this.Position.CopyFrom(source.Position);
            this.Direction.CopyFrom(source.Direction);
        }
        Equals(other) {
            return this.Position.X == other.Position.X
                && this.Position.Y == other.Position.Y
                && this.Direction.X == other.Direction.X
                && this.Direction.Y == other.Direction.Y;
        }
        static DistanceSquared(ray, pt) {
            var dir = ray.Direction;
            dir.Normalize();
            var distSq = U1.Vector2.DistanceSquared(pt, ray.Position);
            var s = U1.Vector2.Dot(U1.Vector2.Subtract(pt, ray.Position), dir);
            if (s <= 0)
                return distSq;
            return distSq - (s * s);
        }
        static Distance(ray, pt) {
            return Math.sqrt(Ray2.DistanceSquared(ray, pt));
        }
    }
    U1.Ray2 = Ray2;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Ray3 {
        constructor(position = U1.Vector3.Zero, direction = U1.Vector3.Zero) {
            this.Position = position;
            this.Direction = direction;
        }
        ConvertFromStr(value) {
            this.Position = this.Position == null ? new U1.Vector3() : this.Position;
            this.Direction = this.Direction == null ? new U1.Vector3() : this.Direction;
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            this.Position.X = items.length > 0 ? (items[0]) : 0;
            this.Position.Y = items.length > 1 ? (items[1]) : 0;
            this.Position.Z = items.length > 2 ? (items[2]) : 0;
            this.Direction.X = items.length > 3 ? (items[3]) : 0;
            this.Direction.Y = items.length > 4 ? (items[4]) : 0;
            this.Direction.Z = items.length > 5 ? (items[5]) : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this.Position.X, this.Position.Y, this.Position.Z, this.Direction.X, this.Direction.Y, this.Direction.Z);
        }
        Equals(other) {
            if (other == this)
                return true;
            if (other == null)
                return false;
            return this.Position.X == other.Position.X
                && this.Position.Y == other.Position.Y
                && this.Position.Z == other.Position.Z
                && this.Direction.X == other.Direction.X
                && this.Direction.Y == other.Direction.Y
                && this.Direction.Z == other.Direction.Z;
        }
        CopyFrom(other) {
            this.Position.CopyFrom(other.Position);
            this.Direction.CopyFrom(other.Direction);
            return this;
        }
        Clone() {
            var copy = new Ray3();
            copy.CopyFrom(this);
            return copy;
        }
        IntersectsBoundingBox(box) {
            return box.IntersectsRay(this);
        }
        IntersectsBoundingFrustum(frustum) {
            if (frustum == null) {
                throw "ArgumentNullException(\"frustum\")";
            }
            return frustum.IntersectsRay(this);
        }
        IntersectsPlane(plane) {
            var num2 = ((plane.Normal.X * this.Direction.X) + (plane.Normal.Y * this.Direction.Y)) + (plane.Normal.Z * this.Direction.Z);
            if (Math.abs(num2) < 1E-05) {
                return null;
            }
            var num3 = ((plane.Normal.X * this.Position.X) + (plane.Normal.Y * this.Position.Y)) + (plane.Normal.Z * this.Position.Z);
            var num = (-plane.D - num3) / num2;
            if (num < 0) {
                if (num < -1E-05) {
                    return null;
                }
                num = 0;
            }
            return num;
        }
        IntersectsBoundingSphere(sphere) {
            var num5 = sphere.Center.X - this.Position.X;
            var num4 = sphere.Center.Y - this.Position.Y;
            var num3 = sphere.Center.Z - this.Position.Z;
            var num7 = ((num5 * num5) + (num4 * num4)) + (num3 * num3);
            var num2 = sphere.Radius * sphere.Radius;
            if (num7 <= num2) {
                return 0;
            }
            var num = ((num5 * this.Direction.X) + (num4 * this.Direction.Y)) + (num3 * this.Direction.Z);
            if (num < 0) {
                return null;
            }
            var num6 = num7 - (num * num);
            if (num6 > num2) {
                return null;
            }
            var num8 = Math.sqrt((num2 - num6));
            return num - num8;
        }
        static DistanceSquared(ray, point) {
            let v = Ray3.tmp["ds.v"] || (Ray3.tmp["ds.v"] = new U1.Vector3());
            var dir = ray.Direction;
            var distSq = U1.Vector3.DistanceSquared(point, ray.Position);
            var s = U1.Vector3.Dot(v.SetSubtract(point, ray.Position), dir) / U1.Vector3.Dot(dir, dir);
            if (s <= 0)
                return distSq;
            return distSq - (s * s);
        }
        static DistanceSquared1(ray_p, ray_dir, point) {
            let v = Ray3.tmp["ds.v"] || (Ray3.tmp["ds.v"] = new U1.Vector3());
            var distSq = U1.Vector3.DistanceSquared(point, ray_p);
            var s = U1.Vector3.Dot(v.SetSubtract(point, ray_p), ray_dir) / U1.Vector3.Dot(ray_dir, ray_dir);
            if (s <= 0)
                return distSq;
            return distSq - (s * s);
        }
        Transform(matrix) {
            this.Position.Transform(matrix);
            this.Direction.TransformNormal(matrix);
            return this;
        }
    }
    Ray3.tmp = {};
    U1.Ray3 = Ray3;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Segment2 {
        constructor(start, end) {
            this.Start = new U1.Vector2();
            this.End = new U1.Vector2();
            if (start != null)
                this.Start.CopyFrom(start);
            if (end != null)
                this.End.CopyFrom(end);
        }
        ConvertFromStr(value) {
            if (value == null)
                return;
            var items = value.split(",");
            this.Start.X = items.length > 0 ? parseFloat(items[0]) : 0;
            this.Start.Y = items.length > 1 ? parseFloat(items[1]) : 0;
            this.End.X = items.length > 2 ? parseFloat(items[2]) : 0;
            this.End.Y = items.length > 3 ? parseFloat(items[3]) : 0;
        }
        ConvertToStr() {
            return "" + this.Start.X + "," + this.Start.Y + "," + this.End.X + "," + this.End.Y;
        }
        Equals(other) {
            return this.Start.Equals(other.Start) && this.End.Equals(other.End);
        }
        static CheckCross(seg0, seg1, result) {
            var s0 = seg0.Start;
            var s1 = seg0.End;
            var t0 = seg1.Start;
            var t1 = seg1.End;
            var tv0 = Segment2[".ckc.v0"] || (Segment2[".ckc.v0"] = new U1.Vector2());
            var tv1 = Segment2[".ckc.v1"] || (Segment2[".ckc.v1"] = new U1.Vector2());
            if ((s0.X < t0.X && s0.X < t1.X && s1.X < t0.X && s1.X < t1.X) ||
                (s0.X > t0.X && s0.X > t1.X && s1.X > t0.X && s1.X > t1.X))
                return null;
            if ((s0.Y < t0.Y && s0.Y < t1.Y && s1.Y < t0.Y && s1.Y < t1.Y) ||
                (s0.Y > t0.Y && s0.Y > t1.Y && s1.Y > t0.Y && s1.Y > t1.Y))
                return null;
            var sd = tv0.SetSubtract(s1, s0);
            var td = tv1.SetSubtract(t1, t0);
            var isect = U1.GeometryHelper2.CrossLineLine(s0, sd, t0, td);
            if (isect == null) {
                return null;
            }
            if (isect.s < 0 || isect.s > 1 || isect.t < 0 || isect.t > 1)
                return null;
            if (result == null)
                result = new U1.Vector2();
            var o_crossv = result.SetScaleAdd(s0, isect.s, sd);
            return o_crossv;
        }
        static IsIntersectPolylines(source, target) {
            for (var i = 1; i < source.length; i++) {
                var seg0 = new Segment2(source[i - 1], source[i]);
                for (var j = 1; j < target.length; j++) {
                    var seg1 = new Segment2(target[j - 1], target[j]);
                    if (Segment2.CheckCross(seg0, seg1) != null)
                        return true;
                }
            }
            return false;
        }
        static DistanceSquaredPoint(segment, point) {
            var dir = U1.Vector2.Subtract(segment.End, segment.Start);
            dir.Normalize();
            var distSq = U1.Vector2.DistanceSquared(point, segment.Start);
            var s = U1.Vector2.Dot(U1.Vector2.Subtract(point, segment.Start), dir);
            if (s <= 0)
                return distSq;
            var e = U1.Vector2.Dot(U1.Vector2.Subtract(point, segment.End), U1.Vector2.Negate(dir));
            if (e <= 0) {
                distSq = U1.Vector2.DistanceSquared(point, segment.End);
                return distSq;
            }
            return distSq - (s * s);
        }
        static DistancePoint(segment, point) {
            return Math.sqrt(Segment2.DistanceSquaredPoint(segment, point));
        }
    }
    U1.Segment2 = Segment2;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Matrix4 {
        constructor(m11 = 0, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 0, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 0, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 0) {
            this.m = new Float32Array(16);
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m13;
            this.m[3] = m14;
            this.m[4] = m21;
            this.m[5] = m22;
            this.m[6] = m23;
            this.m[7] = m24;
            this.m[8] = m31;
            this.m[9] = m32;
            this.m[10] = m33;
            this.m[11] = m34;
            this.m[12] = m41;
            this.m[13] = m42;
            this.m[14] = m43;
            this.m[15] = m44;
        }
        get M11() { return this.m[0]; }
        set M11(value) { this.m[0] = value; }
        get M12() { return this.m[1]; }
        set M12(value) { this.m[1] = value; }
        get M13() { return this.m[2]; }
        set M13(value) { this.m[2] = value; }
        get M14() { return this.m[3]; }
        set M14(value) { this.m[3] = value; }
        get M21() { return this.m[4]; }
        set M21(value) { this.m[4] = value; }
        get M22() { return this.m[5]; }
        set M22(value) { this.m[5] = value; }
        get M23() { return this.m[6]; }
        set M23(value) { this.m[6] = value; }
        get M24() { return this.m[7]; }
        set M24(value) { this.m[7] = value; }
        get M31() { return this.m[8]; }
        set M31(value) { this.m[8] = value; }
        get M32() { return this.m[9]; }
        set M32(value) { this.m[9] = value; }
        get M33() { return this.m[10]; }
        set M33(value) { this.m[10] = value; }
        get M34() { return this.m[11]; }
        set M34(value) { this.m[11] = value; }
        get M41() { return this.m[12]; }
        set M41(value) { this.m[12] = value; }
        get M42() { return this.m[13]; }
        set M42(value) { this.m[13] = value; }
        get M43() { return this.m[14]; }
        set M43(value) { this.m[14] = value; }
        get M44() { return this.m[15]; }
        set M44(value) { this.m[15] = value; }
        ConvertFromStr(value) {
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            var idx = 0;
            var m = this.m;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
            m[idx] = items.length > idx ? items[idx++] : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertTypedArrayToString(this.m);
        }
        Clone() {
            var copy = new Matrix4();
            copy.CopyFrom(this);
            return copy;
        }
        Equals(other) {
            for (var i = 0; i < this.m.length; i++) {
                if (this.m[i] !== other.m[i])
                    return false;
            }
            return true;
        }
        CopyFrom(other) {
            for (var i = 0; i < this.m.length; i++) {
                this.m[i] = other.m[i];
            }
            return this;
        }
        Set(m11 = 0, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 0, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 0, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 0) {
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m13;
            this.m[3] = m14;
            this.m[4] = m21;
            this.m[5] = m22;
            this.m[6] = m23;
            this.m[7] = m24;
            this.m[8] = m31;
            this.m[9] = m32;
            this.m[10] = m33;
            this.m[11] = m34;
            this.m[12] = m41;
            this.m[13] = m42;
            this.m[14] = m43;
            this.m[15] = m44;
            return this;
        }
        static get Identity() {
            return new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        SetIdentity() {
            this.Set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        }
        get Up() {
            return new U1.Vector3(this.m[4], this.m[5], this.m[6]);
        }
        set Up(value) {
            this.m[4] = value.X;
            this.m[5] = value.Y;
            this.m[6] = value.Z;
        }
        GetUp(result = null) {
            if (result == null)
                result = new U1.Vector3();
            result.Set(this.m[4], this.m[5], this.m[6]);
            return result;
        }
        get Down() {
            return new U1.Vector3(-this.m[4], -this.m[5], -this.m[6]);
        }
        set Down(value) {
            this.m[4] = -value.X;
            this.m[5] = -value.Y;
            this.m[6] = -value.Z;
        }
        GetDown(result = null) {
            if (result == null)
                result = new U1.Vector3();
            result.Set(-this.m[4], -this.m[5], -this.m[6]);
            return result;
        }
        get Right() {
            return new U1.Vector3(this.m[0], this.m[1], this.m[2]);
        }
        set Right(value) {
            this.m[0] = value.X;
            this.m[1] = value.Y;
            this.m[2] = value.Z;
        }
        GetRight(result = null) {
            if (result == null)
                result = new U1.Vector3();
            result.Set(this.m[0], this.m[1], this.m[2]);
            return result;
        }
        get Left() {
            return new U1.Vector3(-this.m[0], -this.m[1], -this.m[2]);
        }
        set Left(value) {
            this.m[0] = -value.X;
            this.m[1] = -value.Y;
            this.m[2] = -value.Z;
        }
        GetLeft(result = null) {
            if (result == null)
                result = new U1.Vector3();
            result.Set(-this.m[0], -this.m[1], -this.m[2]);
            return result;
        }
        get Forward() {
            return new U1.Vector3(-this.m[8], -this.m[9], -this.m[10]);
        }
        set Forward(value) {
            this.m[8] = -value.X;
            this.m[9] = -value.Y;
            this.m[10] = -value.Z;
        }
        GetForward(result = null) {
            if (result == null)
                result = new U1.Vector3();
            result.Set(-this.m[8], -this.m[9], -this.m[10]);
            return result;
        }
        get Backward() {
            return new U1.Vector3(this.m[8], this.m[9], this.m[10]);
        }
        set Backward(value) {
            this.m[8] = value.X;
            this.m[9] = value.Y;
            this.m[10] = value.Z;
        }
        GetBackward(result = null) {
            if (result == null)
                result = new U1.Vector3();
            result.Set(this.m[8], this.m[9], this.m[10]);
            return result;
        }
        get Translation() {
            return new U1.Vector3(this.m[12], this.m[13], this.m[14]);
        }
        set Translation(value) {
            this.m[12] = value.X;
            this.m[13] = value.Y;
            this.m[14] = value.Z;
        }
        GetTranslation(result = null) {
            if (result == null)
                result = new U1.Vector3();
            result.Set(this.m[12], this.m[13], this.m[14]);
            return result;
        }
        static CreateFromAxes(xAxis, yAxis, zAxis, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            result.m[0] = xAxis.X;
            result.m[1] = xAxis.Y;
            result.m[2] = xAxis.Z;
            result.m[4] = yAxis.X;
            result.m[5] = yAxis.Y;
            result.m[6] = yAxis.Z;
            result.m[8] = zAxis.X;
            result.m[9] = zAxis.Y;
            result.m[10] = zAxis.Z;
            return result;
        }
        static CreateBillboard(objectPosition, cameraPosition, cameraUpVector, cameraForwardVector, result = null) {
            if (result == null)
                result = new Matrix4();
            var vector1 = Matrix4[".cb.v1."] || (Matrix4[".cb.v1."] = new U1.Vector3());
            var vector2 = Matrix4[".cb.v2."] || (Matrix4[".cb.v2."] = new U1.Vector3());
            var vector3 = Matrix4[".cb.v3."] || (Matrix4[".cb.v3."] = new U1.Vector3());
            vector1.X = objectPosition.X - cameraPosition.X;
            vector1.Y = objectPosition.Y - cameraPosition.Y;
            vector1.Z = objectPosition.Z - cameraPosition.Z;
            var num = vector1.LengthSquareduared();
            if (num < 0.0001) {
                vector1 = cameraForwardVector != null ? vector1.SetNegate(cameraForwardVector) : vector1.SetForward();
            }
            else {
                vector1.Scale(1 / (Math.sqrt(num)));
            }
            vector3.SetCross(cameraUpVector, vector1).Normalize();
            vector2.SetCross(vector1, vector3).Normalize();
            result.m[0] = vector3.X;
            result.m[1] = vector3.Y;
            result.m[2] = vector3.Z;
            result.m[3] = 0;
            result.m[4] = vector2.X;
            result.m[5] = vector2.Y;
            result.m[6] = vector2.Z;
            result.m[7] = 0;
            result.m[8] = vector1.X;
            result.m[9] = vector1.Y;
            result.m[10] = vector1.Z;
            result.m[11] = 0;
            result.m[12] = objectPosition.X;
            result.m[13] = objectPosition.Y;
            result.m[14] = objectPosition.Z;
            result.m[15] = 1;
            return result;
        }
        SetCreateBillboard(objectPosition, cameraPosition, cameraUpVector, cameraForwardVector) {
            var vector1 = Matrix4[".sb.v1."] || (Matrix4[".sb.v1."] = new U1.Vector3());
            var vector2 = Matrix4[".sb.v2."] || (Matrix4[".sb.v2."] = new U1.Vector3());
            var vector3 = Matrix4[".sb.v3."] || (Matrix4[".sb.v3."] = new U1.Vector3());
            vector1.SetSubtract(objectPosition, cameraPosition);
            var num = vector1.LengthSquareduared();
            if (num < 0.0001) {
                vector1 = cameraForwardVector != null
                    ? vector1.SetNegate(cameraForwardVector)
                    : vector1.SetForward();
            }
            else {
                vector1.Scale(1 / (Math.sqrt(num)));
            }
            vector3.SetCross(cameraUpVector, vector1).Normalize();
            vector2.SetCross(vector1, vector3).Normalize();
            this.m[0] = vector3.X;
            this.m[1] = vector3.Y;
            this.m[2] = vector3.Z;
            this.m[3] = 0;
            this.m[4] = vector2.X;
            this.m[5] = vector2.Y;
            this.m[6] = vector2.Z;
            this.m[7] = 0;
            this.m[8] = vector1.X;
            this.m[9] = vector1.Y;
            this.m[10] = vector1.Z;
            this.m[11] = 0;
            this.m[12] = objectPosition.X;
            this.m[13] = objectPosition.Y;
            this.m[14] = objectPosition.Z;
            this.m[15] = 1;
            return this;
        }
        static CreateConstrainedBillboard(objectPosition, cameraPosition, rotateAxis, cameraForwardVector, objectForwardVector, result = null) {
            var num;
            if (result == null)
                result = Matrix4.Identity;
            var vector1 = Matrix4[".ccb.v1."] || (Matrix4[".ccb.v1."] = new U1.Vector3());
            var vector2 = Matrix4[".ccb.v2."] || (Matrix4[".ccb.v2."] = new U1.Vector3());
            var vector3 = Matrix4[".ccb.v3."] || (Matrix4[".ccb.v3."] = new U1.Vector3());
            vector2.X = objectPosition.X - cameraPosition.X;
            vector2.Y = objectPosition.Y - cameraPosition.Y;
            vector2.Z = objectPosition.Z - cameraPosition.Z;
            var num2 = vector2.LengthSquareduared();
            if (num2 < 0.0001) {
                vector2 = cameraForwardVector != null ? U1.Vector3.Negate(cameraForwardVector) : U1.Vector3.Forward;
            }
            else {
                vector2.Scale(1 / (Math.sqrt(num2)));
            }
            var vector4 = rotateAxis;
            num = U1.Vector3.Dot(rotateAxis, vector2);
            if (Math.abs(num) > 0.9982547) {
                if (objectForwardVector != null) {
                    vector1 = objectForwardVector;
                    num = U1.Vector3.Dot(rotateAxis, vector1);
                    if (Math.abs(num) > 0.9982547) {
                        num = ((rotateAxis.X * U1.Vector3.Forward.X) + (rotateAxis.Y * U1.Vector3.Forward.Y)) + (rotateAxis.Z * U1.Vector3.Forward.Z);
                        vector1 = (Math.abs(num) > 0.9982547) ? U1.Vector3.Right : U1.Vector3.Forward;
                    }
                }
                else {
                    num = ((rotateAxis.X * U1.Vector3.Forward.X) + (rotateAxis.Y * U1.Vector3.Forward.Y)) + (rotateAxis.Z * U1.Vector3.Forward.Z);
                    vector1 = (Math.abs(num) > 0.9982547) ? U1.Vector3.Right : U1.Vector3.Forward;
                }
                vector3.SetCross(rotateAxis, vector1).Normalize();
                vector1.SetCross(vector3, rotateAxis).Normalize();
            }
            else {
                vector3.SetCross(rotateAxis, vector2).Normalize();
                vector1.SetCross(vector3, vector4).Normalize();
            }
            result.m[0] = vector3.X;
            result.m[1] = vector3.Y;
            result.m[2] = vector3.Z;
            result.m[3] = 0;
            result.m[4] = vector4.X;
            result.m[5] = vector4.Y;
            result.m[6] = vector4.Z;
            result.m[7] = 0;
            result.m[8] = vector1.X;
            result.m[9] = vector1.Y;
            result.m[10] = vector1.Z;
            result.m[11] = 0;
            result.m[12] = objectPosition.X;
            result.m[13] = objectPosition.Y;
            result.m[14] = objectPosition.Z;
            result.m[15] = 1;
            return result;
        }
        SetCreateConstrainedBillboard(objectPosition, cameraPosition, rotateAxis, cameraForwardVector, objectForwardVector) {
            var num;
            var vector1 = Matrix4[".scb.v1."] || (Matrix4[".scb.v1."] = new U1.Vector3());
            var vector2 = Matrix4[".scb.v2."] || (Matrix4[".scb.v2."] = new U1.Vector3());
            var vector3 = Matrix4[".scb.v3."] || (Matrix4[".scb.v3."] = new U1.Vector3());
            vector2.X = objectPosition.X - cameraPosition.X;
            vector2.Y = objectPosition.Y - cameraPosition.Y;
            vector2.Z = objectPosition.Z - cameraPosition.Z;
            var num2 = vector2.LengthSquareduared();
            if (num2 < 0.0001) {
                vector2 = cameraForwardVector != null
                    ? vector2.SetNegate(cameraForwardVector)
                    : vector2.SetForward();
            }
            else {
                vector2.Scale(1 / (Math.sqrt(num2)));
            }
            var vector4 = rotateAxis;
            num = U1.Vector3.Dot(rotateAxis, vector2);
            if (Math.abs(num) > 0.9982547) {
                if (objectForwardVector != null) {
                    vector1 = objectForwardVector;
                    num = U1.Vector3.Dot(rotateAxis, vector1);
                    if (Math.abs(num) > 0.9982547) {
                        num = ((rotateAxis.X * U1.Vector3.Forward.X) + (rotateAxis.Y * U1.Vector3.Forward.Y)) + (rotateAxis.Z * U1.Vector3.Forward.Z);
                        vector1 = (Math.abs(num) > 0.9982547) ? U1.Vector3.Right : U1.Vector3.Forward;
                    }
                }
                else {
                    num = ((rotateAxis.X * U1.Vector3.Forward.X) + (rotateAxis.Y * U1.Vector3.Forward.Y)) + (rotateAxis.Z * U1.Vector3.Forward.Z);
                    vector1 = (Math.abs(num) > 0.9982547) ? U1.Vector3.Right : U1.Vector3.Forward;
                }
                vector3.SetCross(rotateAxis, vector1).Normalize();
                vector1.SetCross(vector3, rotateAxis).Normalize();
            }
            else {
                vector3.SetCross(rotateAxis, vector2).Normalize();
                vector1.SetCross(vector3, vector4).Normalize();
            }
            this.m[0] = vector3.X;
            this.m[1] = vector3.Y;
            this.m[2] = vector3.Z;
            this.m[3] = 0;
            this.m[4] = vector4.X;
            this.m[5] = vector4.Y;
            this.m[6] = vector4.Z;
            this.m[7] = 0;
            this.m[8] = vector1.X;
            this.m[9] = vector1.Y;
            this.m[10] = vector1.Z;
            this.m[11] = 0;
            this.m[12] = objectPosition.X;
            this.m[13] = objectPosition.Y;
            this.m[14] = objectPosition.Z;
            this.m[15] = 1;
            return this;
        }
        static CreateTranslation(position, result = null) {
            if (result == null)
                result = new Matrix4();
            result.m[0] = 1;
            result.m[1] = 0;
            result.m[2] = 0;
            result.m[3] = 0;
            result.m[4] = 0;
            result.m[5] = 1;
            result.m[6] = 0;
            result.m[7] = 0;
            result.m[8] = 0;
            result.m[9] = 0;
            result.m[10] = 1;
            result.m[11] = 0;
            result.m[12] = position.X;
            result.m[13] = position.Y;
            result.m[14] = position.Z;
            result.m[15] = 1;
            return result;
        }
        static CreateTranslationFloats(x, y, z, result = null) {
            if (result == null)
                result = new Matrix4();
            result.m[0] = 1;
            result.m[1] = 0;
            result.m[2] = 0;
            result.m[3] = 0;
            result.m[4] = 0;
            result.m[5] = 1;
            result.m[6] = 0;
            result.m[7] = 0;
            result.m[8] = 0;
            result.m[9] = 0;
            result.m[10] = 1;
            result.m[11] = 0;
            result.m[12] = x;
            result.m[13] = y;
            result.m[14] = z;
            result.m[15] = 1;
            return result;
        }
        SetCreateTranslation(position) {
            this.m[0] = 1;
            this.m[1] = 0;
            this.m[2] = 0;
            this.m[3] = 0;
            this.m[4] = 0;
            this.m[5] = 1;
            this.m[6] = 0;
            this.m[7] = 0;
            this.m[8] = 0;
            this.m[9] = 0;
            this.m[10] = 1;
            this.m[11] = 0;
            this.m[12] = position.X;
            this.m[13] = position.Y;
            this.m[14] = position.Z;
            this.m[15] = 1;
            return this;
        }
        SetCreateTranslationFloats(x, y, z) {
            this.m[0] = 1;
            this.m[1] = 0;
            this.m[2] = 0;
            this.m[3] = 0;
            this.m[4] = 0;
            this.m[5] = 1;
            this.m[6] = 0;
            this.m[7] = 0;
            this.m[8] = 0;
            this.m[9] = 0;
            this.m[10] = 1;
            this.m[11] = 0;
            this.m[12] = x;
            this.m[13] = y;
            this.m[14] = z;
            this.m[15] = 1;
            return this;
        }
        static CreateScaleByFloats(xScale, yScale, zScale, result = null) {
            if (result == null)
                result = new Matrix4();
            var num3 = xScale;
            var num2 = yScale;
            var num = zScale;
            result.m[0] = num3;
            result.m[1] = 0;
            result.m[2] = 0;
            result.m[3] = 0;
            result.m[4] = 0;
            result.m[5] = num2;
            result.m[6] = 0;
            result.m[7] = 0;
            result.m[8] = 0;
            result.m[9] = 0;
            result.m[10] = num;
            result.m[11] = 0;
            result.m[12] = 0;
            result.m[13] = 0;
            result.m[14] = 0;
            result.m[15] = 1;
            return result;
        }
        SetCreateScaleByFloats(xScale, yScale, zScale) {
            var num3 = xScale;
            var num2 = yScale;
            var num = zScale;
            this.m[0] = num3;
            this.m[1] = 0;
            this.m[2] = 0;
            this.m[3] = 0;
            this.m[4] = 0;
            this.m[5] = num2;
            this.m[6] = 0;
            this.m[7] = 0;
            this.m[8] = 0;
            this.m[9] = 0;
            this.m[10] = num;
            this.m[11] = 0;
            this.m[12] = 0;
            this.m[13] = 0;
            this.m[14] = 0;
            this.m[15] = 1;
            return this;
        }
        static CreateScale(scales, reslut = null) {
            return Matrix4.CreateScaleByFloats(scales.X, scales.Y, scales.Z, reslut);
        }
        SetCreateScale(scales) {
            return this.SetCreateScaleByFloats(scales.X, scales.Y, scales.Z);
        }
        static CreateRotationX(radians, result = null) {
            if (result == null)
                result = new Matrix4();
            var num2 = Math.cos(radians);
            var num = Math.sin(radians);
            result.m[0] = 1;
            result.m[1] = 0;
            result.m[2] = 0;
            result.m[3] = 0;
            result.m[4] = 0;
            result.m[5] = num2;
            result.m[6] = num;
            result.m[7] = 0;
            result.m[8] = 0;
            result.m[9] = -num;
            result.m[10] = num2;
            result.m[11] = 0;
            result.m[12] = 0;
            result.m[13] = 0;
            result.m[14] = 0;
            result.m[15] = 1;
            return result;
        }
        SetCreateRotationX(radians) {
            var num2 = Math.cos(radians);
            var num = Math.sin(radians);
            this.m[0] = 1;
            this.m[1] = 0;
            this.m[2] = 0;
            this.m[3] = 0;
            this.m[4] = 0;
            this.m[5] = num2;
            this.m[6] = num;
            this.m[7] = 0;
            this.m[8] = 0;
            this.m[9] = -num;
            this.m[10] = num2;
            this.m[11] = 0;
            this.m[12] = 0;
            this.m[13] = 0;
            this.m[14] = 0;
            this.m[15] = 1;
            return this;
        }
        static CreateRotationY(radians, result = null) {
            if (result == null)
                result = new Matrix4();
            var num2 = Math.cos(radians);
            var num = Math.sin(radians);
            result.m[0] = num2;
            result.m[1] = 0;
            result.m[2] = -num;
            result.m[3] = 0;
            result.m[4] = 0;
            result.m[5] = 1;
            result.m[6] = 0;
            result.m[7] = 0;
            result.m[8] = num;
            result.m[9] = 0;
            result.m[10] = num2;
            result.m[11] = 0;
            result.m[12] = 0;
            result.m[13] = 0;
            result.m[14] = 0;
            result.m[15] = 1;
            return result;
        }
        SetCreateRotationY(radians) {
            var num2 = Math.cos(radians);
            var num = Math.sin(radians);
            this.m[0] = num2;
            this.m[1] = 0;
            this.m[2] = -num;
            this.m[3] = 0;
            this.m[4] = 0;
            this.m[5] = 1;
            this.m[6] = 0;
            this.m[7] = 0;
            this.m[8] = num;
            this.m[9] = 0;
            this.m[10] = num2;
            this.m[11] = 0;
            this.m[12] = 0;
            this.m[13] = 0;
            this.m[14] = 0;
            this.m[15] = 1;
            return this;
        }
        static CreateRotationZ(radians, result = null) {
            if (result == null)
                result = new Matrix4();
            var num2 = Math.cos(radians);
            var num = Math.sin(radians);
            result.m[0] = num2;
            result.m[1] = num;
            result.m[2] = 0;
            result.m[3] = 0;
            result.m[4] = -num;
            result.m[5] = num2;
            result.m[6] = 0;
            result.m[7] = 0;
            result.m[8] = 0;
            result.m[9] = 0;
            result.m[10] = 1;
            result.m[11] = 0;
            result.m[12] = 0;
            result.m[13] = 0;
            result.m[14] = 0;
            result.m[15] = 1;
            return result;
        }
        SetCreateRotationZ(radians) {
            var num2 = Math.cos(radians);
            var num = Math.sin(radians);
            this.m[0] = num2;
            this.m[1] = num;
            this.m[2] = 0;
            this.m[3] = 0;
            this.m[4] = -num;
            this.m[5] = num2;
            this.m[6] = 0;
            this.m[7] = 0;
            this.m[8] = 0;
            this.m[9] = 0;
            this.m[10] = 1;
            this.m[11] = 0;
            this.m[12] = 0;
            this.m[13] = 0;
            this.m[14] = 0;
            this.m[15] = 1;
            return this;
        }
        static CreateFromAxisAngle(axis, angle, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            if (angle == 0)
                return result;
            var x = axis.X;
            var y = axis.Y;
            var z = axis.Z;
            var num2 = Math.sin(angle);
            var num = Math.cos(angle);
            var num11 = x * x;
            var num10 = y * y;
            var num9 = z * z;
            var num8 = x * y;
            var num7 = x * z;
            var num6 = y * z;
            result.m[0] = num11 + (num * (1 - num11));
            result.m[1] = (num8 - (num * num8)) + (num2 * z);
            result.m[2] = (num7 - (num * num7)) - (num2 * y);
            result.m[3] = 0;
            result.m[4] = (num8 - (num * num8)) - (num2 * z);
            result.m[5] = num10 + (num * (1 - num10));
            result.m[6] = (num6 - (num * num6)) + (num2 * x);
            result.m[7] = 0;
            result.m[8] = (num7 - (num * num7)) + (num2 * y);
            result.m[9] = (num6 - (num * num6)) - (num2 * x);
            result.m[10] = num9 + (num * (1 - num9));
            result.m[11] = 0;
            result.m[12] = 0;
            result.m[13] = 0;
            result.m[14] = 0;
            result.m[15] = 1;
            return result;
        }
        SetCreateFromAxisAngle(axis, angle) {
            var x = axis.X;
            var y = axis.Y;
            var z = axis.Z;
            var num2 = Math.sin(angle);
            var num = Math.cos(angle);
            var num11 = x * x;
            var num10 = y * y;
            var num9 = z * z;
            var num8 = x * y;
            var num7 = x * z;
            var num6 = y * z;
            this.m[0] = num11 + (num * (1 - num11));
            this.m[1] = (num8 - (num * num8)) + (num2 * z);
            this.m[2] = (num7 - (num * num7)) - (num2 * y);
            this.m[3] = 0;
            this.m[4] = (num8 - (num * num8)) - (num2 * z);
            this.m[5] = num10 + (num * (1 - num10));
            this.m[6] = (num6 - (num * num6)) + (num2 * x);
            this.m[7] = 0;
            this.m[8] = (num7 - (num * num7)) + (num2 * y);
            this.m[9] = (num6 - (num * num6)) - (num2 * x);
            this.m[10] = num9 + (num * (1 - num9));
            this.m[11] = 0;
            this.m[12] = 0;
            this.m[13] = 0;
            this.m[14] = 0;
            this.m[15] = 1;
            return this;
        }
        static CreatePerspectiveFieldOfView(fieldOfView, aspectRatio, nearPlaneDistance, farPlaneDistance, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            if ((fieldOfView <= 0) || (fieldOfView >= 3.141593)) {
                throw "ArgumentOutOfRangeException( fieldOfView)";
            }
            if (nearPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            if (farPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( farPlaneDistance)";
            }
            if (nearPlaneDistance >= farPlaneDistance) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            var num = 1 / (Math.tan((fieldOfView * 0.5)));
            var num9 = num / aspectRatio;
            result.m[0] = num9;
            result.m[1] = result.m[2] = result.m[3] = 0;
            result.m[5] = num;
            result.m[4] = result.m[6] = result.m[7] = 0;
            result.m[8] = result.m[9] = 0;
            result.m[10] = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
            result.m[11] = -1;
            result.m[12] = result.m[13] = result.m[15] = 0;
            result.m[14] = (nearPlaneDistance * farPlaneDistance) / (nearPlaneDistance - farPlaneDistance);
            return result;
        }
        SetCreatePerspectiveFieldOfView(fieldOfView, aspectRatio, nearPlaneDistance, farPlaneDistance) {
            if ((fieldOfView <= 0) || (fieldOfView >= 3.141593)) {
                throw "ArgumentOutOfRangeException( fieldOfView)";
            }
            if (nearPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            if (farPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( farPlaneDistance)";
            }
            if (nearPlaneDistance >= farPlaneDistance) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            var num = 1 / (Math.tan((fieldOfView * 0.5)));
            var num9 = num / aspectRatio;
            this.m[0] = num9;
            this.m[1] = this.m[2] = this.m[3] = 0;
            this.m[5] = num;
            this.m[4] = this.m[6] = this.m[7] = 0;
            this.m[8] = this.m[9] = 0;
            this.m[10] = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
            this.m[11] = -1;
            this.m[12] = this.m[13] = this.m[15] = 0;
            this.m[14] = (nearPlaneDistance * farPlaneDistance) / (nearPlaneDistance - farPlaneDistance);
            return this;
        }
        static CreatePerspective(width, height, nearPlaneDistance, farPlaneDistance) {
            var matrix = Matrix4.Identity;
            if (nearPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            if (farPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( farPlaneDistance)";
            }
            if (nearPlaneDistance >= farPlaneDistance) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            matrix.m[0] = (2 * nearPlaneDistance) / width;
            matrix.m[1] = matrix.m[2] = matrix.m[3] = 0;
            matrix.m[5] = (2 * nearPlaneDistance) / height;
            matrix.m[4] = matrix.m[6] = matrix.m[7] = 0;
            matrix.m[10] = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
            matrix.m[8] = matrix.m[9] = 0;
            matrix.m[11] = -1;
            matrix.m[12] = matrix.m[13] = matrix.m[15] = 0;
            matrix.m[14] = (nearPlaneDistance * farPlaneDistance) / (nearPlaneDistance - farPlaneDistance);
            return matrix;
        }
        SetCreatePerspective(width, height, nearPlaneDistance, farPlaneDistance) {
            if (nearPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            if (farPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( farPlaneDistance)";
            }
            if (nearPlaneDistance >= farPlaneDistance) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            this.m[0] = (2 * nearPlaneDistance) / width;
            this.m[1] = this.m[2] = this.m[3] = 0;
            this.m[5] = (2 * nearPlaneDistance) / height;
            this.m[4] = this.m[6] = this.m[7] = 0;
            this.m[10] = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
            this.m[8] = this.m[9] = 0;
            this.m[11] = -1;
            this.m[12] = this.m[13] = this.m[15] = 0;
            this.m[14] = (nearPlaneDistance * farPlaneDistance) / (nearPlaneDistance - farPlaneDistance);
            return this;
        }
        static CreatePerspectiveOffCenter(left, right, bottom, top, nearPlaneDistance, farPlaneDistance, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            if (nearPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            if (farPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( farPlaneDistance)";
            }
            if (nearPlaneDistance >= farPlaneDistance) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            result.m[0] = (2 * nearPlaneDistance) / (right - left);
            result.m[1] = result.m[2] = result.m[3] = 0;
            result.m[5] = (2 * nearPlaneDistance) / (top - bottom);
            result.m[4] = result.m[6] = result.m[7] = 0;
            result.m[8] = (left + right) / (right - left);
            result.m[9] = (top + bottom) / (top - bottom);
            result.m[10] = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
            result.m[11] = -1;
            result.m[14] = (nearPlaneDistance * farPlaneDistance) / (nearPlaneDistance - farPlaneDistance);
            result.m[12] = result.m[13] = result.m[15] = 0;
            return result;
        }
        SetCreatePerspectiveOffCenter(left, right, bottom, top, nearPlaneDistance, farPlaneDistance) {
            if (nearPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            if (farPlaneDistance <= 0) {
                throw "ArgumentOutOfRangeException( farPlaneDistance)";
            }
            if (nearPlaneDistance >= farPlaneDistance) {
                throw "ArgumentOutOfRangeException( nearPlaneDistance)";
            }
            this.m[0] = (2 * nearPlaneDistance) / (right - left);
            this.m[1] = this.m[2] = this.m[3] = 0;
            this.m[5] = (2 * nearPlaneDistance) / (top - bottom);
            this.m[4] = this.m[6] = this.m[7] = 0;
            this.m[8] = (left + right) / (right - left);
            this.m[9] = (top + bottom) / (top - bottom);
            this.m[10] = farPlaneDistance / (nearPlaneDistance - farPlaneDistance);
            this.m[11] = -1;
            this.m[14] = (nearPlaneDistance * farPlaneDistance) / (nearPlaneDistance - farPlaneDistance);
            this.m[12] = this.m[13] = this.m[15] = 0;
            return this;
        }
        static CreateOrthographic(width, height, zNearPlane, zFarPlane, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            result.m[0] = 2 / width;
            result.m[1] = result.m[2] = result.m[3] = 0;
            result.m[5] = 2 / height;
            result.m[4] = result.m[6] = result.m[7] = 0;
            result.m[10] = 1 / (zNearPlane - zFarPlane);
            result.m[8] = result.m[9] = result.m[11] = 0;
            result.m[12] = result.m[13] = 0;
            result.m[14] = zNearPlane / (zNearPlane - zFarPlane);
            result.m[15] = 1;
            return result;
        }
        SetCreateOrthographic(width, height, zNearPlane, zFarPlane) {
            this.m[0] = 2 / width;
            this.m[1] = this.m[2] = this.m[3] = 0;
            this.m[5] = 2 / height;
            this.m[4] = this.m[6] = this.m[7] = 0;
            this.m[10] = 1 / (zNearPlane - zFarPlane);
            this.m[8] = this.m[9] = this.m[11] = 0;
            this.m[12] = this.m[13] = 0;
            this.m[14] = zNearPlane / (zNearPlane - zFarPlane);
            this.m[15] = 1;
            return this;
        }
        static CreateOrthographicOffCenter(left, right, bottom, top, zNearPlane, zFarPlane, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            result.m[0] = 2 / (right - left);
            result.m[1] = result.m[2] = result.m[3] = 0;
            result.m[5] = 2 / (top - bottom);
            result.m[4] = result.m[6] = result.m[7] = 0;
            result.m[10] = 1 / (zNearPlane - zFarPlane);
            result.m[8] = result.m[9] = result.m[11] = 0;
            result.m[12] = (left + right) / (left - right);
            result.m[13] = (top + bottom) / (bottom - top);
            result.m[14] = zNearPlane / (zNearPlane - zFarPlane);
            result.m[15] = 1;
            return result;
        }
        SetCreateOrthographicOffCenter(left, right, bottom, top, zNearPlane, zFarPlane) {
            this.SetIdentity();
            this.m[0] = 2 / (right - left);
            this.m[1] = this.m[2] = this.m[3] = 0;
            this.m[5] = 2 / (top - bottom);
            this.m[4] = this.m[6] = this.m[7] = 0;
            this.m[10] = 1 / (zNearPlane - zFarPlane);
            this.m[8] = this.m[9] = this.m[11] = 0;
            this.m[12] = (left + right) / (left - right);
            this.m[13] = (top + bottom) / (bottom - top);
            this.m[14] = zNearPlane / (zNearPlane - zFarPlane);
            this.m[15] = 1;
            return this;
        }
        static CreateLookAt(cameraPosition, cameraTarget, cameraUpVector, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            var zdir = U1.Vector3.Subtract(cameraPosition, cameraTarget).Normalize();
            var xdir = U1.Vector3.Cross(cameraUpVector, zdir).Normalize();
            var ydir = U1.Vector3.Cross(zdir, xdir).Normalize();
            result.m[0] = xdir.X;
            result.m[1] = ydir.X;
            result.m[2] = zdir.X;
            result.m[3] = 0;
            result.m[4] = xdir.Y;
            result.m[5] = ydir.Y;
            result.m[6] = zdir.Y;
            result.m[7] = 0;
            result.m[8] = xdir.Z;
            result.m[9] = ydir.Z;
            result.m[10] = zdir.Z;
            result.m[11] = 0;
            result.m[12] = -U1.Vector3.Dot(xdir, cameraPosition);
            result.m[13] = -U1.Vector3.Dot(ydir, cameraPosition);
            result.m[14] = -U1.Vector3.Dot(zdir, cameraPosition);
            result.m[15] = 1;
            return result;
        }
        SetCreateLookAt(cameraPosition, cameraTarget, cameraUpVector) {
            var zdir = U1.Vector3.Subtract(cameraPosition, cameraTarget).Normalize();
            var xdir = U1.Vector3.Cross(cameraUpVector, zdir).Normalize();
            var ydir = U1.Vector3.Cross(zdir, xdir).Normalize();
            this.m[0] = xdir.X;
            this.m[1] = ydir.X;
            this.m[2] = zdir.X;
            this.m[3] = 0;
            this.m[4] = xdir.Y;
            this.m[5] = ydir.Y;
            this.m[6] = zdir.Y;
            this.m[7] = 0;
            this.m[8] = xdir.Z;
            this.m[9] = ydir.Z;
            this.m[10] = zdir.Z;
            this.m[11] = 0;
            this.m[12] = -U1.Vector3.Dot(xdir, cameraPosition);
            this.m[13] = -U1.Vector3.Dot(ydir, cameraPosition);
            this.m[14] = -U1.Vector3.Dot(zdir, cameraPosition);
            this.m[15] = 1;
            return this;
        }
        static CreateWorld(position, forward, up, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            var xAxis = Matrix4[".v3.1"] || (Matrix4[".v3.1"] = U1.Vector3.Zero);
            var yAxis = Matrix4[".v3.2"] || (Matrix4[".v3.2"] = U1.Vector3.Zero);
            var zAxis = Matrix4[".v3.3"] || (Matrix4[".v3.3"] = U1.Vector3.Zero);
            zAxis = U1.Vector3.Negate(forward, zAxis).Normalize();
            xAxis = U1.Vector3.Cross(up, zAxis, xAxis).Normalize();
            yAxis = U1.Vector3.Cross(zAxis, xAxis, yAxis).Normalize();
            result.m[0] = xAxis.X;
            result.m[1] = xAxis.Y;
            result.m[2] = xAxis.Z;
            result.m[3] = 0;
            result.m[4] = yAxis.X;
            result.m[5] = yAxis.Y;
            result.m[6] = yAxis.Z;
            result.m[7] = 0;
            result.m[8] = zAxis.X;
            result.m[9] = zAxis.Y;
            result.m[10] = zAxis.Z;
            result.m[11] = 0;
            result.m[12] = position.X;
            result.m[13] = position.Y;
            result.m[14] = position.Z;
            result.m[15] = 1;
            return result;
        }
        static CreateWorldFormXY(pos, xdir, ydir, result) {
            var zDir = Matrix4[".v3.1"] || (Matrix4[".v3.1"] = U1.Vector3.Zero);
            zDir.SetCross(xdir, ydir).Normalize();
            if (result == null)
                result = Matrix4.Identity;
            result.SetIdentity();
            result.m[0] = xdir.X;
            result.m[1] = xdir.Y;
            result.m[2] = xdir.Z;
            result.m[4] = ydir.X;
            result.m[5] = ydir.Y;
            result.m[6] = ydir.Z;
            result.m[8] = zDir.X;
            result.m[9] = zDir.Y;
            result.m[10] = zDir.Z;
            result.m[12] = pos.X;
            result.m[13] = pos.Y;
            result.m[14] = pos.Z;
            return result;
        }
        SetCreateWorldFormXY(pos, xdir, ydir) {
            var zDir = Matrix4[".v3.1"] || (Matrix4[".v3.1"] = U1.Vector3.Zero);
            zDir.SetCross(xdir, ydir).Normalize();
            var result = this;
            result.SetIdentity();
            result.m[0] = xdir.X;
            result.m[1] = xdir.Y;
            result.m[2] = xdir.Z;
            result.m[4] = ydir.X;
            result.m[5] = ydir.Y;
            result.m[6] = ydir.Z;
            result.m[8] = zDir.X;
            result.m[9] = zDir.Y;
            result.m[10] = zDir.Z;
            result.m[12] = pos.X;
            result.m[13] = pos.Y;
            result.m[14] = pos.Z;
            return result;
        }
        SetCreateWorld(position, forward, up) {
            var zAxis = U1.Vector3.Negate(forward).Normalize();
            var xAxis = U1.Vector3.Cross(up, zAxis).Normalize();
            var yAxis = U1.Vector3.Cross(zAxis, xAxis).Normalize();
            this.m[0] = xAxis.X;
            this.m[1] = xAxis.Y;
            this.m[2] = xAxis.Z;
            this.m[3] = 0;
            this.m[4] = yAxis.X;
            this.m[5] = yAxis.Y;
            this.m[6] = yAxis.Z;
            this.m[7] = 0;
            this.m[8] = zAxis.X;
            this.m[9] = zAxis.Y;
            this.m[10] = zAxis.Z;
            this.m[11] = 0;
            this.m[12] = position.X;
            this.m[13] = position.Y;
            this.m[14] = position.Z;
            this.m[15] = 1;
            return this;
        }
        static CreateFromQuaternion(quaternion, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            var num9 = quaternion.X * quaternion.X;
            var num8 = quaternion.Y * quaternion.Y;
            var num7 = quaternion.Z * quaternion.Z;
            var num6 = quaternion.X * quaternion.Y;
            var num5 = quaternion.Z * quaternion.W;
            var num4 = quaternion.Z * quaternion.X;
            var num3 = quaternion.Y * quaternion.W;
            var num2 = quaternion.Y * quaternion.Z;
            var num = quaternion.X * quaternion.W;
            result.m[0] = 1 - (2 * (num8 + num7));
            result.m[1] = 2 * (num6 + num5);
            result.m[2] = 2 * (num4 - num3);
            result.m[3] = 0;
            result.m[4] = 2 * (num6 - num5);
            result.m[5] = 1 - (2 * (num7 + num9));
            result.m[6] = 2 * (num2 + num);
            result.m[7] = 0;
            result.m[8] = 2 * (num4 + num3);
            result.m[9] = 2 * (num2 - num);
            result.m[10] = 1 - (2 * (num8 + num9));
            result.m[11] = 0;
            result.m[12] = 0;
            result.m[13] = 0;
            result.m[14] = 0;
            result.m[15] = 1;
            return result;
        }
        SetCreateFromQuaternion(quaternion) {
            var num9 = quaternion.X * quaternion.X;
            var num8 = quaternion.Y * quaternion.Y;
            var num7 = quaternion.Z * quaternion.Z;
            var num6 = quaternion.X * quaternion.Y;
            var num5 = quaternion.Z * quaternion.W;
            var num4 = quaternion.Z * quaternion.X;
            var num3 = quaternion.Y * quaternion.W;
            var num2 = quaternion.Y * quaternion.Z;
            var num = quaternion.X * quaternion.W;
            this.m[0] = 1 - (2 * (num8 + num7));
            this.m[1] = 2 * (num6 + num5);
            this.m[2] = 2 * (num4 - num3);
            this.m[3] = 0;
            this.m[4] = 2 * (num6 - num5);
            this.m[5] = 1 - (2 * (num7 + num9));
            this.m[6] = 2 * (num2 + num);
            this.m[7] = 0;
            this.m[8] = 2 * (num4 + num3);
            this.m[9] = 2 * (num2 - num);
            this.m[10] = 1 - (2 * (num8 + num9));
            this.m[11] = 0;
            this.m[12] = 0;
            this.m[13] = 0;
            this.m[14] = 0;
            this.m[15] = 1;
            return this;
        }
        static CreateFromYawPitchRoll(yaw, pitch, roll, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            var quaternion = Matrix4[".cfypr.q"] || (Matrix4[".cfypr.q"] = new U1.Quaternion());
            quaternion.SetCreateFromYawPitchRoll(yaw, pitch, roll);
            result.SetCreateFromQuaternion(quaternion);
            return result;
        }
        SetCreateFromYawPitchRoll(yaw, pitch, roll) {
            var quaternion = Matrix4[".cfypr.q"] || (Matrix4[".cfypr.q"] = new U1.Quaternion());
            quaternion.SetCreateFromYawPitchRoll(yaw, pitch, roll);
            this.SetCreateFromQuaternion(quaternion);
            return this;
        }
        static CreateShadow(lightDirection, plane, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            var plane2 = plane.Clone().Normalize();
            var num = ((plane2.Normal.X * lightDirection.X) + (plane2.Normal.Y * lightDirection.Y)) + (plane2.Normal.Z * lightDirection.Z);
            var num5 = -plane2.Normal.X;
            var num4 = -plane2.Normal.Y;
            var num3 = -plane2.Normal.Z;
            var num2 = -plane2.D;
            result.m[0] = (num5 * lightDirection.X) + num;
            result.m[4] = num4 * lightDirection.X;
            result.m[8] = num3 * lightDirection.X;
            result.m[12] = num2 * lightDirection.X;
            result.m[1] = num5 * lightDirection.Y;
            result.m[5] = (num4 * lightDirection.Y) + num;
            result.m[9] = num3 * lightDirection.Y;
            result.m[13] = num2 * lightDirection.Y;
            result.m[2] = num5 * lightDirection.Z;
            result.m[6] = num4 * lightDirection.Z;
            result.m[10] = (num3 * lightDirection.Z) + num;
            result.m[14] = num2 * lightDirection.Z;
            result.m[3] = 0;
            result.m[7] = 0;
            result.m[11] = 0;
            result.m[15] = num;
            return result;
        }
        SetCreateShadow(lightDirection, plane) {
            var plane2 = U1.Plane.Normalize(plane);
            var num = ((plane2.Normal.X * lightDirection.X) + (plane2.Normal.Y * lightDirection.Y)) + (plane2.Normal.Z * lightDirection.Z);
            var num5 = -plane2.Normal.X;
            var num4 = -plane2.Normal.Y;
            var num3 = -plane2.Normal.Z;
            var num2 = -plane2.D;
            this.m[0] = (num5 * lightDirection.X) + num;
            this.m[4] = num4 * lightDirection.X;
            this.m[8] = num3 * lightDirection.X;
            this.m[12] = num2 * lightDirection.X;
            this.m[1] = num5 * lightDirection.Y;
            this.m[5] = (num4 * lightDirection.Y) + num;
            this.m[9] = num3 * lightDirection.Y;
            this.m[13] = num2 * lightDirection.Y;
            this.m[2] = num5 * lightDirection.Z;
            this.m[6] = num4 * lightDirection.Z;
            this.m[10] = (num3 * lightDirection.Z) + num;
            this.m[14] = num2 * lightDirection.Z;
            this.m[3] = 0;
            this.m[7] = 0;
            this.m[11] = 0;
            this.m[15] = num;
            return this;
        }
        static CreateReflection(value, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            value = U1.Plane.Normalize(value);
            var x = value.Normal.X;
            var y = value.Normal.Y;
            var z = value.Normal.Z;
            var num3 = -2 * x;
            var num2 = -2 * y;
            var num = -2 * z;
            result.m[0] = (num3 * x) + 1;
            result.m[1] = num2 * x;
            result.m[2] = num * x;
            result.m[3] = 0;
            result.m[4] = num3 * y;
            result.m[5] = (num2 * y) + 1;
            result.m[6] = num * y;
            result.m[7] = 0;
            result.m[8] = num3 * z;
            result.m[9] = num2 * z;
            result.m[10] = (num * z) + 1;
            result.m[11] = 0;
            result.m[12] = num3 * value.D;
            result.m[13] = num2 * value.D;
            result.m[14] = num * value.D;
            result.m[15] = 1;
            return result;
        }
        SetCreateReflection(value) {
            value = U1.Plane.Normalize(value);
            var x = value.Normal.X;
            var y = value.Normal.Y;
            var z = value.Normal.Z;
            var num3 = -2 * x;
            var num2 = -2 * y;
            var num = -2 * z;
            this.m[0] = (num3 * x) + 1;
            this.m[1] = num2 * x;
            this.m[2] = num * x;
            this.m[3] = 0;
            this.m[4] = num3 * y;
            this.m[5] = (num2 * y) + 1;
            this.m[6] = num * y;
            this.m[7] = 0;
            this.m[8] = num3 * z;
            this.m[9] = num2 * z;
            this.m[10] = (num * z) + 1;
            this.m[11] = 0;
            this.m[12] = num3 * value.D;
            this.m[13] = num2 * value.D;
            this.m[14] = num * value.D;
            this.m[15] = 1;
            return this;
        }
        static TransformByQuaternion(value, rotation, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            var num21 = rotation.X + rotation.X;
            var num11 = rotation.Y + rotation.Y;
            var num10 = rotation.Z + rotation.Z;
            var num20 = rotation.W * num21;
            var num19 = rotation.W * num11;
            var num18 = rotation.W * num10;
            var num17 = rotation.X * num21;
            var num16 = rotation.X * num11;
            var num15 = rotation.X * num10;
            var num14 = rotation.Y * num11;
            var num13 = rotation.Y * num10;
            var num12 = rotation.Z * num10;
            var num9 = (1 - num14) - num12;
            var num8 = num16 - num18;
            var num7 = num15 + num19;
            var num6 = num16 + num18;
            var num5 = (1 - num17) - num12;
            var num4 = num13 - num20;
            var num3 = num15 - num19;
            var num2 = num13 + num20;
            var num = (1 - num17) - num14;
            result.m[0] = ((value.m[0] * num9) + (value.m[1] * num8)) + (value.m[2] * num7);
            result.m[1] = ((value.m[0] * num6) + (value.m[1] * num5)) + (value.m[2] * num4);
            result.m[2] = ((value.m[0] * num3) + (value.m[1] * num2)) + (value.m[2] * num);
            result.m[3] = value.m[3];
            result.m[4] = ((value.m[4] * num9) + (value.m[5] * num8)) + (value.m[6] * num7);
            result.m[5] = ((value.m[4] * num6) + (value.m[5] * num5)) + (value.m[6] * num4);
            result.m[6] = ((value.m[4] * num3) + (value.m[5] * num2)) + (value.m[6] * num);
            result.m[7] = value.m[7];
            result.m[8] = ((value.m[8] * num9) + (value.m[9] * num8)) + (value.m[10] * num7);
            result.m[9] = ((value.m[8] * num6) + (value.m[9] * num5)) + (value.m[10] * num4);
            result.m[10] = ((value.m[8] * num3) + (value.m[9] * num2)) + (value.m[10] * num);
            result.m[11] = value.m[11];
            result.m[12] = ((value.m[12] * num9) + (value.m[13] * num8)) + (value.m[14] * num7);
            result.m[13] = ((value.m[12] * num6) + (value.m[13] * num5)) + (value.m[14] * num4);
            result.m[14] = ((value.m[12] * num3) + (value.m[13] * num2)) + (value.m[14] * num);
            result.m[15] = value.m[15];
            return result;
        }
        SetTransformByQuaternion(value, rotation) {
            var num21 = rotation.X + rotation.X;
            var num11 = rotation.Y + rotation.Y;
            var num10 = rotation.Z + rotation.Z;
            var num20 = rotation.W * num21;
            var num19 = rotation.W * num11;
            var num18 = rotation.W * num10;
            var num17 = rotation.X * num21;
            var num16 = rotation.X * num11;
            var num15 = rotation.X * num10;
            var num14 = rotation.Y * num11;
            var num13 = rotation.Y * num10;
            var num12 = rotation.Z * num10;
            var num9 = (1 - num14) - num12;
            var num8 = num16 - num18;
            var num7 = num15 + num19;
            var num6 = num16 + num18;
            var num5 = (1 - num17) - num12;
            var num4 = num13 - num20;
            var num3 = num15 - num19;
            var num2 = num13 + num20;
            var num = (1 - num17) - num14;
            this.m[0] = ((value.m[0] * num9) + (value.m[1] * num8)) + (value.m[2] * num7);
            this.m[1] = ((value.m[0] * num6) + (value.m[1] * num5)) + (value.m[2] * num4);
            this.m[2] = ((value.m[0] * num3) + (value.m[1] * num2)) + (value.m[2] * num);
            this.m[3] = value.m[3];
            this.m[4] = ((value.m[4] * num9) + (value.m[5] * num8)) + (value.m[6] * num7);
            this.m[5] = ((value.m[4] * num6) + (value.m[5] * num5)) + (value.m[6] * num4);
            this.m[6] = ((value.m[4] * num3) + (value.m[5] * num2)) + (value.m[6] * num);
            this.m[7] = value.m[7];
            this.m[8] = ((value.m[8] * num9) + (value.m[9] * num8)) + (value.m[10] * num7);
            this.m[9] = ((value.m[8] * num6) + (value.m[9] * num5)) + (value.m[10] * num4);
            this.m[10] = ((value.m[8] * num3) + (value.m[9] * num2)) + (value.m[10] * num);
            this.m[11] = value.m[11];
            this.m[12] = ((value.m[12] * num9) + (value.m[13] * num8)) + (value.m[14] * num7);
            this.m[13] = ((value.m[12] * num6) + (value.m[13] * num5)) + (value.m[14] * num4);
            this.m[14] = ((value.m[12] * num3) + (value.m[13] * num2)) + (value.m[14] * num);
            this.m[15] = value.m[15];
            return this;
        }
        static Transpose(matrix, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            result.m[0] = matrix.m[0];
            result.m[1] = matrix.m[4];
            result.m[2] = matrix.m[8];
            result.m[3] = matrix.m[12];
            result.m[4] = matrix.m[1];
            result.m[5] = matrix.m[5];
            result.m[6] = matrix.m[9];
            result.m[7] = matrix.m[13];
            result.m[8] = matrix.m[2];
            result.m[9] = matrix.m[6];
            result.m[10] = matrix.m[10];
            result.m[11] = matrix.m[14];
            result.m[12] = matrix.m[3];
            result.m[13] = matrix.m[7];
            result.m[14] = matrix.m[11];
            result.m[15] = matrix.m[15];
            return result;
        }
        SetTranspose(matrix) {
            var m11 = matrix.m[0];
            var m12 = matrix.m[4];
            var m13 = matrix.m[8];
            var m14 = matrix.m[12];
            var m21 = matrix.m[1];
            var m22 = matrix.m[5];
            var m23 = matrix.m[9];
            var m24 = matrix.m[13];
            var m31 = matrix.m[2];
            var m32 = matrix.m[6];
            var m33 = matrix.m[10];
            var m34 = matrix.m[14];
            var m41 = matrix.m[3];
            var m42 = matrix.m[7];
            var m43 = matrix.m[11];
            var m44 = matrix.m[15];
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m13;
            this.m[3] = m14;
            this.m[4] = m21;
            this.m[5] = m22;
            this.m[6] = m23;
            this.m[7] = m24;
            this.m[8] = m31;
            this.m[9] = m32;
            this.m[10] = m33;
            this.m[11] = m34;
            this.m[12] = m41;
            this.m[13] = m42;
            this.m[14] = m43;
            this.m[15] = m44;
            return this;
        }
        Determinant() {
            var num22 = this.m[0];
            var num21 = this.m[1];
            var num20 = this.m[2];
            var num19 = this.m[3];
            var num12 = this.m[4];
            var num11 = this.m[5];
            var num10 = this.m[6];
            var num9 = this.m[7];
            var num8 = this.m[8];
            var num7 = this.m[9];
            var num6 = this.m[10];
            var num5 = this.m[11];
            var num4 = this.m[12];
            var num3 = this.m[13];
            var num2 = this.m[14];
            var num = this.m[15];
            var num18 = (num6 * num) - (num5 * num2);
            var num17 = (num7 * num) - (num5 * num3);
            var num16 = (num7 * num2) - (num6 * num3);
            var num15 = (num8 * num) - (num5 * num4);
            var num14 = (num8 * num2) - (num6 * num4);
            var num13 = (num8 * num3) - (num7 * num4);
            return ((((num22 * (((num11 * num18) - (num10 * num17)) + (num9 * num16))) - (num21 * (((num12 * num18) - (num10 * num15)) + (num9 * num14)))) + (num20 * (((num12 * num17) - (num11 * num15)) + (num9 * num13)))) - (num19 * (((num12 * num16) - (num11 * num14)) + (num10 * num13))));
        }
        static Invert(matrix, result) {
            if (result == null)
                result = Matrix4.Identity;
            return result.CopyFrom(matrix).Invert();
        }
        SetInvert(source) {
            var num5 = source.m[0];
            var num4 = source.m[1];
            var num3 = source.m[2];
            var num2 = source.m[3];
            var num9 = source.m[4];
            var num8 = source.m[5];
            var num7 = source.m[6];
            var num6 = source.m[7];
            var num17 = source.m[8];
            var num16 = source.m[9];
            var num15 = source.m[10];
            var num14 = source.m[11];
            var num13 = source.m[12];
            var num12 = source.m[13];
            var num11 = source.m[14];
            var num10 = source.m[15];
            var num23 = (num15 * num10) - (num14 * num11);
            var num22 = (num16 * num10) - (num14 * num12);
            var num21 = (num16 * num11) - (num15 * num12);
            var num20 = (num17 * num10) - (num14 * num13);
            var num19 = (num17 * num11) - (num15 * num13);
            var num18 = (num17 * num12) - (num16 * num13);
            var num39 = ((num8 * num23) - (num7 * num22)) + (num6 * num21);
            var num38 = -(((num9 * num23) - (num7 * num20)) + (num6 * num19));
            var num37 = ((num9 * num22) - (num8 * num20)) + (num6 * num18);
            var num36 = -(((num9 * num21) - (num8 * num19)) + (num7 * num18));
            var num = 1 / ((((num5 * num39) + (num4 * num38)) + (num3 * num37)) + (num2 * num36));
            this.m[0] = num39 * num;
            this.m[4] = num38 * num;
            this.m[8] = num37 * num;
            this.m[12] = num36 * num;
            this.m[1] = -(((num4 * num23) - (num3 * num22)) + (num2 * num21)) * num;
            this.m[5] = (((num5 * num23) - (num3 * num20)) + (num2 * num19)) * num;
            this.m[9] = -(((num5 * num22) - (num4 * num20)) + (num2 * num18)) * num;
            this.m[13] = (((num5 * num21) - (num4 * num19)) + (num3 * num18)) * num;
            var num35 = (num7 * num10) - (num6 * num11);
            var num34 = (num8 * num10) - (num6 * num12);
            var num33 = (num8 * num11) - (num7 * num12);
            var num32 = (num9 * num10) - (num6 * num13);
            var num31 = (num9 * num11) - (num7 * num13);
            var num30 = (num9 * num12) - (num8 * num13);
            this.m[2] = (((num4 * num35) - (num3 * num34)) + (num2 * num33)) * num;
            this.m[6] = -(((num5 * num35) - (num3 * num32)) + (num2 * num31)) * num;
            this.m[10] = (((num5 * num34) - (num4 * num32)) + (num2 * num30)) * num;
            this.m[14] = -(((num5 * num33) - (num4 * num31)) + (num3 * num30)) * num;
            var num29 = (num7 * num14) - (num6 * num15);
            var num28 = (num8 * num14) - (num6 * num16);
            var num27 = (num8 * num15) - (num7 * num16);
            var num26 = (num9 * num14) - (num6 * num17);
            var num25 = (num9 * num15) - (num7 * num17);
            var num24 = (num9 * num16) - (num8 * num17);
            this.m[3] = -(((num4 * num29) - (num3 * num28)) + (num2 * num27)) * num;
            this.m[7] = (((num5 * num29) - (num3 * num26)) + (num2 * num25)) * num;
            this.m[11] = -(((num5 * num28) - (num4 * num26)) + (num2 * num24)) * num;
            this.m[15] = (((num5 * num27) - (num4 * num25)) + (num3 * num24)) * num;
            return this;
        }
        Invert() {
            this.SetInvert(this);
            return this;
        }
        static Lerp(matrix1, matrix2, amount, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            result.m[0] = matrix1.m[0] + ((matrix2.m[0] - matrix1.m[0]) * amount);
            result.m[1] = matrix1.m[1] + ((matrix2.m[1] - matrix1.m[1]) * amount);
            result.m[2] = matrix1.m[2] + ((matrix2.m[2] - matrix1.m[2]) * amount);
            result.m[3] = matrix1.m[3] + ((matrix2.m[3] - matrix1.m[3]) * amount);
            result.m[4] = matrix1.m[4] + ((matrix2.m[4] - matrix1.m[4]) * amount);
            result.m[5] = matrix1.m[5] + ((matrix2.m[5] - matrix1.m[5]) * amount);
            result.m[6] = matrix1.m[6] + ((matrix2.m[6] - matrix1.m[6]) * amount);
            result.m[7] = matrix1.m[7] + ((matrix2.m[7] - matrix1.m[7]) * amount);
            result.m[8] = matrix1.m[8] + ((matrix2.m[8] - matrix1.m[8]) * amount);
            result.m[9] = matrix1.m[9] + ((matrix2.m[9] - matrix1.m[9]) * amount);
            result.m[10] = matrix1.m[10] + ((matrix2.m[10] - matrix1.m[10]) * amount);
            result.m[11] = matrix1.m[11] + ((matrix2.m[11] - matrix1.m[11]) * amount);
            result.m[12] = matrix1.m[12] + ((matrix2.m[12] - matrix1.m[12]) * amount);
            result.m[13] = matrix1.m[13] + ((matrix2.m[13] - matrix1.m[13]) * amount);
            result.m[14] = matrix1.m[14] + ((matrix2.m[14] - matrix1.m[14]) * amount);
            result.m[15] = matrix1.m[15] + ((matrix2.m[15] - matrix1.m[15]) * amount);
            return result;
        }
        SetLerp(matrix1, matrix2, amount) {
            this.m[0] = matrix1.m[0] + ((matrix2.m[0] - matrix1.m[0]) * amount);
            this.m[1] = matrix1.m[1] + ((matrix2.m[1] - matrix1.m[1]) * amount);
            this.m[2] = matrix1.m[2] + ((matrix2.m[2] - matrix1.m[2]) * amount);
            this.m[3] = matrix1.m[3] + ((matrix2.m[3] - matrix1.m[3]) * amount);
            this.m[4] = matrix1.m[4] + ((matrix2.m[4] - matrix1.m[4]) * amount);
            this.m[5] = matrix1.m[5] + ((matrix2.m[5] - matrix1.m[5]) * amount);
            this.m[6] = matrix1.m[6] + ((matrix2.m[6] - matrix1.m[6]) * amount);
            this.m[7] = matrix1.m[7] + ((matrix2.m[7] - matrix1.m[7]) * amount);
            this.m[8] = matrix1.m[8] + ((matrix2.m[8] - matrix1.m[8]) * amount);
            this.m[9] = matrix1.m[9] + ((matrix2.m[9] - matrix1.m[9]) * amount);
            this.m[10] = matrix1.m[10] + ((matrix2.m[10] - matrix1.m[10]) * amount);
            this.m[11] = matrix1.m[11] + ((matrix2.m[11] - matrix1.m[11]) * amount);
            this.m[12] = matrix1.m[12] + ((matrix2.m[12] - matrix1.m[12]) * amount);
            this.m[13] = matrix1.m[13] + ((matrix2.m[13] - matrix1.m[13]) * amount);
            this.m[14] = matrix1.m[14] + ((matrix2.m[14] - matrix1.m[14]) * amount);
            this.m[15] = matrix1.m[15] + ((matrix2.m[15] - matrix1.m[15]) * amount);
            return this;
        }
        static Negate(matrix, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            result.m[0] = -matrix.m[0];
            result.m[1] = -matrix.m[1];
            result.m[2] = -matrix.m[2];
            result.m[3] = -matrix.m[3];
            result.m[4] = -matrix.m[4];
            result.m[5] = -matrix.m[5];
            result.m[6] = -matrix.m[6];
            result.m[7] = -matrix.m[7];
            result.m[8] = -matrix.m[8];
            result.m[9] = -matrix.m[9];
            result.m[10] = -matrix.m[10];
            result.m[11] = -matrix.m[11];
            result.m[12] = -matrix.m[12];
            result.m[13] = -matrix.m[13];
            result.m[14] = -matrix.m[14];
            result.m[15] = -matrix.m[15];
            return result;
        }
        SetNegate(matrix) {
            this.m[0] = -matrix.m[0];
            this.m[1] = -matrix.m[1];
            this.m[2] = -matrix.m[2];
            this.m[3] = -matrix.m[3];
            this.m[4] = -matrix.m[4];
            this.m[5] = -matrix.m[5];
            this.m[6] = -matrix.m[6];
            this.m[7] = -matrix.m[7];
            this.m[8] = -matrix.m[8];
            this.m[9] = -matrix.m[9];
            this.m[10] = -matrix.m[10];
            this.m[11] = -matrix.m[11];
            this.m[12] = -matrix.m[12];
            this.m[13] = -matrix.m[13];
            this.m[14] = -matrix.m[14];
            this.m[15] = -matrix.m[15];
            return this;
        }
        Negate(matrix) {
            return this.SetNegate(this);
        }
        static Add(matrix1, matrix2, result = null) {
            if (result == null)
                result = Matrix4.Identity;
            result.m[0] = matrix1.m[0] + matrix2.m[0];
            result.m[1] = matrix1.m[1] + matrix2.m[1];
            result.m[2] = matrix1.m[2] + matrix2.m[2];
            result.m[3] = matrix1.m[3] + matrix2.m[3];
            result.m[4] = matrix1.m[4] + matrix2.m[4];
            result.m[5] = matrix1.m[5] + matrix2.m[5];
            result.m[6] = matrix1.m[6] + matrix2.m[6];
            result.m[7] = matrix1.m[7] + matrix2.m[7];
            result.m[8] = matrix1.m[8] + matrix2.m[8];
            result.m[9] = matrix1.m[9] + matrix2.m[9];
            result.m[10] = matrix1.m[10] + matrix2.m[10];
            result.m[11] = matrix1.m[11] + matrix2.m[11];
            result.m[12] = matrix1.m[12] + matrix2.m[12];
            result.m[13] = matrix1.m[13] + matrix2.m[13];
            result.m[14] = matrix1.m[14] + matrix2.m[14];
            result.m[15] = matrix1.m[15] + matrix2.m[15];
            return result;
        }
        SetAdd(matrix1, matrix2) {
            this.m[0] = matrix1.m[0] + matrix2.m[0];
            this.m[1] = matrix1.m[1] + matrix2.m[1];
            this.m[2] = matrix1.m[2] + matrix2.m[2];
            this.m[3] = matrix1.m[3] + matrix2.m[3];
            this.m[4] = matrix1.m[4] + matrix2.m[4];
            this.m[5] = matrix1.m[5] + matrix2.m[5];
            this.m[6] = matrix1.m[6] + matrix2.m[6];
            this.m[7] = matrix1.m[7] + matrix2.m[7];
            this.m[8] = matrix1.m[8] + matrix2.m[8];
            this.m[9] = matrix1.m[9] + matrix2.m[9];
            this.m[10] = matrix1.m[10] + matrix2.m[10];
            this.m[11] = matrix1.m[11] + matrix2.m[11];
            this.m[12] = matrix1.m[12] + matrix2.m[12];
            this.m[13] = matrix1.m[13] + matrix2.m[13];
            this.m[14] = matrix1.m[14] + matrix2.m[14];
            this.m[15] = matrix1.m[15] + matrix2.m[15];
            return this;
        }
        Add(matrix2) {
            return this.SetAdd(this, matrix2);
        }
        static Subtract(matrix1, matrix2, result = null) {
            if (result == null)
                result = new Matrix4();
            result.m[0] = matrix1.m[0] - matrix2.m[0];
            result.m[1] = matrix1.m[1] - matrix2.m[1];
            result.m[2] = matrix1.m[2] - matrix2.m[2];
            result.m[3] = matrix1.m[3] - matrix2.m[3];
            result.m[4] = matrix1.m[4] - matrix2.m[4];
            result.m[5] = matrix1.m[5] - matrix2.m[5];
            result.m[6] = matrix1.m[6] - matrix2.m[6];
            result.m[7] = matrix1.m[7] - matrix2.m[7];
            result.m[8] = matrix1.m[8] - matrix2.m[8];
            result.m[9] = matrix1.m[9] - matrix2.m[9];
            result.m[10] = matrix1.m[10] - matrix2.m[10];
            result.m[11] = matrix1.m[11] - matrix2.m[11];
            result.m[12] = matrix1.m[12] - matrix2.m[12];
            result.m[13] = matrix1.m[13] - matrix2.m[13];
            result.m[14] = matrix1.m[14] - matrix2.m[14];
            result.m[15] = matrix1.m[15] - matrix2.m[15];
            return result;
        }
        SetSubtract(matrix1, matrix2) {
            this.m[0] = matrix1.m[0] - matrix2.m[0];
            this.m[1] = matrix1.m[1] - matrix2.m[1];
            this.m[2] = matrix1.m[2] - matrix2.m[2];
            this.m[3] = matrix1.m[3] - matrix2.m[3];
            this.m[4] = matrix1.m[4] - matrix2.m[4];
            this.m[5] = matrix1.m[5] - matrix2.m[5];
            this.m[6] = matrix1.m[6] - matrix2.m[6];
            this.m[7] = matrix1.m[7] - matrix2.m[7];
            this.m[8] = matrix1.m[8] - matrix2.m[8];
            this.m[9] = matrix1.m[9] - matrix2.m[9];
            this.m[10] = matrix1.m[10] - matrix2.m[10];
            this.m[11] = matrix1.m[11] - matrix2.m[11];
            this.m[12] = matrix1.m[12] - matrix2.m[12];
            this.m[13] = matrix1.m[13] - matrix2.m[13];
            this.m[14] = matrix1.m[14] - matrix2.m[14];
            this.m[15] = matrix1.m[15] - matrix2.m[15];
            return this;
        }
        Subtract(matrix2) {
            return this.SetSubtract(this, matrix2);
        }
        static Multiply(matrix1, matrix2, result) {
            if (result == null)
                result = new Matrix4();
            if (matrix1 == null && matrix2 == null) {
                result.SetIdentity();
                return result;
            }
            if (matrix1 == null) {
                result.CopyFrom(matrix2);
                return result;
            }
            if (matrix2 == null) {
                result.CopyFrom(matrix1);
                return result;
            }
            result.m[0] = (((matrix1.m[0] * matrix2.m[0]) + (matrix1.m[1] * matrix2.m[4])) + (matrix1.m[2] * matrix2.m[8])) + (matrix1.m[3] * matrix2.m[12]);
            result.m[1] = (((matrix1.m[0] * matrix2.m[1]) + (matrix1.m[1] * matrix2.m[5])) + (matrix1.m[2] * matrix2.m[9])) + (matrix1.m[3] * matrix2.m[13]);
            result.m[2] = (((matrix1.m[0] * matrix2.m[2]) + (matrix1.m[1] * matrix2.m[6])) + (matrix1.m[2] * matrix2.m[10])) + (matrix1.m[3] * matrix2.m[14]);
            result.m[3] = (((matrix1.m[0] * matrix2.m[3]) + (matrix1.m[1] * matrix2.m[7])) + (matrix1.m[2] * matrix2.m[11])) + (matrix1.m[3] * matrix2.m[15]);
            result.m[4] = (((matrix1.m[4] * matrix2.m[0]) + (matrix1.m[5] * matrix2.m[4])) + (matrix1.m[6] * matrix2.m[8])) + (matrix1.m[7] * matrix2.m[12]);
            result.m[5] = (((matrix1.m[4] * matrix2.m[1]) + (matrix1.m[5] * matrix2.m[5])) + (matrix1.m[6] * matrix2.m[9])) + (matrix1.m[7] * matrix2.m[13]);
            result.m[6] = (((matrix1.m[4] * matrix2.m[2]) + (matrix1.m[5] * matrix2.m[6])) + (matrix1.m[6] * matrix2.m[10])) + (matrix1.m[7] * matrix2.m[14]);
            result.m[7] = (((matrix1.m[4] * matrix2.m[3]) + (matrix1.m[5] * matrix2.m[7])) + (matrix1.m[6] * matrix2.m[11])) + (matrix1.m[7] * matrix2.m[15]);
            result.m[8] = (((matrix1.m[8] * matrix2.m[0]) + (matrix1.m[9] * matrix2.m[4])) + (matrix1.m[10] * matrix2.m[8])) + (matrix1.m[11] * matrix2.m[12]);
            result.m[9] = (((matrix1.m[8] * matrix2.m[1]) + (matrix1.m[9] * matrix2.m[5])) + (matrix1.m[10] * matrix2.m[9])) + (matrix1.m[11] * matrix2.m[13]);
            result.m[10] = (((matrix1.m[8] * matrix2.m[2]) + (matrix1.m[9] * matrix2.m[6])) + (matrix1.m[10] * matrix2.m[10])) + (matrix1.m[11] * matrix2.m[14]);
            result.m[11] = (((matrix1.m[8] * matrix2.m[3]) + (matrix1.m[9] * matrix2.m[7])) + (matrix1.m[10] * matrix2.m[11])) + (matrix1.m[11] * matrix2.m[15]);
            result.m[12] = (((matrix1.m[12] * matrix2.m[0]) + (matrix1.m[13] * matrix2.m[4])) + (matrix1.m[14] * matrix2.m[8])) + (matrix1.m[15] * matrix2.m[12]);
            result.m[13] = (((matrix1.m[12] * matrix2.m[1]) + (matrix1.m[13] * matrix2.m[5])) + (matrix1.m[14] * matrix2.m[9])) + (matrix1.m[15] * matrix2.m[13]);
            result.m[14] = (((matrix1.m[12] * matrix2.m[2]) + (matrix1.m[13] * matrix2.m[6])) + (matrix1.m[14] * matrix2.m[10])) + (matrix1.m[15] * matrix2.m[14]);
            result.m[15] = (((matrix1.m[12] * matrix2.m[3]) + (matrix1.m[13] * matrix2.m[7])) + (matrix1.m[14] * matrix2.m[11])) + (matrix1.m[15] * matrix2.m[15]);
            return result;
        }
        SetMultiply(m1, m2) {
            if (m1 == null && m2 == null) {
                this.SetIdentity();
                return this;
            }
            if (m1 == null) {
                this.CopyFrom(m2);
                return this;
            }
            if (m2 == null) {
                this.CopyFrom(m1);
                return this;
            }
            var m11 = (((m1.m[0] * m2.m[0]) + (m1.m[1] * m2.m[4])) + (m1.m[2] * m2.m[8])) + (m1.m[3] * m2.m[12]);
            var m12 = (((m1.m[0] * m2.m[1]) + (m1.m[1] * m2.m[5])) + (m1.m[2] * m2.m[9])) + (m1.m[3] * m2.m[13]);
            var m13 = (((m1.m[0] * m2.m[2]) + (m1.m[1] * m2.m[6])) + (m1.m[2] * m2.m[10])) + (m1.m[3] * m2.m[14]);
            var m14 = (((m1.m[0] * m2.m[3]) + (m1.m[1] * m2.m[7])) + (m1.m[2] * m2.m[11])) + (m1.m[3] * m2.m[15]);
            var m21 = (((m1.m[4] * m2.m[0]) + (m1.m[5] * m2.m[4])) + (m1.m[6] * m2.m[8])) + (m1.m[7] * m2.m[12]);
            var m22 = (((m1.m[4] * m2.m[1]) + (m1.m[5] * m2.m[5])) + (m1.m[6] * m2.m[9])) + (m1.m[7] * m2.m[13]);
            var m23 = (((m1.m[4] * m2.m[2]) + (m1.m[5] * m2.m[6])) + (m1.m[6] * m2.m[10])) + (m1.m[7] * m2.m[14]);
            var m24 = (((m1.m[4] * m2.m[3]) + (m1.m[5] * m2.m[7])) + (m1.m[6] * m2.m[11])) + (m1.m[7] * m2.m[15]);
            var m31 = (((m1.m[8] * m2.m[0]) + (m1.m[9] * m2.m[4])) + (m1.m[10] * m2.m[8])) + (m1.m[11] * m2.m[12]);
            var m32 = (((m1.m[8] * m2.m[1]) + (m1.m[9] * m2.m[5])) + (m1.m[10] * m2.m[9])) + (m1.m[11] * m2.m[13]);
            var m33 = (((m1.m[8] * m2.m[2]) + (m1.m[9] * m2.m[6])) + (m1.m[10] * m2.m[10])) + (m1.m[11] * m2.m[14]);
            var m34 = (((m1.m[8] * m2.m[3]) + (m1.m[9] * m2.m[7])) + (m1.m[10] * m2.m[11])) + (m1.m[11] * m2.m[15]);
            var m41 = (((m1.m[12] * m2.m[0]) + (m1.m[13] * m2.m[4])) + (m1.m[14] * m2.m[8])) + (m1.m[15] * m2.m[12]);
            var m42 = (((m1.m[12] * m2.m[1]) + (m1.m[13] * m2.m[5])) + (m1.m[14] * m2.m[9])) + (m1.m[15] * m2.m[13]);
            var m43 = (((m1.m[12] * m2.m[2]) + (m1.m[13] * m2.m[6])) + (m1.m[14] * m2.m[10])) + (m1.m[15] * m2.m[14]);
            var m44 = (((m1.m[12] * m2.m[3]) + (m1.m[13] * m2.m[7])) + (m1.m[14] * m2.m[11])) + (m1.m[15] * m2.m[15]);
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m13;
            this.m[3] = m14;
            this.m[4] = m21;
            this.m[5] = m22;
            this.m[6] = m23;
            this.m[7] = m24;
            this.m[8] = m31;
            this.m[9] = m32;
            this.m[10] = m33;
            this.m[11] = m34;
            this.m[12] = m41;
            this.m[13] = m42;
            this.m[14] = m43;
            this.m[15] = m44;
            return this;
        }
        Multiply(matrix2) {
            if (matrix2 == null)
                return this;
            return this.SetMultiply(this, matrix2);
        }
        static Scale(matrix1, scaleFactor, result = null) {
            if (result == null)
                result = new Matrix4();
            var num = scaleFactor;
            result.m[0] = matrix1.m[0] * num;
            result.m[1] = matrix1.m[1] * num;
            result.m[2] = matrix1.m[2] * num;
            result.m[3] = matrix1.m[3] * num;
            result.m[4] = matrix1.m[4] * num;
            result.m[5] = matrix1.m[5] * num;
            result.m[6] = matrix1.m[6] * num;
            result.m[7] = matrix1.m[7] * num;
            result.m[8] = matrix1.m[8] * num;
            result.m[9] = matrix1.m[9] * num;
            result.m[10] = matrix1.m[10] * num;
            result.m[11] = matrix1.m[11] * num;
            result.m[12] = matrix1.m[12] * num;
            result.m[13] = matrix1.m[13] * num;
            result.m[14] = matrix1.m[14] * num;
            result.m[15] = matrix1.m[15] * num;
            return result;
        }
        SetScale(matrix1, scaleFactor) {
            var num = scaleFactor;
            this.m[0] = matrix1.m[0] * num;
            this.m[1] = matrix1.m[1] * num;
            this.m[2] = matrix1.m[2] * num;
            this.m[3] = matrix1.m[3] * num;
            this.m[4] = matrix1.m[4] * num;
            this.m[5] = matrix1.m[5] * num;
            this.m[6] = matrix1.m[6] * num;
            this.m[7] = matrix1.m[7] * num;
            this.m[8] = matrix1.m[8] * num;
            this.m[9] = matrix1.m[9] * num;
            this.m[10] = matrix1.m[10] * num;
            this.m[11] = matrix1.m[11] * num;
            this.m[12] = matrix1.m[12] * num;
            this.m[13] = matrix1.m[13] * num;
            this.m[14] = matrix1.m[14] * num;
            this.m[15] = matrix1.m[15] * num;
            return this;
        }
        Scale(scaleFactor) {
            return this.SetScale(this, scaleFactor);
        }
        static Divide(matrix1, matrix2, result = null) {
            if (result == null)
                result = new Matrix4();
            result.m[0] = matrix1.m[0] / matrix2.m[0];
            result.m[1] = matrix1.m[1] / matrix2.m[1];
            result.m[2] = matrix1.m[2] / matrix2.m[2];
            result.m[3] = matrix1.m[3] / matrix2.m[3];
            result.m[4] = matrix1.m[4] / matrix2.m[4];
            result.m[5] = matrix1.m[5] / matrix2.m[5];
            result.m[6] = matrix1.m[6] / matrix2.m[6];
            result.m[7] = matrix1.m[7] / matrix2.m[7];
            result.m[8] = matrix1.m[8] / matrix2.m[8];
            result.m[9] = matrix1.m[9] / matrix2.m[9];
            result.m[10] = matrix1.m[10] / matrix2.m[10];
            result.m[11] = matrix1.m[11] / matrix2.m[11];
            result.m[12] = matrix1.m[12] / matrix2.m[12];
            result.m[13] = matrix1.m[13] / matrix2.m[13];
            result.m[14] = matrix1.m[14] / matrix2.m[14];
            result.m[15] = matrix1.m[15] / matrix2.m[15];
            return result;
        }
        SetDivide(matrix1, matrix2) {
            this.m[0] = matrix1.m[0] / matrix2.m[0];
            this.m[1] = matrix1.m[1] / matrix2.m[1];
            this.m[2] = matrix1.m[2] / matrix2.m[2];
            this.m[3] = matrix1.m[3] / matrix2.m[3];
            this.m[4] = matrix1.m[4] / matrix2.m[4];
            this.m[5] = matrix1.m[5] / matrix2.m[5];
            this.m[6] = matrix1.m[6] / matrix2.m[6];
            this.m[7] = matrix1.m[7] / matrix2.m[7];
            this.m[8] = matrix1.m[8] / matrix2.m[8];
            this.m[9] = matrix1.m[9] / matrix2.m[9];
            this.m[10] = matrix1.m[10] / matrix2.m[10];
            this.m[11] = matrix1.m[11] / matrix2.m[11];
            this.m[12] = matrix1.m[12] / matrix2.m[12];
            this.m[13] = matrix1.m[13] / matrix2.m[13];
            this.m[14] = matrix1.m[14] / matrix2.m[14];
            this.m[15] = matrix1.m[15] / matrix2.m[15];
            return this;
        }
        Divide(matrix2) {
            return this.SetDivide(this, matrix2);
        }
        static DivideFloat(matrix1, divider, result = null) {
            if (result == null)
                result = new Matrix4();
            var num = 1 / divider;
            result.m[0] = matrix1.m[0] * num;
            result.m[1] = matrix1.m[1] * num;
            result.m[2] = matrix1.m[2] * num;
            result.m[3] = matrix1.m[3] * num;
            result.m[4] = matrix1.m[4] * num;
            result.m[5] = matrix1.m[5] * num;
            result.m[6] = matrix1.m[6] * num;
            result.m[7] = matrix1.m[7] * num;
            result.m[8] = matrix1.m[8] * num;
            result.m[9] = matrix1.m[9] * num;
            result.m[10] = matrix1.m[10] * num;
            result.m[11] = matrix1.m[11] * num;
            result.m[12] = matrix1.m[12] * num;
            result.m[13] = matrix1.m[13] * num;
            result.m[14] = matrix1.m[14] * num;
            result.m[15] = matrix1.m[15] * num;
            return result;
        }
        SetDivideFloat(matrix1, divider) {
            var num = 1 / divider;
            this.m[0] = matrix1.m[0] * num;
            this.m[1] = matrix1.m[1] * num;
            this.m[2] = matrix1.m[2] * num;
            this.m[3] = matrix1.m[3] * num;
            this.m[4] = matrix1.m[4] * num;
            this.m[5] = matrix1.m[5] * num;
            this.m[6] = matrix1.m[6] * num;
            this.m[7] = matrix1.m[7] * num;
            this.m[8] = matrix1.m[8] * num;
            this.m[9] = matrix1.m[9] * num;
            this.m[10] = matrix1.m[10] * num;
            this.m[11] = matrix1.m[11] * num;
            this.m[12] = matrix1.m[12] * num;
            this.m[13] = matrix1.m[13] * num;
            this.m[14] = matrix1.m[14] * num;
            this.m[15] = matrix1.m[15] * num;
            return this;
        }
        get M1() {
            return new U1.Vector4(this.m[0], this.m[1], this.m[2], this.m[3]);
        }
        set M1(value) {
            this.m[0] = value.X;
            this.m[1] = value.Y;
            this.m[2] = value.Z;
            this.m[3] = value.W;
        }
        GetM1(result = null) {
            if (result == null)
                result = new U1.Vector4();
            result.Set(this.m[0], this.m[1], this.m[2], this.m[3]);
            return result;
        }
        get M2() {
            return new U1.Vector4(this.m[4], this.m[5], this.m[6], this.m[7]);
        }
        set M2(value) {
            this.m[4] = value.X;
            this.m[5] = value.Y;
            this.m[6] = value.Z;
            this.m[7] = value.W;
        }
        GetM2(result = null) {
            if (result == null)
                result = new U1.Vector4();
            result.Set(this.m[4], this.m[5], this.m[6], this.m[7]);
            return result;
        }
        get M3() {
            return new U1.Vector4(this.m[8], this.m[9], this.m[10], this.m[11]);
        }
        set M3(value) {
            this.m[8] = value.X;
            this.m[9] = value.Y;
            this.m[10] = value.Z;
            this.m[11] = value.W;
        }
        GetM3(result = null) {
            if (result == null)
                result = new U1.Vector4();
            result.Set(this.m[8], this.m[9], this.m[10], this.m[11]);
            return result;
        }
        get M4() {
            return new U1.Vector4(this.m[12], this.m[13], this.m[14], this.m[15]);
        }
        set M4(value) {
            this.m[12] = value.X;
            this.m[13] = value.Y;
            this.m[14] = value.Z;
            this.m[15] = value.W;
        }
        GetM4(result = null) {
            if (result == null)
                result = new U1.Vector4();
            result.Set(this.m[12], this.m[13], this.m[14], this.m[15]);
            return result;
        }
        ToSRT(Scale, AxisAngle, Loc) {
            var xform = this;
            var s_ = Matrix4[".mts"] || (Matrix4[".mts"] = {});
            var zero = s_.zero || (s_.zero = U1.Vector3.Zero);
            var unitx = s_.ux || (s_.ux = U1.Vector3.UnitX);
            var unity = s_.uy || (s_.uy = U1.Vector3.UnitY);
            var unitz = s_.uz || (s_.uz = U1.Vector3.UnitZ);
            var ux2 = s_.ux2 || (s_.ux2 = U1.Vector2.UnitX);
            var xy = s_.xy || (s_.xy = U1.Vector2.UnitX);
            var xdir = s_.v1 || (s_.v1 = new U1.Vector3());
            var ydir = s_.v2 || (s_.v2 = new U1.Vector3());
            var zdir = s_.v3 || (s_.v3 = new U1.Vector3());
            var res = s_.res || (s_.res = new U1.Vector4());
            xform.GetTranslation(Loc);
            xdir.SetUnitX();
            ydir.SetUnitY();
            zdir.SetUnitZ();
            xdir.TransformNormal(xform);
            ydir.TransformNormal(xform);
            zdir.TransformNormal(xform);
            Scale.Set(xdir.Length(), ydir.Length(), zdir.Length());
            xform.Determinant();
            if (U1.Vector3.Dot(zdir, U1.Vector3.Cross(xdir, ydir)) < -0.9) {
                xdir.Scale(-1);
                Scale.X *= -1;
            }
            xdir.Normalize();
            ydir.Normalize();
            zdir.Normalize();
            if (U1.Vector3.Dot(zdir, unitz) >= 0.9999) {
                AxisAngle.Set(0, 0, 1);
                AxisAngle.W = U1.GeometryHelper2.AngleCCW(ux2, xdir.XY(xy));
            }
            else {
                U1.MathHelper.GetAxisAngle(xdir, ydir, res);
            }
        }
    }
    Matrix4.tv0 = U1.Vector3.Zero;
    Matrix4.tv1 = U1.Vector3.Zero;
    Matrix4.tv2 = U1.Vector3.Zero;
    Matrix4.tv3 = U1.Vector3.Zero;
    U1.Matrix4 = Matrix4;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Circle2 {
        constructor(center, radius) {
            this.Center = new U1.Vector2();
            this.Radius = 0;
            if (center != null)
                this.Center = center;
            if (radius != null)
                this.Radius = radius;
        }
        Equals(other) {
            return this.Center.Equals(other.Center) && (this.Radius == other.Radius);
        }
        static IsIntersectPolyline(center, sqRadius, path) {
            for (var i = 1; i < path.length; i++) {
                var s = path[i - 1];
                var cs2 = U1.Vector2.DistanceSquared(center, s);
                if (cs2 < sqRadius)
                    return true;
                var e = path[i];
                var s_e = U1.Vector2.Subtract(e, s);
                var dir = U1.Vector2.Normalize(s_e);
                var l = U1.Vector2.Dot(dir, U1.Vector2.Subtract(center, s));
                var ll = l * l;
                var sql = cs2 - ll;
                if (sql > sqRadius)
                    continue;
                if (l < 0 && cs2 > sqRadius)
                    continue;
                if (ll > U1.Vector2.Dot(s_e, s_e) && U1.Vector2.DistanceSquared(center, s) > sqRadius)
                    continue;
                return true;
            }
            return false;
        }
        static IsIntersectPolygon(center, sqRadius, path) {
            for (var i = 1; i <= path.length; i++) {
                var s = path[i - 1];
                var cs2 = U1.Vector2.DistanceSquared(center, s);
                if (cs2 < sqRadius)
                    return true;
                var e = i < path.length ? path[i] : path[0];
                var s_e = U1.Vector2.Subtract(e, s);
                var dir = U1.Vector2.Normalize(s_e);
                var l = U1.Vector2.Dot(dir, U1.Vector2.Subtract(center, s));
                var ll = l * l;
                var sql = cs2 - ll;
                if (sql > sqRadius)
                    continue;
                if (l < 0 && cs2 > sqRadius)
                    continue;
                if (ll > U1.Vector2.Dot(s_e, s_e) && U1.Vector2.DistanceSquared(center, s) > sqRadius)
                    continue;
                return true;
            }
            return false;
        }
    }
    U1.Circle2 = Circle2;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Color {
        constructor(r = 0, g = 0, b = 0, a = 255) {
            this.A = Math.floor(a);
            this.R = Math.floor(r);
            this.G = Math.floor(g);
            this.B = Math.floor(b);
        }
        ConvertFromStr(value) {
            if (value == null)
                return;
            var items = value
                .replace('(', '')
                .replace(')', '')
                .split(",");
            this.R = items.length > 0 ? parseInt(items[0]) : 0;
            this.G = items.length > 1 ? parseInt(items[1]) : 0;
            this.B = items.length > 2 ? parseInt(items[2]) : 0;
            this.A = items.length > 3 ? parseInt(items[3]) : 255;
        }
        ConvertToStr() {
            return "" + this.R + "," + this.G + "," + this.B + "," + this.A;
        }
        Equals(other) {
            if (this === other)
                return true;
            if (this.A == other.A &&
                this.R == other.R &&
                this.G == other.G &&
                this.B == other.B)
                return true;
            return false;
        }
        CopyFrom(other) {
            this.A = other.A;
            this.R = other.R;
            this.G = other.G;
            this.B = other.B;
        }
        Clone() {
            return new Color(this.R, this.G, this.B, this.A);
        }
        static FromUInt32(argb) {
            var color = new Color();
            color.A = 255;
            color.R = ((argb & 0xff0000) >> 0x10);
            color.G = ((argb & 0xff00) >> 8);
            color.B = (argb & 0xff);
            return color;
        }
        toString() {
            return `rgba(${this.R},${this.G},${this.B},${this.A})`;
        }
        toHexString() {
            let r = this.R.toString(16);
            if (r.length < 2)
                r = "0" + r;
            let g = this.G.toString(16);
            if (g.length < 2)
                g = "0" + g;
            let b = this.B.toString(16);
            if (b.length < 2)
                b = "0" + b;
            let a = this.A.toString(16);
            if (a.length < 2)
                a = "0" + a;
            return `#${r}${g}${b}${a}`;
        }
        toHexRGBString() {
            let r = this.R.toString(16);
            if (r.length < 2)
                r = "0" + r;
            let g = this.G.toString(16);
            if (g.length < 2)
                g = "0" + g;
            let b = this.B.toString(16);
            if (b.length < 2)
                b = "0" + b;
            return `#${r}${g}${b}`;
        }
        static fromHexString(strVal) {
            if (strVal.startsWith("#"))
                strVal = strVal.substring(1);
            var val = new Color();
            var strR = "";
            var strG = "";
            var strB = "";
            var strA = "FF";
            if (strVal.length == 6 || strVal.length == 8) {
                strR = strVal.substring(0, 2);
                strG = strVal.substring(2, 4);
                strB = strVal.substring(4, 6);
                if (strVal.length == 8)
                    strA = strVal.substring(6, 8);
            }
            val.R = parseInt(strR, 16);
            val.G = parseInt(strG, 16);
            val.B = parseInt(strB, 16);
            val.A = parseInt(strA, 16);
            return val;
        }
        toVector4() {
            return new U1.Vector4(this.R / 255, this.G / 255, this.B / 255, this.A / 255);
        }
    }
    U1.Color = Color;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Colors {
        static get AliceBlue() {
            return U1.Color.FromUInt32(0xfff0f8ff);
        }
        static get AntiqueWhite() {
            return U1.Color.FromUInt32(0xfffaebd7);
        }
        static get Aqua() {
            return U1.Color.FromUInt32(0xff00ffff);
        }
        static get Aquamarine() {
            return U1.Color.FromUInt32(0xff7fffd4);
        }
        static get Azure() {
            return U1.Color.FromUInt32(0xfff0ffff);
        }
        static get Beige() {
            return U1.Color.FromUInt32(0xfff5f5dc);
        }
        static get Bisque() {
            return U1.Color.FromUInt32(0xffffe4c4);
        }
        static get Black() {
            return U1.Color.FromUInt32(0xff000000);
        }
        static get BlanchedAlmond() {
            return U1.Color.FromUInt32(0xffffebcd);
        }
        static get Blue() {
            return U1.Color.FromUInt32(0xff0000ff);
        }
        static get BlueViolet() {
            return U1.Color.FromUInt32(0xff8a2be2);
        }
        static get Brown() {
            return U1.Color.FromUInt32(0xffa52a2a);
        }
        static get BurlyWood() {
            return U1.Color.FromUInt32(0xffdeb887);
        }
        static get CadetBlue() {
            return U1.Color.FromUInt32(0xff5f9ea0);
        }
        static get Chartreuse() {
            return U1.Color.FromUInt32(0xff7fff00);
        }
        static get Chocolate() {
            return U1.Color.FromUInt32(0xffd2691e);
        }
        static get Coral() {
            return U1.Color.FromUInt32(0xffff7f50);
        }
        static get CornflowerBlue() {
            return U1.Color.FromUInt32(0xff6495ed);
        }
        static get Cornsilk() {
            return U1.Color.FromUInt32(0xfffff8dc);
        }
        static get Crimson() {
            return U1.Color.FromUInt32(0xffdc143c);
        }
        static get Cyan() {
            return U1.Color.FromUInt32(0xff00ffff);
        }
        static get DarkBlue() {
            return U1.Color.FromUInt32(0xff00008b);
        }
        static get DarkCyan() {
            return U1.Color.FromUInt32(0xff008b8b);
        }
        static get DarkGoldenrod() {
            return U1.Color.FromUInt32(0xffb8860b);
        }
        static get DarkGray() {
            return U1.Color.FromUInt32(0xffa9a9a9);
        }
        static get DarkGreen() {
            return U1.Color.FromUInt32(0xff006400);
        }
        static get DarkKhaki() {
            return U1.Color.FromUInt32(0xffbdb76b);
        }
        static get DarkMagenta() {
            return U1.Color.FromUInt32(0xff8b008b);
        }
        static get DarkOliveGreen() {
            return U1.Color.FromUInt32(0xff556b2f);
        }
        static get DarkOrange() {
            return U1.Color.FromUInt32(0xffff8c00);
        }
        static get DarkOrchid() {
            return U1.Color.FromUInt32(0xff9932cc);
        }
        static get DarkRed() {
            return U1.Color.FromUInt32(0xff8b0000);
        }
        static get DarkSalmon() {
            return U1.Color.FromUInt32(0xffe9967a);
        }
        static get DarkSeaGreen() {
            return U1.Color.FromUInt32(0xff8fbc8f);
        }
        static get DarkSlateBlue() {
            return U1.Color.FromUInt32(0xff483d8b);
        }
        static get DarkSlateGray() {
            return U1.Color.FromUInt32(0xff2f4f4f);
        }
        static get DarkTurquoise() {
            return U1.Color.FromUInt32(0xff00ced1);
        }
        static get DarkViolet() {
            return U1.Color.FromUInt32(0xff9400d3);
        }
        static get DeepPink() {
            return U1.Color.FromUInt32(0xffff1493);
        }
        static get DeepSkyBlue() {
            return U1.Color.FromUInt32(0xff00bfff);
        }
        static get DimGray() {
            return U1.Color.FromUInt32(0xff696969);
        }
        static get DodgerBlue() {
            return U1.Color.FromUInt32(0xff1e90ff);
        }
        static get Firebrick() {
            return U1.Color.FromUInt32(0xffb22222);
        }
        static get FloralWhite() {
            return U1.Color.FromUInt32(0xfffffaf0);
        }
        static get ForestGreen() {
            return U1.Color.FromUInt32(0xff228b22);
        }
        static get Fuchsia() {
            return U1.Color.FromUInt32(0xffff00ff);
        }
        static get Gainsboro() {
            return U1.Color.FromUInt32(0xffdcdcdc);
        }
        static get GhostWhite() {
            return U1.Color.FromUInt32(0xfff8f8ff);
        }
        static get Gold() {
            return U1.Color.FromUInt32(0xffffd700);
        }
        static get Goldenrod() {
            return U1.Color.FromUInt32(0xffdaa520);
        }
        static get Gray() {
            return U1.Color.FromUInt32(0xff808080);
        }
        static get Green() {
            return U1.Color.FromUInt32(0xff008000);
        }
        static get GreenYellow() {
            return U1.Color.FromUInt32(0xffadff2f);
        }
        static get Honeydew() {
            return U1.Color.FromUInt32(0xfff0fff0);
        }
        static get HotPink() {
            return U1.Color.FromUInt32(0xffff69b4);
        }
        static get IndianRed() {
            return U1.Color.FromUInt32(0xffcd5c5c);
        }
        static get Indigo() {
            return U1.Color.FromUInt32(0xff4b0082);
        }
        static get Ivory() {
            return U1.Color.FromUInt32(0xfffffff0);
        }
        static get Khaki() {
            return U1.Color.FromUInt32(0xfff0e68c);
        }
        static get Lavender() {
            return U1.Color.FromUInt32(0xffe6e6fa);
        }
        static get LavenderBlush() {
            return U1.Color.FromUInt32(0xfffff0f5);
        }
        static get LawnGreen() {
            return U1.Color.FromUInt32(0xff7cfc00);
        }
        static get LemonChiffon() {
            return U1.Color.FromUInt32(0xfffffacd);
        }
        static get LightBlue() {
            return U1.Color.FromUInt32(0xffadd8e6);
        }
        static get LightCoral() {
            return U1.Color.FromUInt32(0xfff08080);
        }
        static get LightCyan() {
            return U1.Color.FromUInt32(0xffe0ffff);
        }
        static get LightGoldenrodYellow() {
            return U1.Color.FromUInt32(0xfffafad2);
        }
        static get LightGray() {
            return U1.Color.FromUInt32(0xffd3d3d3);
        }
        static get LightGreen() {
            return U1.Color.FromUInt32(0xff90ee90);
        }
        static get LightPink() {
            return U1.Color.FromUInt32(0xffffb6c1);
        }
        static get LightSalmon() {
            return U1.Color.FromUInt32(0xffffa07a);
        }
        static get LightSeaGreen() {
            return U1.Color.FromUInt32(0xff20b2aa);
        }
        static get LightSkyBlue() {
            return U1.Color.FromUInt32(0xff87cefa);
        }
        static get LightSlateGray() {
            return U1.Color.FromUInt32(0xff778899);
        }
        static get LightSteelBlue() {
            return U1.Color.FromUInt32(0xffb0c4de);
        }
        static get LightYellow() {
            return U1.Color.FromUInt32(0xffffffe0);
        }
        static get Lime() {
            return U1.Color.FromUInt32(0xff00ff00);
        }
        static get LimeGreen() {
            return U1.Color.FromUInt32(0xff32cd32);
        }
        static get Linen() {
            return U1.Color.FromUInt32(0xfffaf0e6);
        }
        static get Magenta() {
            return U1.Color.FromUInt32(0xffff00ff);
        }
        static get Maroon() {
            return U1.Color.FromUInt32(0xff800000);
        }
        static get MediumAquamarine() {
            return U1.Color.FromUInt32(0xff66cdaa);
        }
        static get MediumBlue() {
            return U1.Color.FromUInt32(0xff0000cd);
        }
        static get MediumOrchid() {
            return U1.Color.FromUInt32(0xffba55d3);
        }
        static get MediumPurple() {
            return U1.Color.FromUInt32(0xff9370db);
        }
        static get MediumSeaGreen() {
            return U1.Color.FromUInt32(0xff3cb371);
        }
        static get MediumSlateBlue() {
            return U1.Color.FromUInt32(0xff7b68ee);
        }
        static get MediumSpringGreen() {
            return U1.Color.FromUInt32(0xff00fa9a);
        }
        static get MediumTurquoise() {
            return U1.Color.FromUInt32(0xff48d1cc);
        }
        static get MediumVioletRed() {
            return U1.Color.FromUInt32(0xffc71585);
        }
        static get MidnightBlue() {
            return U1.Color.FromUInt32(0xff191970);
        }
        static get MintCream() {
            return U1.Color.FromUInt32(0xfff5fffa);
        }
        static get MistyRose() {
            return U1.Color.FromUInt32(0xffffe4e1);
        }
        static get Moccasin() {
            return U1.Color.FromUInt32(0xffffe4b5);
        }
        static get NavajoWhite() {
            return U1.Color.FromUInt32(0xffffdead);
        }
        static get Navy() {
            return U1.Color.FromUInt32(0xff000080);
        }
        static get OldLace() {
            return U1.Color.FromUInt32(0xfffdf5e6);
        }
        static get Olive() {
            return U1.Color.FromUInt32(0xff808000);
        }
        static get OliveDrab() {
            return U1.Color.FromUInt32(0xff6b8e23);
        }
        static get Orange() {
            return U1.Color.FromUInt32(0xffffa500);
        }
        static get OrangeRed() {
            return U1.Color.FromUInt32(0xffff4500);
        }
        static get Orchid() {
            return U1.Color.FromUInt32(0xffda70d6);
        }
        static get PaleGoldenrod() {
            return U1.Color.FromUInt32(0xffeee8aa);
        }
        static get PaleGreen() {
            return U1.Color.FromUInt32(0xff98fb98);
        }
        static get PaleTurquoise() {
            return U1.Color.FromUInt32(0xffafeeee);
        }
        static get PaleVioletRed() {
            return U1.Color.FromUInt32(0xffdb7093);
        }
        static get PapayaWhip() {
            return U1.Color.FromUInt32(0xffffefd5);
        }
        static get PeachPuff() {
            return U1.Color.FromUInt32(0xffffdab9);
        }
        static get Peru() {
            return U1.Color.FromUInt32(0xffcd853f);
        }
        static get Pink() {
            return U1.Color.FromUInt32(0xffffc0cb);
        }
        static get Plum() {
            return U1.Color.FromUInt32(0xffdda0dd);
        }
        static get PowderBlue() {
            return U1.Color.FromUInt32(0xffb0e0e6);
        }
        static get Purple() {
            return U1.Color.FromUInt32(0xff800080);
        }
        static get Red() {
            return U1.Color.FromUInt32(0xffff0000);
        }
        static get RosyBrown() {
            return U1.Color.FromUInt32(0xffbc8f8f);
        }
        static get RoyalBlue() {
            return U1.Color.FromUInt32(0xff4169e1);
        }
        static get SaddleBrown() {
            return U1.Color.FromUInt32(0xff8b4513);
        }
        static get Salmon() {
            return U1.Color.FromUInt32(0xfffa8072);
        }
        static get SandyBrown() {
            return U1.Color.FromUInt32(0xfff4a460);
        }
        static get SeaGreen() {
            return U1.Color.FromUInt32(0xff2e8b57);
        }
        static get SeaShell() {
            return U1.Color.FromUInt32(0xfffff5ee);
        }
        static get Sienna() {
            return U1.Color.FromUInt32(0xffa0522d);
        }
        static get Silver() {
            return U1.Color.FromUInt32(0xffc0c0c0);
        }
        static get SkyBlue() {
            return U1.Color.FromUInt32(0xff87ceeb);
        }
        static get SlateBlue() {
            return U1.Color.FromUInt32(0xff6a5acd);
        }
        static get SlateGray() {
            return U1.Color.FromUInt32(0xff708090);
        }
        static get Snow() {
            return U1.Color.FromUInt32(0xfffffafa);
        }
        static get SpringGreen() {
            return U1.Color.FromUInt32(0xff00ff7f);
        }
        static get SteelBlue() {
            return U1.Color.FromUInt32(0xff4682b4);
        }
        static get Tan() {
            return U1.Color.FromUInt32(0xffd2b48c);
        }
        static get Teal() {
            return U1.Color.FromUInt32(0xff008080);
        }
        static get Thistle() {
            return U1.Color.FromUInt32(0xffd8bfd8);
        }
        static get Tomato() {
            return U1.Color.FromUInt32(0xffff6347);
        }
        static get Transparent() {
            return U1.Color.FromUInt32(0xffffff);
        }
        static get Turquoise() {
            return U1.Color.FromUInt32(0xff40e0d0);
        }
        static get Violet() {
            return U1.Color.FromUInt32(0xffee82ee);
        }
        static get Wheat() {
            return U1.Color.FromUInt32(0xfff5deb3);
        }
        static get White() {
            return new U1.Color(255, 255, 255, 255);
        }
        static get WhiteSmoke() {
            return U1.Color.FromUInt32(0xffffffff);
        }
        static get Yellow() {
            return U1.Color.FromUInt32(0xffffff00);
        }
        static get YellowGreen() {
            return U1.Color.FromUInt32(0xff9acd32);
        }
    }
    U1.Colors = Colors;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    let LightTypeEnum;
    (function (LightTypeEnum) {
        LightTypeEnum[LightTypeEnum["POINT"] = 1] = "POINT";
        LightTypeEnum[LightTypeEnum["SPOT"] = 2] = "SPOT";
        LightTypeEnum[LightTypeEnum["DIRECTIONAL"] = 3] = "DIRECTIONAL";
    })(LightTypeEnum = U1.LightTypeEnum || (U1.LightTypeEnum = {}));
    class Light {
        constructor() {
            this.Diffuse = new U1.Color(255, 255, 255);
            this.Specular = new U1.Color(255, 255, 255);
            this.Ambient = new U1.Color(0, 0, 0);
            this.Position = new U1.Vector3(0, 0, 0);
            this.Direction = U1.Vector3.Down;
        }
        Clone() {
            var copy = new Light();
            copy.Type = this.Type;
            copy.Diffuse.CopyFrom(this.Diffuse);
            copy.Specular.CopyFrom(this.Specular);
            copy.Ambient.CopyFrom(this.Ambient);
            copy.Position.CopyFrom(this.Position);
            copy.Direction.CopyFrom(this.Direction);
            copy.Range = this.Range;
            copy.Falloff = this.Falloff;
            copy.Attenuation0 = this.Attenuation0;
            copy.Attenuation1 = this.Attenuation1;
            copy.Attenuation2 = this.Attenuation2;
            copy.Theta = this.Theta;
            copy.Phi = this.Phi;
            return copy;
        }
        ConvertFromStr(value) {
            if (value == null)
                return;
            var items = value.split(",");
            var idx = 0;
            this.Type = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Diffuse.R = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Diffuse.G = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Diffuse.B = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Specular.R = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Specular.G = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Specular.B = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Ambient.R = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Ambient.G = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Ambient.B = items.length > idx ? parseInt(items[idx++]) : 0;
            this.Position.X = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Position.Y = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Position.Z = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Direction.X = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Direction.Y = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Direction.Z = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Range = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Falloff = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Attenuation0 = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Attenuation1 = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Attenuation2 = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Theta = items.length > idx ? parseFloat(items[idx++]) : 0;
            this.Phi = items.length > idx ? parseFloat(items[idx++]) : 0;
        }
        ConvertToStr() {
            return "" +
                this.Type + "," +
                this.Diffuse.R + "," +
                this.Diffuse.G + "," +
                this.Diffuse.B + "," +
                this.Specular.R + "," +
                this.Specular.G + "," +
                this.Specular.B + "," +
                this.Ambient.R + "," +
                this.Ambient.G + "," +
                this.Ambient.B + "," +
                this.Position.X + "," +
                this.Position.Y + "," +
                this.Position.Z + "," +
                this.Direction.X + "," +
                this.Direction.Y + "," +
                this.Direction.Z + "," +
                this.Range + "," +
                this.Falloff + "," +
                this.Attenuation0 + "," +
                this.Attenuation1 + "," +
                this.Attenuation2 + "," +
                this.Theta + "," +
                this.Phi;
        }
        CopyFrom(source) {
            this.Type = source.Type;
            this.Diffuse.R = source.Diffuse.R;
            this.Diffuse.G = source.Diffuse.G;
            this.Diffuse.B = source.Diffuse.B;
            this.Specular.R = source.Specular.R;
            this.Specular.G = source.Specular.G;
            this.Specular.B = source.Specular.B;
            this.Ambient.R = source.Ambient.R;
            this.Ambient.G = source.Ambient.G;
            this.Ambient.B = source.Ambient.B;
            this.Position.X = source.Position.X;
            this.Position.Y = source.Position.Y;
            this.Position.Z = source.Position.Z;
            this.Direction.X = source.Direction.X;
            this.Direction.Y = source.Direction.Y;
            this.Direction.Z = source.Direction.Z;
            this.Range = source.Range;
            this.Falloff = source.Falloff;
            this.Attenuation0 = source.Attenuation0;
            this.Attenuation1 = source.Attenuation1;
            this.Attenuation2 = source.Attenuation2;
            this.Theta = source.Theta;
            this.Phi = source.Phi;
        }
        Equals(source) {
            if (this === source)
                return true;
            return this.Type == source.Type &&
                this.Diffuse.R == source.Diffuse.R &&
                this.Diffuse.G == source.Diffuse.G &&
                this.Diffuse.B == source.Diffuse.B &&
                this.Specular.R == source.Specular.R &&
                this.Specular.G == source.Specular.G &&
                this.Specular.B == source.Specular.B &&
                this.Ambient.R == source.Ambient.R &&
                this.Ambient.G == source.Ambient.G &&
                this.Ambient.B == source.Ambient.B &&
                this.Position.X == source.Position.X &&
                this.Position.Y == source.Position.Y &&
                this.Position.Z == source.Position.Z &&
                this.Direction.X == source.Direction.X &&
                this.Direction.Y == source.Direction.Y &&
                this.Direction.Z == source.Direction.Z &&
                this.Range == source.Range &&
                this.Falloff == source.Falloff &&
                this.Attenuation0 == source.Attenuation0 &&
                this.Attenuation1 == source.Attenuation1 &&
                this.Attenuation2 == source.Attenuation2 &&
                this.Theta == source.Theta &&
                this.Phi == source.Phi;
        }
    }
    U1.Light = Light;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Line2 {
        constructor(position, direction) {
            this.Position = new U1.Vector2();
            this.Direction = new U1.Vector2();
            if (position != null)
                this.Position.CopyFrom(position);
            if (direction != null)
                this.Direction.CopyFrom(direction);
        }
        ConvertFromStr(value) {
            if (value == null)
                return;
            var items = value.split(",");
            this.Position.X = items.length > 0 ? parseFloat(items[0]) : 0;
            this.Position.Y = items.length > 1 ? parseFloat(items[1]) : 0;
            this.Direction.X = items.length > 2 ? parseFloat(items[2]) : 0;
            this.Direction.Y = items.length > 3 ? parseFloat(items[3]) : 0;
        }
        ConvertToStr() {
            return "" + this.Position.X + "," + this.Position.Y + "," + this.Direction.X + "," + this.Direction.Y;
        }
        Equals(other) {
            return this.Position.Equals(other.Position) && this.Direction.Equals(other.Direction);
        }
        CopyFrom(line2) {
            this.Position = line2.Position;
            this.Direction = line2.Direction;
        }
        CopyFromRay(ray) {
            this.Position = ray.Position;
            this.Direction = ray.Direction;
        }
        static GetIntersectPoint(line0, line1, result = null) {
            var p0 = line0.Position, d0 = line0.Direction;
            var p1 = line1.Position, d1 = line1.Direction;
            var d01 = U1.Vector2.Subtract(p0, p1);
            if (result == null)
                result = new U1.Vector2();
            var a = (d1.X) * (d01.Y) - (d1.Y) * (d01.X);
            var b = (d1.Y) * (d0.X) - (d1.X) * (d0.Y);
            if (Math.abs(b) < U1.PRECISION)
                return null;
            var t = a / b;
            result.SetScaleAdd(p0, t, d0);
            return result;
        }
        static GetIntersectInfo(line0, line1, result = null) {
            if (result == null) {
                result = { IsectP: null, s: 0, t: 0 };
            }
            var d0 = line0.Direction;
            var d1 = line1.Direction;
            var diff = U1.Vector2.Subtract(line1.Position, line0.Position);
            var a = U1.Vector2.Dot(diff, d0) / U1.Vector2.Dot(d0, d0);
            var b = U1.Vector2.Dot(d1, d0) / U1.Vector2.Dot(d0, d0);
            var c = U1.Vector2.Dot(U1.Vector2.Negate(diff), d1) / U1.Vector2.Dot(d1, d1);
            var d = U1.Vector2.Dot(d0, d1) / U1.Vector2.Dot(d1, d1);
            if (1 - U1.PRECISION < b * d && b * d < 1 + U1.PRECISION) {
                return null;
            }
            else {
                var s = (a + b * c) / (1 - b * d);
                var t = c + d * s;
                if (result.IsectP != null)
                    result.IsectP = new U1.Vector2();
                result.IsectP.SetScaleAdd(line0.Position, s, d0);
                result.s = s;
                result.t = t;
                return result;
            }
        }
        static DistanceSquared(line, point) {
            var dir = U1.Vector2.Normalize(line.Direction);
            var p_s = U1.Vector2.Subtract(point, line.Position);
            var l = U1.Vector2.Dot(dir, p_s);
            return U1.Vector2.DistanceSquared(line.Position, point) - l * l;
        }
    }
    U1.Line2 = Line2;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class OrientedBox3 {
        constructor(src) {
            this.Axes = [U1.Vector3.UnitX, U1.Vector3.UnitY, U1.Vector3.UnitZ];
            this.Center = new U1.Vector3();
            this.Extents = [0, 0, 0];
            if (src != null) {
                this.Center.CopyFrom(src.Center);
                this.Axes[0].CopyFrom(src.Axes[0]);
                this.Axes[1].CopyFrom(src.Axes[1]);
                this.Axes[2].CopyFrom(src.Axes[2]);
                this.Extents[0] = src.Extents[0];
                this.Extents[1] = src.Extents[1];
                this.Extents[2] = src.Extents[2];
            }
        }
        CopyFrom(src) {
            this.Center.CopyFrom(src.Center);
            this.Axes[0].CopyFrom(src.Axes[0]);
            this.Axes[1].CopyFrom(src.Axes[1]);
            this.Axes[2].CopyFrom(src.Axes[2]);
            this.Extents[0] = src.Extents[0];
            this.Extents[1] = src.Extents[1];
            this.Extents[2] = src.Extents[2];
            return this;
        }
        get Radius() {
            return (Math.sqrt(this.Extents[0] * this.Extents[0] +
                this.Extents[1] * this.Extents[1] +
                this.Extents[2] * this.Extents[2]));
        }
        get IsEmpty() {
            return this.Extents[0] == 0 && this.Extents[1] == 0 && this.Extents[2] == 0;
        }
        Clone() {
            var result = new OrientedBox3();
            result.CopyFrom(this);
            return result;
        }
        static get Empty() {
            return new OrientedBox3();
        }
        static get Identity() {
            var box = new OrientedBox3();
            box.Extents[0] = 0.5;
            box.Extents[1] = 0.5;
            box.Extents[2] = 0.5;
            return box;
        }
        SetIdentity() {
            this.Center.Set(0, 0, 0);
            this.Axes[0].SetUnitX();
            this.Axes[1].SetUnitY();
            this.Axes[2].SetUnitZ();
            this.Extents[0] = 0.5;
            this.Extents[1] = 0.5;
            this.Extents[2] = 0.5;
            return this;
        }
        static CheckIntersect(rkBox0, rkBox1) {
            var akA = rkBox0.Axes;
            var akB = rkBox1.Axes;
            var afEA = rkBox0.Extents;
            var afEB = rkBox1.Extents;
            var kD = U1.Vector3.Subtract(rkBox1.Center, rkBox0.Center);
            var aafC = [
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0]
            ];
            var aafAbsC = [
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0]
            ];
            var afAD = [0, 0, 0];
            var fR0 = 0, fR1 = 0, fR = 0;
            var fR01 = 0;
            aafC[0][0] = U1.Vector3.Dot(akA[0], akB[0]);
            aafC[0][1] = U1.Vector3.Dot(akA[0], akB[1]);
            aafC[0][2] = U1.Vector3.Dot(akA[0], akB[2]);
            afAD[0] = U1.Vector3.Dot(akA[0], kD);
            aafAbsC[0][0] = Math.abs(aafC[0][0]);
            aafAbsC[0][1] = Math.abs(aafC[0][1]);
            aafAbsC[0][2] = Math.abs(aafC[0][2]);
            fR = Math.abs(afAD[0]);
            fR1 = afEB[0] * aafAbsC[0][0] + afEB[1] * aafAbsC[0][1] + afEB[2] * aafAbsC[0][2];
            fR01 = afEA[0] + fR1;
            if (fR > fR01)
                return false;
            aafC[1][0] = U1.Vector3.Dot(akA[1], akB[0]);
            aafC[1][1] = U1.Vector3.Dot(akA[1], akB[1]);
            aafC[1][2] = U1.Vector3.Dot(akA[1], akB[2]);
            afAD[1] = U1.Vector3.Dot(akA[1], kD);
            aafAbsC[1][0] = Math.abs(aafC[1][0]);
            aafAbsC[1][1] = Math.abs(aafC[1][1]);
            aafAbsC[1][2] = Math.abs(aafC[1][2]);
            fR = Math.abs(afAD[1]);
            fR1 = afEB[0] * aafAbsC[1][0] + afEB[1] * aafAbsC[1][1] + afEB[2] * aafAbsC[1][2];
            fR01 = afEA[1] + fR1;
            if (fR > fR01)
                return false;
            aafC[2][0] = U1.Vector3.Dot(akA[2], akB[0]);
            aafC[2][1] = U1.Vector3.Dot(akA[2], akB[1]);
            aafC[2][2] = U1.Vector3.Dot(akA[2], akB[2]);
            afAD[2] = U1.Vector3.Dot(akA[2], kD);
            aafAbsC[2][0] = Math.abs(aafC[2][0]);
            aafAbsC[2][1] = Math.abs(aafC[2][1]);
            aafAbsC[2][2] = Math.abs(aafC[2][2]);
            fR = Math.abs(afAD[2]);
            fR1 = afEB[0] * aafAbsC[2][0] + afEB[1] * aafAbsC[2][1] + afEB[2] * aafAbsC[2][2];
            fR01 = afEA[2] + fR1;
            if (fR > fR01)
                return false;
            fR = Math.abs(U1.Vector3.Dot(akB[0], kD));
            fR0 = afEA[0] * aafAbsC[0][0] + afEA[1] * aafAbsC[1][0] + afEA[2] * aafAbsC[2][0];
            fR01 = fR0 + afEB[0];
            if (fR > fR01)
                return false;
            fR = Math.abs(U1.Vector3.Dot(akB[1], kD));
            fR0 = afEA[0] * aafAbsC[0][1] + afEA[1] * aafAbsC[1][1] + afEA[2] * aafAbsC[2][1];
            fR01 = fR0 + afEB[1];
            if (fR > fR01)
                return false;
            fR = Math.abs(U1.Vector3.Dot(akB[2], kD));
            fR0 = afEA[0] * aafAbsC[0][2] + afEA[1] * aafAbsC[1][2] + afEA[2] * aafAbsC[2][2];
            fR01 = fR0 + afEB[2];
            if (fR > fR01)
                return false;
            fR = Math.abs(afAD[2] * aafC[1][0] - afAD[1] * aafC[2][0]);
            fR0 = afEA[1] * aafAbsC[2][0] + afEA[2] * aafAbsC[1][0];
            fR1 = afEB[1] * aafAbsC[0][2] + afEB[2] * aafAbsC[0][1];
            fR01 = fR0 + fR1;
            if (fR > fR01)
                return false;
            fR = Math.abs(afAD[2] * aafC[1][1] - afAD[1] * aafC[2][1]);
            fR0 = afEA[1] * aafAbsC[2][1] + afEA[2] * aafAbsC[1][1];
            fR1 = afEB[0] * aafAbsC[0][2] + afEB[2] * aafAbsC[0][0];
            fR01 = fR0 + fR1;
            if (fR > fR01)
                return false;
            fR = Math.abs(afAD[2] * aafC[1][2] - afAD[1] * aafC[2][2]);
            fR0 = afEA[1] * aafAbsC[2][2] + afEA[2] * aafAbsC[1][2];
            fR1 = afEB[0] * aafAbsC[0][1] + afEB[1] * aafAbsC[0][0];
            fR01 = fR0 + fR1;
            if (fR > fR01)
                return false;
            fR = Math.abs(afAD[0] * aafC[2][0] - afAD[2] * aafC[0][0]);
            fR0 = afEA[0] * aafAbsC[2][0] + afEA[2] * aafAbsC[0][0];
            fR1 = afEB[1] * aafAbsC[1][2] + afEB[2] * aafAbsC[1][1];
            fR01 = fR0 + fR1;
            if (fR > fR01)
                return false;
            fR = Math.abs(afAD[0] * aafC[2][1] - afAD[2] * aafC[0][1]);
            fR0 = afEA[0] * aafAbsC[2][1] + afEA[2] * aafAbsC[0][1];
            fR1 = afEB[0] * aafAbsC[1][2] + afEB[2] * aafAbsC[1][0];
            fR01 = fR0 + fR1;
            if (fR > fR01)
                return false;
            fR = Math.abs(afAD[0] * aafC[2][2] - afAD[2] * aafC[0][2]);
            fR0 = afEA[0] * aafAbsC[2][2] + afEA[2] * aafAbsC[0][2];
            fR1 = afEB[0] * aafAbsC[1][1] + afEB[1] * aafAbsC[1][0];
            fR01 = fR0 + fR1;
            if (fR > fR01)
                return false;
            fR = Math.abs(afAD[1] * aafC[0][0] - afAD[0] * aafC[1][0]);
            fR0 = afEA[0] * aafAbsC[1][0] + afEA[1] * aafAbsC[0][0];
            fR1 = afEB[1] * aafAbsC[2][2] + afEB[2] * aafAbsC[2][1];
            fR01 = fR0 + fR1;
            if (fR > fR01)
                return false;
            fR = Math.abs(afAD[1] * aafC[0][1] - afAD[0] * aafC[1][1]);
            fR0 = afEA[0] * aafAbsC[1][1] + afEA[1] * aafAbsC[0][1];
            fR1 = afEB[0] * aafAbsC[2][2] + afEB[2] * aafAbsC[2][0];
            fR01 = fR0 + fR1;
            if (fR > fR01)
                return false;
            fR = Math.abs(afAD[1] * aafC[0][2] - afAD[0] * aafC[1][2]);
            fR0 = afEA[0] * aafAbsC[1][2] + afEA[1] * aafAbsC[0][2];
            fR1 = afEB[0] * aafAbsC[2][1] + afEB[1] * aafAbsC[2][0];
            fR01 = fR0 + fR1;
            if (fR > fR01)
                return false;
            return true;
        }
        static GetOrientMatrix(obx, result) {
            if (result == null)
                result = U1.Matrix4.Identity;
            else
                result.SetIdentity();
            result.M11 = obx.Axes[0].X;
            result.M12 = obx.Axes[0].Y;
            result.M13 = obx.Axes[0].Z;
            result.M21 = obx.Axes[1].X;
            result.M22 = obx.Axes[1].Y;
            result.M23 = obx.Axes[1].Z;
            result.M31 = obx.Axes[2].X;
            result.M32 = obx.Axes[2].Y;
            result.M33 = obx.Axes[2].Z;
            return result;
        }
        static GetMatrix(obx, result) {
            if (result == null)
                result = U1.Matrix4.Identity;
            else
                result.SetIdentity();
            var mxScale = OrientedBox3[".gm.ms"] || (OrientedBox3[".gm.ms"] = new U1.Matrix4());
            var mxRot = OrientedBox3[".gm.mr"] || (OrientedBox3[".gm.mr"] = new U1.Matrix4());
            var mxTrans = OrientedBox3[".gm.mt"] || (OrientedBox3[".gm.mt"] = new U1.Matrix4());
            mxScale.SetCreateScaleByFloats(obx.Extents[0] * 2, obx.Extents[1] * 2, obx.Extents[2] * 2);
            this.GetOrientMatrix(obx, mxRot);
            mxTrans.SetCreateTranslation(obx.Center);
            result.SetMultiply(mxScale, mxRot).Multiply(mxTrans);
            return result;
        }
        GetMatrix(result = null) {
            return OrientedBox3.GetMatrix(this, result);
        }
        GetOrientMatrix(result = null) {
            return OrientedBox3.GetOrientMatrix(this, result);
        }
        LFB(result) {
            return this.GetVertex(-1, -1, -1, result);
        }
        LKB(result) {
            return this.GetVertex(-1, 1, -1, result);
        }
        LFT(result) {
            return this.GetVertex(-1, -1, 1, result);
        }
        LKT(result) {
            return this.GetVertex(-1, 1, 1, result);
        }
        RFB(result) {
            return this.GetVertex(1, -1, -1, result);
        }
        RKB(result) {
            return this.GetVertex(1, 1, -1, result);
        }
        RFT(result) {
            return this.GetVertex(1, -1, 1, result);
        }
        RKT(result) {
            return this.GetVertex(1, 1, 1, result);
        }
        FrontPlane(result) {
            if (result == null)
                result = new U1.Plane();
            var lfb = this.LFB();
            var lkb = this.LKB();
            var norm = OrientedBox3[".fp.norm"] || (OrientedBox3[".fp.norm"] = new U1.Vector3());
            norm.SetSubtract(lfb, lkb);
            result.SetFromPointNormal(lfb, norm);
            return result;
        }
        BackPlane(result) {
            if (result == null)
                result = new U1.Plane();
            var lfb = this.LFB();
            var lkb = this.LKB();
            var norm = U1.Vector3.Subtract(lkb, lfb);
            result.SetFromPointNormal(lkb, norm);
            return result;
        }
        RightPlane(result) {
            if (result == null)
                result = new U1.Plane();
            var rkb = this.RKB();
            var lkb = this.LKB();
            var norm = U1.Vector3.Subtract(rkb, lkb);
            result.SetFromPointNormal(rkb, norm);
            return result;
        }
        LeftPlane(result) {
            if (result == null)
                result = new U1.Plane();
            var rkb = this.RKB();
            var lkb = this.LKB();
            return U1.Plane.FromPointNormal(lkb, U1.Vector3.Subtract(lkb, rkb));
        }
        TopPlane(result) {
            if (result == null)
                result = new U1.Plane();
            var lkt = this.LKT();
            var lkb = this.LKB();
            var norm = U1.Vector3.Subtract(lkt, lkb);
            result.SetFromPointNormal(lkt, norm);
            return result;
        }
        BottomPlane(result) {
            if (result == null)
                result = new U1.Plane();
            var lkt = this.LKT();
            var lkb = this.LKB();
            var norm = U1.Vector3.Subtract(lkb, lkt);
            result.SetFromPointNormal(lkb, norm);
            return result;
        }
        GetVs(points) {
            if (points == null)
                points = new Array(8);
            points[0] = this.LFB(points[0]);
            points[1] = this.LKB(points[1]);
            points[2] = this.LFT(points[2]);
            points[3] = this.LKT(points[3]);
            points[4] = this.RFB(points[4]);
            points[5] = this.RKB(points[5]);
            points[6] = this.RFT(points[6]);
            points[7] = this.RKT(points[7]);
            return points;
        }
        GetVertex(s0, s1, s2, result) {
            result = result || new U1.Vector3();
            result.CopyFrom(this.Center);
            result.ScaleAdd(s0 * this.Extents[0], this.Axes[0])
                .ScaleAdd(s1 * this.Extents[1], this.Axes[1])
                .ScaleAdd(s2 * this.Extents[2], this.Axes[2]);
            return result;
        }
        static Transform(source, matrix, result) {
            if (result == null)
                result = new OrientedBox3();
            var xp = U1.Vector3.ScaleAdd(result.Center, result.Extents[0], result.Axes[0]).Transform(matrix);
            var yp = U1.Vector3.ScaleAdd(result.Center, result.Extents[1], result.Axes[1]).Transform(matrix);
            var zp = U1.Vector3.ScaleAdd(result.Center, result.Extents[2], result.Axes[2]).Transform(matrix);
            var cp = U1.Vector3.Transform(result.Center, matrix);
            result.Center.CopyFrom(cp);
            result.Axes[0].SetSubtract(xp, cp).Normalize();
            result.Axes[1].SetSubtract(yp, cp).Normalize();
            result.Axes[2].SetSubtract(zp, cp).Normalize();
            result.Extents[0] = U1.Vector3.Distance(xp, cp);
            result.Extents[0] = U1.Vector3.Distance(yp, cp);
            result.Extents[0] = U1.Vector3.Distance(zp, cp);
            return result;
        }
        Transform(matrix) {
            var xp = U1.Vector3.ScaleAdd(this.Center, this.Extents[0], this.Axes[0]).Transform(matrix);
            var yp = U1.Vector3.ScaleAdd(this.Center, this.Extents[1], this.Axes[1]).Transform(matrix);
            var zp = U1.Vector3.ScaleAdd(this.Center, this.Extents[2], this.Axes[2]).Transform(matrix);
            var cp = U1.Vector3.Transform(this.Center, matrix);
            this.Center.CopyFrom(cp);
            this.Axes[0].TransformNormal(matrix).Normalize();
            this.Axes[1].TransformNormal(matrix).Normalize();
            this.Axes[2].TransformNormal(matrix).Normalize();
            this.Extents[0] = U1.Vector3.Distance(xp, cp);
            this.Extents[1] = U1.Vector3.Distance(yp, cp);
            this.Extents[2] = U1.Vector3.Distance(zp, cp);
            return this;
        }
        SetTransform(source, matrix) {
            var xp = U1.Vector3.ScaleAdd(source.Center, source.Extents[0], source.Axes[0]).Transform(matrix);
            var yp = U1.Vector3.ScaleAdd(source.Center, source.Extents[1], source.Axes[1]).Transform(matrix);
            var zp = U1.Vector3.ScaleAdd(source.Center, source.Extents[2], source.Axes[2]).Transform(matrix);
            var cp = U1.Vector3.Transform(source.Center, matrix);
            this.Center.CopyFrom(cp);
            this.Axes[0].SetSubtract(xp, cp).Normalize();
            this.Axes[1].SetSubtract(yp, cp).Normalize();
            this.Axes[2].SetSubtract(zp, cp).Normalize();
            this.Extents[0] = U1.Vector3.Distance(xp, cp);
            this.Extents[0] = U1.Vector3.Distance(yp, cp);
            this.Extents[0] = U1.Vector3.Distance(zp, cp);
            return this;
        }
        ScaleWithTwoPoints(cent, p0, p1) {
            return this.SetScaleWithTowPoints(this, cent, p0, p1);
        }
        Scale(cent, axisScale) {
            return this.SetScale(this, cent, axisScale);
        }
        SetScale(source, cent, axisScale) {
            var cc = OrientedBox3[".sc.cc"] || (OrientedBox3[".sc.cc"] = new U1.Vector3());
            cent = cent.Clone();
            cc.SetSubtract(source.Center, cent);
            var cx = U1.Vector3.Dot(source.Axes[0], cc);
            var cy = U1.Vector3.Dot(source.Axes[1], cc);
            var cz = U1.Vector3.Dot(source.Axes[2], cc);
            cent.ScaleAdd((cx * axisScale.X), source.Axes[0]);
            cent.ScaleAdd((cy * axisScale.Y), source.Axes[1]);
            cent.ScaleAdd((cz * axisScale.Z), source.Axes[2]);
            this.Center.CopyFrom(cent);
            this.Extents[0] = source.Extents[0] * axisScale.X;
            this.Extents[1] = source.Extents[1] * axisScale.Y;
            this.Extents[2] = source.Extents[2] * axisScale.Z;
            return this;
        }
        SetScaleWithTowPoints(source, cent, p0, p1) {
            this.CopyFrom(source);
            var d0 = U1.Vector3.Subtract(p0, cent);
            var d1 = U1.Vector3.Subtract(p1, cent);
            var dir = U1.Vector3.Subtract(p1, p0).Normalize();
            var a0 = U1.Vector3.Distance(p0, cent);
            var a1 = U1.Vector3.Distance(p1, cent);
            if (a0 < 0.0001) {
                return this;
            }
            var sdt = (a1 - a0) / a0;
            var scale = 1 + sdt;
            var xAxis = source.Axes[0];
            var yAxis = source.Axes[1];
            var zAxis = source.Axes[2];
            var x0 = U1.Vector3.Dot(d0, xAxis);
            var x1 = U1.Vector3.Dot(d1, xAxis);
            var y0 = U1.Vector3.Dot(d0, yAxis);
            var y1 = U1.Vector3.Dot(d1, yAxis);
            var z0 = U1.Vector3.Dot(d0, zAxis);
            var z1 = U1.Vector3.Dot(d1, zAxis);
            var sc = OrientedBox3[".scwtp.sc"] || (OrientedBox3[".scwtp.sc"] = new U1.Vector3());
            sc.X = 1 + (Math.abs(x0) > 0.001 ? (x1 - x0) / x0 : 0);
            sc.Y = 1 + (Math.abs(y0) > 0.001 ? (y1 - y0) / y0 : 0);
            sc.Z = 1 + (Math.abs(z0) > 0.001 ? (z1 - z0) / z0 : 0);
            this.Scale(cent, sc);
            return this;
        }
        static ScaleWithTowPoints(source, cent, p0, p1) {
            var result = new OrientedBox3();
            return result.SetScaleWithTowPoints(source, cent, p0, p1);
        }
        static Rotate(source, center, axis, angle) {
            var rm = U1.Matrix4.CreateTranslation(U1.Vector3.Negate(center));
            rm = U1.Matrix4.Multiply(rm, U1.Matrix4.CreateFromAxisAngle(axis, angle));
            rm = U1.Matrix4.Multiply(rm, U1.Matrix4.CreateTranslation(center));
            var cent = U1.Vector3.Transform(source.Center, rm);
            var xAxis = U1.Vector3.Normalize(U1.Vector3.TransformNormal(source.Axes[0], rm));
            var yAxis = U1.Vector3.Normalize(U1.Vector3.TransformNormal(source.Axes[1], rm));
            var zAxis = U1.Vector3.Normalize(U1.Vector3.TransformNormal(source.Axes[2], rm));
            var result = source.Clone();
            result.Center = cent;
            result.Axes[0] = xAxis;
            result.Axes[1] = yAxis;
            result.Axes[2] = zAxis;
            return result;
        }
        static Translate(source, offset) {
            var result = source.Clone();
            result.Center.Add(offset);
            return result;
        }
        static GetMatrixBetween(from, to) {
            for (var i = 0; i < from.Extents.length; i++)
                if (from.Extents[i] == 0)
                    from.Extents[i] = 0.5;
            for (var i = 0; i < to.Extents.length; i++)
                if (to.Extents[i] == 0)
                    to.Extents[i] = 0.5;
            var tm = OrientedBox3[".gmb.tm"] || (OrientedBox3[".gmb.tm"] = new U1.Matrix4());
            var sm = OrientedBox3[".gmb.sm"] || (OrientedBox3[".gmb.sm"] = new U1.Matrix4());
            to.GetMatrix(tm);
            from.GetMatrix(sm);
            var result = sm.Invert().Multiply(tm);
            return result;
        }
        static Scale(source, cent, p0, p1) {
            var d0 = U1.Vector3.Subtract(p0, cent);
            var d1 = U1.Vector3.Subtract(p1, cent);
            var dir = U1.Vector3.Subtract(p1, p0).Normalize();
            var a0 = U1.Vector3.Distance(p0, cent);
            var a1 = U1.Vector3.Distance(p1, cent);
            if (a0 < 0.0001)
                return source;
            var sdt = (a1 - a0) / a0;
            var scale = 1 + sdt;
            var xAxis = source.Axes[0];
            var yAxis = source.Axes[1];
            var zAxis = source.Axes[2];
            var x0 = U1.Vector3.Dot(d0, xAxis);
            var x1 = U1.Vector3.Dot(d1, xAxis);
            var y0 = U1.Vector3.Dot(d0, yAxis);
            var y1 = U1.Vector3.Dot(d1, yAxis);
            var z0 = U1.Vector3.Dot(d0, zAxis);
            var z1 = U1.Vector3.Dot(d1, zAxis);
            var sx = 1 + (Math.abs(x0) > 0.001 ? (x1 - x0) / x0 : 0);
            var sy = 1 + (Math.abs(y0) > 0.001 ? (y1 - y0) / y0 : 0);
            var sz = 1 + (Math.abs(z0) > 0.001 ? (z1 - z0) / z0 : 0);
            var result = OrientedBox3.Scale1(source, cent, new U1.Vector3(sx, sy, sz));
            return result;
        }
        static Scale1(source, cent, scale) {
            var result = source;
            var cc = U1.Vector3.Subtract(source.Center, cent);
            var cx = U1.Vector3.Dot(source.Axes[0], cc);
            var cy = U1.Vector3.Dot(source.Axes[1], cc);
            var cz = U1.Vector3.Dot(source.Axes[2], cc);
            var vx = source.Axes[0].Clone().Scale(cx * scale.X);
            var vy = source.Axes[1].Clone().Scale(cy * scale.Y);
            var vz = source.Axes[2].Clone().Scale(cz * scale.Z);
            result.Center = vx.Add(vy).Add(vz).Add(cent);
            result.Extents = [
                source.Extents[0] * scale.X,
                source.Extents[1] * scale.Y,
                source.Extents[2] * scale.Z,
            ];
            return result;
        }
        Rotate(source, center, axis, angle) {
            var rm = U1.Matrix4.CreateTranslation(U1.Vector3.Negate(center));
            rm = U1.Matrix4.Multiply(rm, U1.Matrix4.CreateFromAxisAngle(axis, angle));
            rm = U1.Matrix4.Multiply(rm, U1.Matrix4.CreateTranslation(center));
            var cent = U1.Vector3.Transform(source.Center, rm);
            var xAxis = U1.Vector3.Normalize(U1.Vector3.TransformNormal(source.Axes[0], rm));
            var yAxis = U1.Vector3.Normalize(U1.Vector3.TransformNormal(source.Axes[1], rm));
            var zAxis = U1.Vector3.Normalize(U1.Vector3.TransformNormal(source.Axes[2], rm));
            var result = source.Clone();
            result.Center = cent;
            result.Axes[0] = xAxis;
            result.Axes[1] = yAxis;
            result.Axes[2] = zAxis;
            return result;
        }
        SetRotate(source, center, axis, angle) {
            var tv0 = U1.Vector3.Negate(center);
            var rm = OrientedBox3[".sr.rm"] || (OrientedBox3[".sr.rm"] = new U1.Matrix4());
            rm.SetCreateTranslation(tv0);
            rm = U1.Matrix4.Multiply(rm, U1.Matrix4.CreateFromAxisAngle(axis, angle));
            rm = U1.Matrix4.Multiply(rm, U1.Matrix4.CreateTranslation(center));
            var cent = U1.Vector3.Transform(source.Center, rm);
            var xAxis = U1.Vector3.Normalize(U1.Vector3.TransformNormal(source.Axes[0], rm));
            var yAxis = U1.Vector3.Normalize(U1.Vector3.TransformNormal(source.Axes[1], rm));
            var zAxis = U1.Vector3.Normalize(U1.Vector3.TransformNormal(source.Axes[2], rm));
            this.Center.CopyFrom(cent);
            this.Axes[0] = xAxis;
            this.Axes[1] = yAxis;
            this.Axes[2] = zAxis;
            this.Extents[0] = source.Extents[0];
            this.Extents[1] = source.Extents[1];
            this.Extents[2] = source.Extents[2];
            return this;
        }
    }
    U1.OrientedBox3 = OrientedBox3;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Plane {
        constructor(a = 0, b = 0, c = 0, d = 0) {
            this.Normal = new U1.Vector3(a, b, c);
            this.D = d;
        }
        ConvertFromStr(value) {
            this.Normal = new U1.Vector3();
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            var idx = 0;
            this.Normal.X = items.length > idx ? items[idx++] : 0;
            this.Normal.Y = items.length > idx ? items[idx++] : 0;
            this.Normal.Z = items.length > idx ? items[idx++] : 0;
            this.D = items.length > idx ? items[idx] : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this.Normal.X, this.Normal.Y, this.Normal.Z, this.D);
        }
        Equals(other) {
            return this.Normal.X == other.Normal.X
                && this.Normal.Y == other.Normal.Y
                && this.Normal.Z == other.Normal.Z
                && this.D == other.D;
        }
        Set(nx, ny, nz, d) {
            this.Normal.X = nx;
            this.Normal.Y = ny;
            this.Normal.Z = nz;
            this.D = d;
            return this;
        }
        Clone() {
            var result = new Plane(this.Normal.X, this.Normal.Y, this.Normal.Z, this.D);
            return result;
        }
        CopyFrom(source) {
            this.Normal.CopyFrom(source.Normal);
            this.D = source.D;
            return this;
        }
        static Zero() {
            return new Plane(0, 0, 0, 0);
        }
        SetZero() {
            this.Normal.X = 0;
            this.Normal.Y = 0;
            this.Normal.Z = 0;
            this.D = 0;
            return this;
        }
        get IsZero() {
            return this.Normal.X === 0 &&
                this.Normal.Y === 0 &&
                this.Normal.Z === 0 &&
                this.D === 0;
        }
        Normalize() {
            var num2 = ((this.Normal.X * this.Normal.X) + (this.Normal.Y * this.Normal.Y)) + (this.Normal.Z * this.Normal.Z);
            if (Math.abs((num2 - 1)) >= 1.192093E-07) {
                var num = 1 / (Math.sqrt(num2));
                this.Normal.X *= num;
                this.Normal.Y *= num;
                this.Normal.Z *= num;
                this.D *= num;
            }
            return this;
        }
        static Normalize(value, result = null) {
            if (result == null)
                result = new Plane();
            var num2 = ((value.Normal.X * value.Normal.X) + (value.Normal.Y * value.Normal.Y)) + (value.Normal.Z * value.Normal.Z);
            if (Math.abs((num2 - 1)) < 1.192093E-07) {
                result.Normal = value.Normal;
                result.D = value.D;
                return result;
            }
            var num = 1 / (Math.sqrt(num2));
            result.Normal.X = value.Normal.X * num;
            result.Normal.Y = value.Normal.Y * num;
            result.Normal.Z = value.Normal.Z * num;
            result.D = value.D * num;
            return result;
        }
        SetNormalize(value) {
            var num2 = ((value.Normal.X * value.Normal.X) + (value.Normal.Y * value.Normal.Y)) + (value.Normal.Z * value.Normal.Z);
            if (Math.abs((num2 - 1)) < 1.192093E-07) {
                this.Normal = value.Normal;
                this.D = value.D;
                return this;
            }
            var num = 1 / (Math.sqrt(num2));
            this.Normal.X = value.Normal.X * num;
            this.Normal.Y = value.Normal.Y * num;
            this.Normal.Z = value.Normal.Z * num;
            this.D = value.D * num;
            return this;
        }
        static Transform(plane, matrix, result = null) {
            if (result == null)
                result = new Plane();
            var matrix2 = U1.Matrix4.Invert(matrix);
            var x = plane.Normal.X;
            var y = plane.Normal.Y;
            var z = plane.Normal.Z;
            var d = plane.D;
            result.Normal.X = (((x * matrix2.M11) + (y * matrix2.M12)) + (z * matrix2.M13)) + (d * matrix2.M14);
            result.Normal.Y = (((x * matrix2.M21) + (y * matrix2.M22)) + (z * matrix2.M23)) + (d * matrix2.M24);
            result.Normal.Z = (((x * matrix2.M31) + (y * matrix2.M32)) + (z * matrix2.M33)) + (d * matrix2.M34);
            result.D = (((x * matrix2.M41) + (y * matrix2.M42)) + (z * matrix2.M43)) + (d * matrix2.M44);
            return result;
        }
        SetTransform(plane, matrix) {
            var matrix2 = U1.Matrix4.Invert(matrix);
            var x = plane.Normal.X;
            var y = plane.Normal.Y;
            var z = plane.Normal.Z;
            var d = plane.D;
            this.Normal.X = (((x * matrix2.M11) + (y * matrix2.M12)) + (z * matrix2.M13)) + (d * matrix2.M14);
            this.Normal.Y = (((x * matrix2.M21) + (y * matrix2.M22)) + (z * matrix2.M23)) + (d * matrix2.M24);
            this.Normal.Z = (((x * matrix2.M31) + (y * matrix2.M32)) + (z * matrix2.M33)) + (d * matrix2.M34);
            this.D = (((x * matrix2.M41) + (y * matrix2.M42)) + (z * matrix2.M43)) + (d * matrix2.M44);
            this.Normalize();
            return this;
        }
        static TransformQuaternion(plane, rotation, result = null) {
            if (result == null)
                result = new Plane();
            var num15 = rotation.X + rotation.X;
            var num5 = rotation.Y + rotation.Y;
            var num = rotation.Z + rotation.Z;
            var num14 = rotation.W * num15;
            var num13 = rotation.W * num5;
            var num12 = rotation.W * num;
            var num11 = rotation.X * num15;
            var num10 = rotation.X * num5;
            var num9 = rotation.X * num;
            var num8 = rotation.Y * num5;
            var num7 = rotation.Y * num;
            var num6 = rotation.Z * num;
            var num24 = (1 - num8) - num6;
            var num23 = num10 - num12;
            var num22 = num9 + num13;
            var num21 = num10 + num12;
            var num20 = (1 - num11) - num6;
            var num19 = num7 - num14;
            var num18 = num9 - num13;
            var num17 = num7 + num14;
            var num16 = (1 - num11) - num8;
            var x = plane.Normal.X;
            var y = plane.Normal.Y;
            var z = plane.Normal.Z;
            result.Normal.X = ((x * num24) + (y * num23)) + (z * num22);
            result.Normal.Y = ((x * num21) + (y * num20)) + (z * num19);
            result.Normal.Z = ((x * num18) + (y * num17)) + (z * num16);
            result.D = plane.D;
            return result;
        }
        SetTransformQuaternion(plane, rotation) {
            var num15 = rotation.X + rotation.X;
            var num5 = rotation.Y + rotation.Y;
            var num = rotation.Z + rotation.Z;
            var num14 = rotation.W * num15;
            var num13 = rotation.W * num5;
            var num12 = rotation.W * num;
            var num11 = rotation.X * num15;
            var num10 = rotation.X * num5;
            var num9 = rotation.X * num;
            var num8 = rotation.Y * num5;
            var num7 = rotation.Y * num;
            var num6 = rotation.Z * num;
            var num24 = (1 - num8) - num6;
            var num23 = num10 - num12;
            var num22 = num9 + num13;
            var num21 = num10 + num12;
            var num20 = (1 - num11) - num6;
            var num19 = num7 - num14;
            var num18 = num9 - num13;
            var num17 = num7 + num14;
            var num16 = (1 - num11) - num8;
            var x = plane.Normal.X;
            var y = plane.Normal.Y;
            var z = plane.Normal.Z;
            this.Normal.X = ((x * num24) + (y * num23)) + (z * num22);
            this.Normal.Y = ((x * num21) + (y * num20)) + (z * num19);
            this.Normal.Z = ((x * num18) + (y * num17)) + (z * num16);
            this.D = plane.D;
            return this;
        }
        Dot(value) {
            return ((((this.Normal.X * value.X) + (this.Normal.Y * value.Y)) + (this.Normal.Z * value.Z)) + (this.D * value.W));
        }
        DotCoordinate(value) {
            return ((((this.Normal.X * value.X) + (this.Normal.Y * value.Y)) + (this.Normal.Z * value.Z)) + this.D);
        }
        DotNormal(value) {
            return (((this.Normal.X * value.X) + (this.Normal.Y * value.Y)) + (this.Normal.Z * value.Z));
        }
        IntersectsBoundingBox(box) {
            var vector = new U1.Vector3();
            var vector2 = new U1.Vector3();
            vector2.X = (this.Normal.X >= 0) ? box.Min.X : box.Max.X;
            vector2.Y = (this.Normal.Y >= 0) ? box.Min.Y : box.Max.Y;
            vector2.Z = (this.Normal.Z >= 0) ? box.Min.Z : box.Max.Z;
            vector.X = (this.Normal.X >= 0) ? box.Max.X : box.Min.X;
            vector.Y = (this.Normal.Y >= 0) ? box.Max.Y : box.Min.Y;
            vector.Z = (this.Normal.Z >= 0) ? box.Max.Z : box.Min.Z;
            var num = ((this.Normal.X * vector2.X) + (this.Normal.Y * vector2.Y)) + (this.Normal.Z * vector2.Z);
            if ((num + this.D) > 0) {
                return U1.PlaneIntersectionTypeEnum.Front;
            }
            num = ((this.Normal.X * vector.X) + (this.Normal.Y * vector.Y)) + (this.Normal.Z * vector.Z);
            if ((num + this.D) < 0) {
                return U1.PlaneIntersectionTypeEnum.Back;
            }
            return U1.PlaneIntersectionTypeEnum.Intersecting;
        }
        IntersectsLine(position, direction, isectRes) {
            var result = null;
            var num2 = ((this.Normal.X * direction.X) + (this.Normal.Y * direction.Y)) + (this.Normal.Z * direction.Z);
            if (Math.abs(num2) < 1E-05) {
                result = null;
            }
            else {
                var num3 = ((this.Normal.X * position.X) + (this.Normal.Y * position.Y)) + (this.Normal.Z * position.Z);
                var num = (-this.D - num3) / num2;
                if (-1E-05 < num && num < 1E-05)
                    result = 0;
                else
                    result = num;
            }
            if (isectRes != null) {
                isectRes.SetScaleAdd(position, result, direction);
            }
            return result;
        }
        Intersects(frustum) {
            if (null == frustum) {
                throw "NullNotAllowed";
            }
            return frustum.IntersectsPlane(this);
        }
        IntersectsBoundingSphere(sphere) {
            var num2 = ((sphere.Center.X * this.Normal.X) + (sphere.Center.Y * this.Normal.Y)) + (sphere.Center.Z * this.Normal.Z);
            var num = num2 + this.D;
            if (num > sphere.Radius) {
                return U1.PlaneIntersectionTypeEnum.Front;
            }
            if (num < -sphere.Radius) {
                return U1.PlaneIntersectionTypeEnum.Back;
            }
            return U1.PlaneIntersectionTypeEnum.Intersecting;
        }
        static FromPointNormal(point, normal, result = null) {
            var n = Plane[".fpn.n."] || (Plane[".fpn.n."] = new U1.Vector3());
            n.CopyFrom(normal).Normalize();
            var d = U1.Vector3.Dot(point, n);
            if (result == null)
                result = new Plane();
            result.Set(n.X, n.Y, n.Z, -d);
            return result;
        }
        SetFromPointNormal(point, normal) {
            this.Normal.SetNormalize(normal);
            var d = U1.Vector3.Dot(point, this.Normal);
            this.D = -d;
            return this;
        }
        static FromTriangle(point1, point2, point3, result = null) {
            var num10 = point2.X - point1.X;
            var num9 = point2.Y - point1.Y;
            var num8 = point2.Z - point1.Z;
            var num7 = point3.X - point1.X;
            var num6 = point3.Y - point1.Y;
            var num5 = point3.Z - point1.Z;
            var num4 = (num9 * num5) - (num8 * num6);
            var num3 = (num8 * num7) - (num10 * num5);
            var num2 = (num10 * num6) - (num9 * num7);
            var num11 = ((num4 * num4) + (num3 * num3)) + (num2 * num2);
            var num = 1 / (Math.sqrt(num11));
            var X = num4 * num;
            var Y = num3 * num;
            var Z = num2 * num;
            var D = -(((X * point1.X) + (Y * point1.Y)) + (Z * point1.Z));
            if (result == null)
                result = new Plane();
            return result.Set(X, Y, Z, D);
        }
        SetFromTriangle(point1, point2, point3) {
            var num10 = point2.X - point1.X;
            var num9 = point2.Y - point1.Y;
            var num8 = point2.Z - point1.Z;
            var num7 = point3.X - point1.X;
            var num6 = point3.Y - point1.Y;
            var num5 = point3.Z - point1.Z;
            var num4 = (num9 * num5) - (num8 * num6);
            var num3 = (num8 * num7) - (num10 * num5);
            var num2 = (num10 * num6) - (num9 * num7);
            var num11 = ((num4 * num4) + (num3 * num3)) + (num2 * num2);
            var num = 1 / (Math.sqrt(num11));
            this.Normal.X = num4 * num;
            this.Normal.Y = num3 * num;
            this.Normal.Z = num2 * num;
            this.D = -(((this.Normal.X * point1.X) + (this.Normal.Y * point1.Y)) + (this.Normal.Z * point1.Z));
            return this;
        }
    }
    U1.Plane = Plane;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Quaternion {
        constructor(x = 0, y = 0, z = 0, w = 1) {
            this.X = x;
            this.Y = y;
            this.Z = z;
            this.W = w;
        }
        ConvertFromStr(value) {
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            this.X = items.length > 0 ? items[0] : 0;
            this.Y = items.length > 1 ? items[1] : 0;
            this.Z = items.length > 2 ? items[2] : 0;
            this.W = items.length > 3 ? items[3] : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this.X, this.Y, this.Z, this.W);
        }
        Equals(other) {
            return this.X == other.X && this.Y == other.Y && this.Z == other.Z && this.W == other.W;
        }
        CopyFrom(other) {
            this.X = other.X;
            this.Y = other.Y;
            this.Z = other.Z;
            this.W = other.W;
        }
        Clone() {
            var copy = new Quaternion();
            copy.CopyFrom(this);
            return copy;
        }
        static get Identity() {
            return new Quaternion();
        }
        LengthSquareduared() {
            return ((((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z)) + (this.W * this.W));
        }
        Length() {
            var num = (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z)) + (this.W * this.W);
            return (Math.sqrt(num));
        }
        Normalize() {
            var num2 = (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z)) + (this.W * this.W);
            var num = 1 / (Math.sqrt(num2));
            this.X *= num;
            this.Y *= num;
            this.Z *= num;
            this.W *= num;
        }
        static Normalize(quaternion, result = null) {
            if (result == null)
                result = new Quaternion();
            var num2 = (((quaternion.X * quaternion.X) + (quaternion.Y * quaternion.Y)) + (quaternion.Z * quaternion.Z)) + (quaternion.W * quaternion.W);
            var num = 1 / (Math.sqrt(num2));
            result.X = quaternion.X * num;
            result.Y = quaternion.Y * num;
            result.Z = quaternion.Z * num;
            result.W = quaternion.W * num;
            return result;
        }
        SetNormalize(quaternion) {
            var num2 = (((quaternion.X * quaternion.X) + (quaternion.Y * quaternion.Y)) + (quaternion.Z * quaternion.Z)) + (quaternion.W * quaternion.W);
            var num = 1 / (Math.sqrt(num2));
            this.X = quaternion.X * num;
            this.Y = quaternion.Y * num;
            this.Z = quaternion.Z * num;
            this.W = quaternion.W * num;
            return this;
        }
        Conjugate() {
            this.X = -this.X;
            this.Y = -this.Y;
            this.Z = -this.Z;
        }
        static Conjugate(value, result = null) {
            if (result == null)
                result = new Quaternion();
            result.X = -value.X;
            result.Y = -value.Y;
            result.Z = -value.Z;
            result.W = value.W;
            return result;
        }
        SetConjugate(value) {
            this.X = -value.X;
            this.Y = -value.Y;
            this.Z = -value.Z;
            this.W = value.W;
            return this;
        }
        static Inverse(quaternion, result = null) {
            if (result == null)
                result = new Quaternion();
            var num2 = (((quaternion.X * quaternion.X) + (quaternion.Y * quaternion.Y)) + (quaternion.Z * quaternion.Z)) + (quaternion.W * quaternion.W);
            var num = 1 / num2;
            result.X = -quaternion.X * num;
            result.Y = -quaternion.Y * num;
            result.Z = -quaternion.Z * num;
            result.W = quaternion.W * num;
            return result;
        }
        SetInverse(quaternion) {
            var num2 = (((quaternion.X * quaternion.X) + (quaternion.Y * quaternion.Y)) + (quaternion.Z * quaternion.Z)) + (quaternion.W * quaternion.W);
            var num = 1 / num2;
            this.X = -quaternion.X * num;
            this.Y = -quaternion.Y * num;
            this.Z = -quaternion.Z * num;
            this.W = quaternion.W * num;
            return this;
        }
        Inverse() {
            var num2 = (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z)) + (this.W * this.W);
            var num = 1 / num2;
            this.X = -this.X * num;
            this.Y = -this.Y * num;
            this.Z = -this.Z * num;
            this.W = this.W * num;
            return this;
        }
        static CreateFromAxisAngle(axis, angle, result = null) {
            if (result == null)
                result = new Quaternion();
            var num2 = angle * 0.5;
            var num = Math.sin(num2);
            var num3 = Math.cos(num2);
            result.X = axis.X * num;
            result.Y = axis.Y * num;
            result.Z = axis.Z * num;
            result.W = num3;
            return result;
        }
        SetCreateFromAxisAngle(axis, angle) {
            var num2 = angle * 0.5;
            var num = Math.sin(num2);
            var num3 = Math.cos(num2);
            this.X = axis.X * num;
            this.Y = axis.Y * num;
            this.Z = axis.Z * num;
            this.W = num3;
            return this;
        }
        static CreateFromYawPitchRoll(yaw, pitch, roll, result = null) {
            if (result == null)
                result = new Quaternion();
            var num9 = roll * 0.5;
            var num6 = Math.sin(num9);
            var num5 = Math.cos(num9);
            var num8 = pitch * 0.5;
            var num4 = Math.sin(num8);
            var num3 = Math.cos(num8);
            var num7 = yaw * 0.5;
            var num2 = Math.sin(num7);
            var num = Math.cos(num7);
            result.X = ((num * num4) * num5) + ((num2 * num3) * num6);
            result.Y = ((num2 * num3) * num5) - ((num * num4) * num6);
            result.Z = ((num * num3) * num6) - ((num2 * num4) * num5);
            result.W = ((num * num3) * num5) + ((num2 * num4) * num6);
            return result;
        }
        SetCreateFromYawPitchRoll(yaw, pitch, roll) {
            var num9 = roll * 0.5;
            var num6 = Math.sin(num9);
            var num5 = Math.cos(num9);
            var num8 = pitch * 0.5;
            var num4 = Math.sin(num8);
            var num3 = Math.cos(num8);
            var num7 = yaw * 0.5;
            var num2 = Math.sin(num7);
            var num = Math.cos(num7);
            this.X = ((num * num4) * num5) + ((num2 * num3) * num6);
            this.Y = ((num2 * num3) * num5) - ((num * num4) * num6);
            this.Z = ((num * num3) * num6) - ((num2 * num4) * num5);
            this.W = ((num * num3) * num5) + ((num2 * num4) * num6);
            return this;
        }
        static CreateFromRotationMatrix(matrix, result = null) {
            var num8 = (matrix.M11 + matrix.M22) + matrix.M33;
            if (result == null)
                result = new Quaternion();
            if (num8 > 0) {
                var num = Math.sqrt((num8 + 1));
                result.W = num * 0.5;
                num = 0.5 / num;
                result.X = (matrix.M23 - matrix.M32) * num;
                result.Y = (matrix.M31 - matrix.M13) * num;
                result.Z = (matrix.M12 - matrix.M21) * num;
                return result;
            }
            if ((matrix.M11 >= matrix.M22) && (matrix.M11 >= matrix.M33)) {
                var num7 = Math.sqrt((((1 + matrix.M11) - matrix.M22) - matrix.M33));
                var num4 = 0.5 / num7;
                result.X = 0.5 * num7;
                result.Y = (matrix.M12 + matrix.M21) * num4;
                result.Z = (matrix.M13 + matrix.M31) * num4;
                result.W = (matrix.M23 - matrix.M32) * num4;
                return result;
            }
            if (matrix.M22 > matrix.M33) {
                var num6 = Math.sqrt((((1 + matrix.M22) - matrix.M11) - matrix.M33));
                var num3 = 0.5 / num6;
                result.X = (matrix.M21 + matrix.M12) * num3;
                result.Y = 0.5 * num6;
                result.Z = (matrix.M32 + matrix.M23) * num3;
                result.W = (matrix.M31 - matrix.M13) * num3;
                return result;
            }
            var num5 = Math.sqrt((((1 + matrix.M33) - matrix.M11) - matrix.M22));
            var num2 = 0.5 / num5;
            result.X = (matrix.M31 + matrix.M13) * num2;
            result.Y = (matrix.M32 + matrix.M23) * num2;
            result.Z = 0.5 * num5;
            result.W = (matrix.M12 - matrix.M21) * num2;
            return result;
        }
        SetCreateFromRotationMatrix(matrix) {
            var num8 = (matrix.M11 + matrix.M22) + matrix.M33;
            if (num8 > 0) {
                var num = Math.sqrt((num8 + 1));
                this.W = num * 0.5;
                num = 0.5 / num;
                this.X = (matrix.M23 - matrix.M32) * num;
                this.Y = (matrix.M31 - matrix.M13) * num;
                this.Z = (matrix.M12 - matrix.M21) * num;
                return this;
            }
            if ((matrix.M11 >= matrix.M22) && (matrix.M11 >= matrix.M33)) {
                var num7 = Math.sqrt((((1 + matrix.M11) - matrix.M22) - matrix.M33));
                var num4 = 0.5 / num7;
                this.X = 0.5 * num7;
                this.Y = (matrix.M12 + matrix.M21) * num4;
                this.Z = (matrix.M13 + matrix.M31) * num4;
                this.W = (matrix.M23 - matrix.M32) * num4;
                return this;
            }
            if (matrix.M22 > matrix.M33) {
                var num6 = Math.sqrt((((1 + matrix.M22) - matrix.M11) - matrix.M33));
                var num3 = 0.5 / num6;
                this.X = (matrix.M21 + matrix.M12) * num3;
                this.Y = 0.5 * num6;
                this.Z = (matrix.M32 + matrix.M23) * num3;
                this.W = (matrix.M31 - matrix.M13) * num3;
                return this;
            }
            var num5 = Math.sqrt((((1 + matrix.M33) - matrix.M11) - matrix.M22));
            var num2 = 0.5 / num5;
            this.X = (matrix.M31 + matrix.M13) * num2;
            this.Y = (matrix.M32 + matrix.M23) * num2;
            this.Z = 0.5 * num5;
            this.W = (matrix.M12 - matrix.M21) * num2;
            return this;
        }
        static Dot(quaternion1, quaternion2) {
            return quaternion1.X * quaternion2.X
                + quaternion1.Y * quaternion2.Y
                + quaternion1.Z * quaternion2.Z
                + quaternion1.W * quaternion2.W;
        }
        static Slerp(quaternion1, quaternion2, amount, result = null) {
            var num2;
            var num3;
            if (result == null)
                result = new Quaternion();
            var num = amount;
            var num4 = (((quaternion1.X * quaternion2.X) + (quaternion1.Y * quaternion2.Y)) + (quaternion1.Z * quaternion2.Z)) + (quaternion1.W * quaternion2.W);
            var flag = false;
            if (num4 < 0) {
                flag = true;
                num4 = -num4;
            }
            if (num4 > 0.999999) {
                num3 = 1 - num;
                num2 = flag ? -num : num;
            }
            else {
                var num5 = Math.acos(num4);
                var num6 = (1.0 / Math.sin(num5));
                num3 = (Math.sin(((1 - num) * num5))) * num6;
                num2 = flag ? ((-Math.sin((num * num5))) * num6) : ((Math.sin((num * num5))) * num6);
            }
            result.X = (num3 * quaternion1.X) + (num2 * quaternion2.X);
            result.Y = (num3 * quaternion1.Y) + (num2 * quaternion2.Y);
            result.Z = (num3 * quaternion1.Z) + (num2 * quaternion2.Z);
            result.W = (num3 * quaternion1.W) + (num2 * quaternion2.W);
            return result;
        }
        SetSlerp(quaternion1, quaternion2, amount) {
            var num2;
            var num3;
            var num = amount;
            var num4 = (((quaternion1.X * quaternion2.X) + (quaternion1.Y * quaternion2.Y)) + (quaternion1.Z * quaternion2.Z)) + (quaternion1.W * quaternion2.W);
            var flag = false;
            if (num4 < 0) {
                flag = true;
                num4 = -num4;
            }
            if (num4 > 0.999999) {
                num3 = 1 - num;
                num2 = flag ? -num : num;
            }
            else {
                var num5 = Math.acos(num4);
                var num6 = (1.0 / Math.sin(num5));
                num3 = (Math.sin(((1 - num) * num5))) * num6;
                num2 = flag ? ((-Math.sin((num * num5))) * num6) : ((Math.sin((num * num5))) * num6);
            }
            this.X = (num3 * quaternion1.X) + (num2 * quaternion2.X);
            this.Y = (num3 * quaternion1.Y) + (num2 * quaternion2.Y);
            this.Z = (num3 * quaternion1.Z) + (num2 * quaternion2.Z);
            this.W = (num3 * quaternion1.W) + (num2 * quaternion2.W);
            return this;
        }
        Slerp(quaternion2, amount) {
            var num2;
            var num3;
            var num = amount;
            var num4 = (((this.X * quaternion2.X) + (this.Y * quaternion2.Y)) + (this.Z * quaternion2.Z)) + (this.W * quaternion2.W);
            var flag = false;
            if (num4 < 0) {
                flag = true;
                num4 = -num4;
            }
            if (num4 > 0.999999) {
                num3 = 1 - num;
                num2 = flag ? -num : num;
            }
            else {
                var num5 = Math.acos(num4);
                var num6 = (1.0 / Math.sin(num5));
                num3 = (Math.sin(((1 - num) * num5))) * num6;
                num2 = flag ? ((-Math.sin((num * num5))) * num6) : ((Math.sin((num * num5))) * num6);
            }
            this.X = (num3 * this.X) + (num2 * quaternion2.X);
            this.Y = (num3 * this.Y) + (num2 * quaternion2.Y);
            this.Z = (num3 * this.Z) + (num2 * quaternion2.Z);
            this.W = (num3 * this.W) + (num2 * quaternion2.W);
            return this;
        }
        static Lerp(quaternion1, quaternion2, amount, result = null) {
            var num = amount;
            var num2 = 1 - num;
            if (result == null)
                result = new Quaternion();
            var num5 = (((quaternion1.X * quaternion2.X) + (quaternion1.Y * quaternion2.Y)) + (quaternion1.Z * quaternion2.Z)) + (quaternion1.W * quaternion2.W);
            if (num5 >= 0) {
                result.X = (num2 * quaternion1.X) + (num * quaternion2.X);
                result.Y = (num2 * quaternion1.Y) + (num * quaternion2.Y);
                result.Z = (num2 * quaternion1.Z) + (num * quaternion2.Z);
                result.W = (num2 * quaternion1.W) + (num * quaternion2.W);
            }
            else {
                result.X = (num2 * quaternion1.X) - (num * quaternion2.X);
                result.Y = (num2 * quaternion1.Y) - (num * quaternion2.Y);
                result.Z = (num2 * quaternion1.Z) - (num * quaternion2.Z);
                result.W = (num2 * quaternion1.W) - (num * quaternion2.W);
            }
            var num4 = (((result.X * result.X) + (result.Y * result.Y)) + (result.Z * result.Z)) + (result.W * result.W);
            var num3 = 1 / (Math.sqrt(num4));
            result.X *= num3;
            result.Y *= num3;
            result.Z *= num3;
            result.W *= num3;
            return result;
        }
        SetLerp(quaternion1, quaternion2, amount) {
            var num = amount;
            var num2 = 1 - num;
            var num5 = (((quaternion1.X * quaternion2.X) + (quaternion1.Y * quaternion2.Y)) + (quaternion1.Z * quaternion2.Z)) + (quaternion1.W * quaternion2.W);
            if (num5 >= 0) {
                this.X = (num2 * quaternion1.X) + (num * quaternion2.X);
                this.Y = (num2 * quaternion1.Y) + (num * quaternion2.Y);
                this.Z = (num2 * quaternion1.Z) + (num * quaternion2.Z);
                this.W = (num2 * quaternion1.W) + (num * quaternion2.W);
            }
            else {
                this.X = (num2 * quaternion1.X) - (num * quaternion2.X);
                this.Y = (num2 * quaternion1.Y) - (num * quaternion2.Y);
                this.Z = (num2 * quaternion1.Z) - (num * quaternion2.Z);
                this.W = (num2 * quaternion1.W) - (num * quaternion2.W);
            }
            var num4 = (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z)) + (this.W * this.W);
            var num3 = 1 / (Math.sqrt(num4));
            this.X *= num3;
            this.Y *= num3;
            this.Z *= num3;
            this.W *= num3;
            return this;
        }
        Lerp(quaternion2, amount) {
            var num = amount;
            var num2 = 1 - num;
            var num5 = (((this.X * quaternion2.X) + (this.Y * quaternion2.Y)) + (this.Z * quaternion2.Z)) + (this.W * quaternion2.W);
            if (num5 >= 0) {
                this.X = (num2 * this.X) + (num * quaternion2.X);
                this.Y = (num2 * this.Y) + (num * quaternion2.Y);
                this.Z = (num2 * this.Z) + (num * quaternion2.Z);
                this.W = (num2 * this.W) + (num * quaternion2.W);
            }
            else {
                this.X = (num2 * this.X) - (num * quaternion2.X);
                this.Y = (num2 * this.Y) - (num * quaternion2.Y);
                this.Z = (num2 * this.Z) - (num * quaternion2.Z);
                this.W = (num2 * this.W) - (num * quaternion2.W);
            }
            var num4 = (((this.X * this.X) + (this.Y * this.Y)) + (this.Z * this.Z)) + (this.W * this.W);
            var num3 = 1 / (Math.sqrt(num4));
            this.X *= num3;
            this.Y *= num3;
            this.Z *= num3;
            this.W *= num3;
            return this;
        }
        static Concatenate(value1, value2, result = null) {
            if (result == null)
                result = new Quaternion();
            var x = value2.X;
            var y = value2.Y;
            var z = value2.Z;
            var w = value2.W;
            var num4 = value1.X;
            var num3 = value1.Y;
            var num2 = value1.Z;
            var num = value1.W;
            var num12 = (y * num2) - (z * num3);
            var num11 = (z * num4) - (x * num2);
            var num10 = (x * num3) - (y * num4);
            var num9 = ((x * num4) + (y * num3)) + (z * num2);
            result.X = ((x * num) + (num4 * w)) + num12;
            result.Y = ((y * num) + (num3 * w)) + num11;
            result.Z = ((z * num) + (num2 * w)) + num10;
            result.W = (w * num) - num9;
            return result;
        }
        SetConcatenate(value1, value2) {
            var x = value2.X;
            var y = value2.Y;
            var z = value2.Z;
            var w = value2.W;
            var num4 = value1.X;
            var num3 = value1.Y;
            var num2 = value1.Z;
            var num = value1.W;
            var num12 = (y * num2) - (z * num3);
            var num11 = (z * num4) - (x * num2);
            var num10 = (x * num3) - (y * num4);
            var num9 = ((x * num4) + (y * num3)) + (z * num2);
            this.X = ((x * num) + (num4 * w)) + num12;
            this.Y = ((y * num) + (num3 * w)) + num11;
            this.Z = ((z * num) + (num2 * w)) + num10;
            this.W = (w * num) - num9;
            return this;
        }
        Concatenate(value2) {
            var x = value2.X;
            var y = value2.Y;
            var z = value2.Z;
            var w = value2.W;
            var num4 = this.X;
            var num3 = this.Y;
            var num2 = this.Z;
            var num = this.W;
            var num12 = (y * num2) - (z * num3);
            var num11 = (z * num4) - (x * num2);
            var num10 = (x * num3) - (y * num4);
            var num9 = ((x * num4) + (y * num3)) + (z * num2);
            this.X = ((x * num) + (num4 * w)) + num12;
            this.Y = ((y * num) + (num3 * w)) + num11;
            this.Z = ((z * num) + (num2 * w)) + num10;
            this.W = (w * num) - num9;
            return this;
        }
        static Negate(quaternion) {
            var quaternion2 = new Quaternion();
            quaternion2.X = -quaternion.X;
            quaternion2.Y = -quaternion.Y;
            quaternion2.Z = -quaternion.Z;
            quaternion2.W = -quaternion.W;
            return quaternion2;
        }
        SetNegate(quaternion) {
            this.X = -quaternion.X;
            this.Y = -quaternion.Y;
            this.Z = -quaternion.Z;
            this.W = -quaternion.W;
            return this;
        }
        Negate() {
            this.X = -this.X;
            this.Y = -this.Y;
            this.Z = -this.Z;
            this.W = -this.W;
            return this;
        }
        static Add(quaternion1, quaternion2, result = null) {
            if (result == null)
                result = new Quaternion();
            result.X = quaternion1.X + quaternion2.X;
            result.Y = quaternion1.Y + quaternion2.Y;
            result.Z = quaternion1.Z + quaternion2.Z;
            result.W = quaternion1.W + quaternion2.W;
            return result;
        }
        SetAdd(quaternion1, quaternion2) {
            this.X = quaternion1.X + quaternion2.X;
            this.Y = quaternion1.Y + quaternion2.Y;
            this.Z = quaternion1.Z + quaternion2.Z;
            this.W = quaternion1.W + quaternion2.W;
            return this;
        }
        Add(quaternion2) {
            this.X = this.X + quaternion2.X;
            this.Y = this.Y + quaternion2.Y;
            this.Z = this.Z + quaternion2.Z;
            this.W = this.W + quaternion2.W;
            return this;
        }
        static Subtract(quaternion1, quaternion2, result = null) {
            if (result == null)
                result = new Quaternion();
            result.X = quaternion1.X - quaternion2.X;
            result.Y = quaternion1.Y - quaternion2.Y;
            result.Z = quaternion1.Z - quaternion2.Z;
            result.W = quaternion1.W - quaternion2.W;
            return result;
        }
        SetSubtract(quaternion1, quaternion2) {
            this.X = quaternion1.X - quaternion2.X;
            this.Y = quaternion1.Y - quaternion2.Y;
            this.Z = quaternion1.Z - quaternion2.Z;
            this.W = quaternion1.W - quaternion2.W;
            return this;
        }
        Subtract(quaternion2) {
            this.X = this.X - quaternion2.X;
            this.Y = this.Y - quaternion2.Y;
            this.Z = this.Z - quaternion2.Z;
            this.W = this.W - quaternion2.W;
            return this;
        }
        static Multiply(quaternion1, quaternion2, result = null) {
            if (result == null)
                result = new Quaternion();
            var x = quaternion1.X;
            var y = quaternion1.Y;
            var z = quaternion1.Z;
            var w = quaternion1.W;
            var num4 = quaternion2.X;
            var num3 = quaternion2.Y;
            var num2 = quaternion2.Z;
            var num = quaternion2.W;
            var num12 = (y * num2) - (z * num3);
            var num11 = (z * num4) - (x * num2);
            var num10 = (x * num3) - (y * num4);
            var num9 = ((x * num4) + (y * num3)) + (z * num2);
            result.X = ((x * num) + (num4 * w)) + num12;
            result.Y = ((y * num) + (num3 * w)) + num11;
            result.Z = ((z * num) + (num2 * w)) + num10;
            result.W = (w * num) - num9;
            return result;
        }
        SetMultiply(quaternion1, quaternion2) {
            var x = quaternion1.X;
            var y = quaternion1.Y;
            var z = quaternion1.Z;
            var w = quaternion1.W;
            var num4 = quaternion2.X;
            var num3 = quaternion2.Y;
            var num2 = quaternion2.Z;
            var num = quaternion2.W;
            var num12 = (y * num2) - (z * num3);
            var num11 = (z * num4) - (x * num2);
            var num10 = (x * num3) - (y * num4);
            var num9 = ((x * num4) + (y * num3)) + (z * num2);
            this.X = ((x * num) + (num4 * w)) + num12;
            this.Y = ((y * num) + (num3 * w)) + num11;
            this.Z = ((z * num) + (num2 * w)) + num10;
            this.W = (w * num) - num9;
            return this;
        }
        Multiply(quaternion2) {
            var x = this.X;
            var y = this.Y;
            var z = this.Z;
            var w = this.W;
            var num4 = quaternion2.X;
            var num3 = quaternion2.Y;
            var num2 = quaternion2.Z;
            var num = quaternion2.W;
            var num12 = (y * num2) - (z * num3);
            var num11 = (z * num4) - (x * num2);
            var num10 = (x * num3) - (y * num4);
            var num9 = ((x * num4) + (y * num3)) + (z * num2);
            this.X = ((x * num) + (num4 * w)) + num12;
            this.Y = ((y * num) + (num3 * w)) + num11;
            this.Z = ((z * num) + (num2 * w)) + num10;
            this.W = (w * num) - num9;
            return this;
        }
        static Scale(quaternion1, scaleFactor, result = null) {
            if (result == null)
                result = new Quaternion();
            result.X = quaternion1.X * scaleFactor;
            result.Y = quaternion1.Y * scaleFactor;
            result.Z = quaternion1.Z * scaleFactor;
            result.W = quaternion1.W * scaleFactor;
            return result;
        }
        SetScale(quaternion1, scaleFactor) {
            this.X = quaternion1.X * scaleFactor;
            this.Y = quaternion1.Y * scaleFactor;
            this.Z = quaternion1.Z * scaleFactor;
            this.W = quaternion1.W * scaleFactor;
            return this;
        }
        Scale(scaleFactor) {
            this.X = this.X * scaleFactor;
            this.Y = this.Y * scaleFactor;
            this.Z = this.Z * scaleFactor;
            this.W = this.W * scaleFactor;
            return this;
        }
        static Divide(quaternion1, quaternion2, result = null) {
            if (result == null)
                result = new Quaternion();
            var x = quaternion1.X;
            var y = quaternion1.Y;
            var z = quaternion1.Z;
            var w = quaternion1.W;
            var num14 = (((quaternion2.X * quaternion2.X) + (quaternion2.Y * quaternion2.Y)) + (quaternion2.Z * quaternion2.Z)) + (quaternion2.W * quaternion2.W);
            var num5 = 1 / num14;
            var num4 = -quaternion2.X * num5;
            var num3 = -quaternion2.Y * num5;
            var num2 = -quaternion2.Z * num5;
            var num = quaternion2.W * num5;
            var num13 = (y * num2) - (z * num3);
            var num12 = (z * num4) - (x * num2);
            var num11 = (x * num3) - (y * num4);
            var num10 = ((x * num4) + (y * num3)) + (z * num2);
            result.X = ((x * num) + (num4 * w)) + num13;
            result.Y = ((y * num) + (num3 * w)) + num12;
            result.Z = ((z * num) + (num2 * w)) + num11;
            result.W = (w * num) - num10;
            return result;
        }
        SetDivide(quaternion1, quaternion2) {
            var x = quaternion1.X;
            var y = quaternion1.Y;
            var z = quaternion1.Z;
            var w = quaternion1.W;
            var num14 = (((quaternion2.X * quaternion2.X) + (quaternion2.Y * quaternion2.Y)) + (quaternion2.Z * quaternion2.Z)) + (quaternion2.W * quaternion2.W);
            var num5 = 1 / num14;
            var num4 = -quaternion2.X * num5;
            var num3 = -quaternion2.Y * num5;
            var num2 = -quaternion2.Z * num5;
            var num = quaternion2.W * num5;
            var num13 = (y * num2) - (z * num3);
            var num12 = (z * num4) - (x * num2);
            var num11 = (x * num3) - (y * num4);
            var num10 = ((x * num4) + (y * num3)) + (z * num2);
            this.X = ((x * num) + (num4 * w)) + num13;
            this.Y = ((y * num) + (num3 * w)) + num12;
            this.Z = ((z * num) + (num2 * w)) + num11;
            this.W = (w * num) - num10;
            return this;
        }
        Divide(quaternion2) {
            var x = this.X;
            var y = this.Y;
            var z = this.Z;
            var w = this.W;
            var num14 = (((quaternion2.X * quaternion2.X) + (quaternion2.Y * quaternion2.Y)) + (quaternion2.Z * quaternion2.Z)) + (quaternion2.W * quaternion2.W);
            var num5 = 1 / num14;
            var num4 = -quaternion2.X * num5;
            var num3 = -quaternion2.Y * num5;
            var num2 = -quaternion2.Z * num5;
            var num = quaternion2.W * num5;
            var num13 = (y * num2) - (z * num3);
            var num12 = (z * num4) - (x * num2);
            var num11 = (x * num3) - (y * num4);
            var num10 = ((x * num4) + (y * num3)) + (z * num2);
            this.X = ((x * num) + (num4 * w)) + num13;
            this.Y = ((y * num) + (num3 * w)) + num12;
            this.Z = ((z * num) + (num2 * w)) + num11;
            this.W = (w * num) - num10;
            return this;
        }
        ToAxisAngle1(result) {
            var q1 = this;
            var x, y, z;
            if (q1.W > 1)
                q1.Normalize();
            var angle = 2 * Math.acos(q1.W);
            var s = Math.sqrt(1 - q1.W * q1.W);
            if (s < U1.PRECISION) {
                x = q1.X;
                y = q1.Y;
                z = q1.Z;
            }
            else {
                x = q1.X / s;
                y = q1.Y / s;
                z = q1.Z / s;
            }
            if (result == null)
                result = { Axis: U1.Vector3.Zero, Angle: 0 };
            result.Axis.Set(x, y, z);
            result.Angle = angle;
            return result;
        }
        ToAxisAngle(result) {
            var q1 = this;
            var x, y, z;
            if (q1.W > 1)
                q1.Normalize();
            var angle = 2 * Math.acos(q1.W);
            var s = Math.sqrt(1 - q1.W * q1.W);
            if (s < U1.PRECISION) {
                x = q1.X;
                y = q1.Y;
                z = q1.Z;
            }
            else {
                x = q1.X / s;
                y = q1.Y / s;
                z = q1.Z / s;
            }
            if (result == null)
                result = new U1.Vector4();
            result.Set(x, y, z, angle);
            return result;
        }
    }
    U1.Quaternion = Quaternion;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var CGAL;
    (function (CGAL) {
        let BOUNDED_SIDES;
        (function (BOUNDED_SIDES) {
            BOUNDED_SIDES[BOUNDED_SIDES["ON_BOUNDED_SIDE"] = 0] = "ON_BOUNDED_SIDE";
            BOUNDED_SIDES[BOUNDED_SIDES["ON_BOUNDARY"] = 1] = "ON_BOUNDARY";
            BOUNDED_SIDES[BOUNDED_SIDES["ON_UNBOUNDED_SIDE"] = 2] = "ON_UNBOUNDED_SIDE";
        })(BOUNDED_SIDES = CGAL.BOUNDED_SIDES || (CGAL.BOUNDED_SIDES = {}));
        let ORIENTED_SIDES;
        (function (ORIENTED_SIDES) {
            ORIENTED_SIDES[ORIENTED_SIDES["ON_NEGATIVE_SIDE"] = 0] = "ON_NEGATIVE_SIDE";
            ORIENTED_SIDES[ORIENTED_SIDES["ON_ORIENTED_BOUNDARY"] = 1] = "ON_ORIENTED_BOUNDARY";
            ORIENTED_SIDES[ORIENTED_SIDES["ON_POSITIVE_SIDE"] = 2] = "ON_POSITIVE_SIDE";
        })(ORIENTED_SIDES = CGAL.ORIENTED_SIDES || (CGAL.ORIENTED_SIDES = {}));
        class Util {
            static DoInersect(polygon0, polygon1) {
                var min0 = Util.Min(polygon0);
                var max0 = Util.Max(polygon0);
                var min1 = Util.Min(polygon1);
                var max1 = Util.Max(polygon1);
                if ((max0.X < min1.X - U1.PRECISION) ||
                    (max0.Y < min1.Y - U1.PRECISION) ||
                    (min0.X > max1.X + U1.PRECISION) ||
                    (min0.Y > max1.Y + U1.PRECISION))
                    return false;
                var pi = polygon0.length - 1;
                var isect = {};
                for (var i = 0; i < polygon0.length; i++) {
                    var pj = polygon1.length - 1;
                    for (var j = 0; j < polygon1.length; j++) {
                        if (Util.IntersectSegmentSegment(polygon0[pi], polygon0[i], polygon1[pj], polygon1[j], isect)) {
                            return true;
                        }
                        pj = j;
                    }
                    pi = i;
                }
                return false;
            }
            static DoInersectLoops(loopsA, loopsB) {
                for (var i = 0; i < loopsA.length; i++) {
                    for (var j = 0; j < loopsB.length; j++) {
                        if (Util.DoInersect(loopsA[i], loopsB[j]))
                            return true;
                    }
                }
                return false;
            }
            static Min(points) {
                var min = points[0].Clone();
                for (var i = 1; i < points.length; i++) {
                    min.X = min.X <= points[i].X ? min.X : points[i].X;
                    min.Y = min.Y <= points[i].Y ? min.Y : points[i].Y;
                }
                return min;
            }
            static Max(points) {
                var max = points[0].Clone();
                for (var i = 1; i < points.length; i++) {
                    max.X = max.X >= points[i].X ? max.X : points[i].X;
                    max.Y = max.Y >= points[i].Y ? max.Y : points[i].Y;
                }
                return max;
            }
            static IntersectSegmentSegment(s0, s1, t0, t1, result) {
                result.s = result.t = 0;
                if ((s0.X < t0.X && s0.X < t1.X && s1.X < t0.X && s1.X < t1.X) ||
                    (s0.X > t0.X && s0.X > t1.X && s1.X > t0.X && s1.X > t1.X))
                    return false;
                if ((s0.Y < t0.Y && s0.Y < t1.Y && s1.Y < t0.Y && s1.Y < t1.Y) ||
                    (s0.Y > t0.Y && s0.Y > t1.Y && s1.Y > t0.Y && s1.Y > t1.Y))
                    return false;
                var sd = U1.Vector2.Subtract(s1, s0);
                var td = U1.Vector2.Subtract(t1, t0);
                var isect = U1.GeometryHelper2.CrossLineLine(s0, sd, t0, td);
                if (isect == null) {
                    return false;
                }
                result.s = isect.s;
                result.t = isect.t;
                if (result.s < 0 || result.s > 1 || result.t < 0 || result.t > 1)
                    return false;
                return true;
            }
            static IntersectSegmentPoint(s0, s1, p, result) {
                if (result == null)
                    result = { s: 0 };
                var slen = U1.Vector2.Distance(s0, s1);
                var dir = U1.Vector2.Normalize(U1.Vector2.Subtract(s1, s0));
                var left = dir.Left;
                var v = U1.Vector2.Subtract(p, s0);
                result.s = 0;
                var l = U1.Vector2.Dot(left, v);
                if (l * l > U1.PRECISION)
                    return false;
                result.s = U1.Vector2.Dot(dir, v);
                if (result.s < -U1.PRECISION)
                    return false;
                result.s = U1.Vector2.Dot(dir.Negate(), U1.Vector2.Subtract(p, s1));
                if (result.s < -U1.PRECISION)
                    return false;
                return true;
            }
            static DistanceSquared(s0, s1, p) {
                var slen = U1.Vector2.DistanceSquared(s0, s1);
                var dir = U1.Vector2.Normalize(U1.Vector2.Subtract(s1, s0));
                var l = U1.Vector2.Dot(dir, U1.Vector2.Subtract(p, s0));
                var ll = l * l;
                if (l <= 0)
                    return U1.Vector2.DistanceSquared(s0, p);
                if (ll >= slen)
                    return U1.Vector2.DistanceSquared(s1, p);
                return U1.Vector2.DistanceSquared(s0, p) - ll;
            }
            static CollectPolygonWithHoles(loops, isIntersection = false) {
                var boundaries = new Array();
                var holes = new Array();
                var result = new Array();
                for (var loop of loops) {
                    var pgon = new U1.CGAL.Polygon2(loop);
                    if (pgon.IsCCW()) {
                        var isAdded = false;
                        for (var i = boundaries.length - 1; i >= 0; i--) {
                            var oldpgon = boundaries[i];
                            if (oldpgon == null)
                                continue;
                            var p0 = pgon.Points[0];
                            var p1 = oldpgon.Points[0];
                            if (!isIntersection) {
                                if (oldpgon.BoundedSide(p0) == BOUNDED_SIDES.ON_BOUNDED_SIDE) {
                                    isAdded = true;
                                    break;
                                }
                                else {
                                    if (pgon.BoundedSide(p1) == BOUNDED_SIDES.ON_BOUNDED_SIDE) {
                                        boundaries.splice(i, 1);
                                    }
                                }
                            }
                            else {
                                if (oldpgon.BoundedSide(p0) == BOUNDED_SIDES.ON_BOUNDED_SIDE) {
                                    boundaries.splice(i, 1);
                                }
                                else {
                                    if (pgon.BoundedSide(p1) == BOUNDED_SIDES.ON_BOUNDED_SIDE) {
                                        isAdded = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (!isAdded)
                            boundaries.push(pgon);
                    }
                    else {
                        holes.push(pgon);
                    }
                }
                for (var ib = 0; ib < boundaries.length; ib++) {
                    if (boundaries[ib] == null)
                        continue;
                    var pwh = new PolygonWithHoles2();
                    pwh.OuterBoundary = boundaries[ib];
                    result.push(pwh);
                }
                for (var ih = 0; ih < holes.length; ih++) {
                    var hole = holes[ih];
                    for (var ir = 0; ir < result.length; ir++) {
                        var pwh = result[ir];
                        if (pwh.OuterBoundary.BoundedSide(hole.Points[0]) == BOUNDED_SIDES.ON_BOUNDED_SIDE) {
                            pwh.AddHole(hole);
                            break;
                        }
                    }
                }
                return result;
            }
        }
        Util.PRECISION = 0.00001;
        CGAL.Util = Util;
        class Polygon2 {
            constructor(arg = null) {
                if (arg instanceof Polygon2) {
                    this.m_points = arg.Points.map(o_ => o_.Clone());
                }
                else if (arg != null && arg instanceof Array) {
                    this.m_points = arg.map(o_ => o_.Clone());
                }
            }
            get Count() {
                return this.m_points == null ? 0 : this.m_points.length;
            }
            Add(pt) {
                this.m_points.push(pt);
            }
            AddRange(collection) {
                this.m_points.concat(collection);
            }
            Area() {
                var j = this.m_points.length - 1;
                var area = 0.0;
                for (var i = 0; i < this.m_points.length; i++) {
                    area += (this.m_points[j].X + this.m_points[i].X) * (this.m_points[j].Y - this.m_points[i].Y);
                    j = i;
                }
                return Math.abs(area / 2);
            }
            Length() {
                var len = 0.0;
                var j = this.m_points.length - 1;
                for (var i = 0; i < this.m_points.length; i++) {
                    len += U1.Vector2.Distance(this.m_points[j], this.m_points[i]);
                    j = i;
                }
                return len;
            }
            Clear() {
                this.m_points = null;
            }
            HasOnNegativeSide(pt) {
                return this.OrientedSide(pt) == ORIENTED_SIDES.ON_NEGATIVE_SIDE;
            }
            HasOnPositiveSide(pt) {
                return this.OrientedSide(pt) == ORIENTED_SIDES.ON_POSITIVE_SIDE;
            }
            static DoIntersect(A, B) {
                return A.DoIntersect(B);
            }
            BoundedSide(pt) {
                var left = this.LeftVertex();
                if (pt.X < left.X - Util.PRECISION)
                    return BOUNDED_SIDES.ON_UNBOUNDED_SIDE;
                var right = this.RightVertex();
                if (pt.X > right.X + Util.PRECISION)
                    return BOUNDED_SIDES.ON_UNBOUNDED_SIDE;
                var top = this.TopVertex();
                if (pt.Y > top.Y + Util.PRECISION)
                    return BOUNDED_SIDES.ON_UNBOUNDED_SIDE;
                var bottom = this.BottomVertex();
                if (pt.Y < bottom.Y - Util.PRECISION)
                    return BOUNDED_SIDES.ON_UNBOUNDED_SIDE;
                var rayS = pt;
                var rayE = Polygon2.tmp_v0;
                rayE.Set((right.X - left.X) * 2, 0);
                rayE.Add(pt);
                var start = 0;
                for (var i = 0; i < this.m_points.length; i++) {
                    if (Util.DistanceSquared(rayS, rayE, this.m_points[i]) > Util.PRECISION)
                        break;
                    start = i;
                }
                var rayLeft = Polygon2.tmp_v1;
                rayLeft.SetSubtract(rayE, rayS);
                rayLeft.LeftRef(rayLeft);
                var SV = null;
                var isectCount = 0;
                var out_s_t = {};
                var tv0 = Polygon2.tmp_v2;
                var tv1 = Polygon2.tmp_v3;
                for (var i = 0; i < this.m_points.length; i++) {
                    var ci = (i + start) % this.m_points.length;
                    var ni = (i + 1 + start) % this.m_points.length;
                    var v0 = this.m_points[ci];
                    var v1 = this.m_points[ni];
                    if (Util.DistanceSquared(v0, v1, pt) < Util.PRECISION)
                        return BOUNDED_SIDES.ON_BOUNDARY;
                    while (Util.DistanceSquared(rayS, rayE, v1) < Util.PRECISION) {
                        if (U1.Vector2.EpsilonEquals(rayS, v1))
                            return BOUNDED_SIDES.ON_BOUNDARY;
                        if (SV == null)
                            SV = v0;
                        i++;
                        ci = (i + start) % this.m_points.length;
                        ni = (i + 1 + start) % this.m_points.length;
                        v0 = this.m_points[ci];
                        v1 = this.m_points[ni];
                    }
                    if (SV != null) {
                        tv0.SetSubtract(SV, rayS);
                        tv1.SetSubtract(v1, rayS);
                        if (U1.Vector2.Dot(rayLeft, tv0) *
                            U1.Vector2.Dot(rayLeft, tv1) < 0)
                            isectCount++;
                        SV = null;
                        continue;
                    }
                    if (Util.IntersectSegmentSegment(rayS, rayE, v0, v1, out_s_t) && out_s_t.s > Util.PRECISION) {
                        isectCount++;
                    }
                }
                if (isectCount % 2 == 0)
                    return BOUNDED_SIDES.ON_UNBOUNDED_SIDE;
                return BOUNDED_SIDES.ON_BOUNDED_SIDE;
            }
            OrientedSide(pt) {
                var boundedSide = this.BoundedSide(pt);
                if (boundedSide == BOUNDED_SIDES.ON_BOUNDARY)
                    return ORIENTED_SIDES.ON_ORIENTED_BOUNDARY;
                if (boundedSide == BOUNDED_SIDES.ON_BOUNDED_SIDE)
                    return this.IsCCW() ? ORIENTED_SIDES.ON_POSITIVE_SIDE : ORIENTED_SIDES.ON_NEGATIVE_SIDE;
                return this.IsCCW() ? ORIENTED_SIDES.ON_NEGATIVE_SIDE : ORIENTED_SIDES.ON_POSITIVE_SIDE;
            }
            HasOnBoundary(pt) {
                return this.BoundedSide(pt) == BOUNDED_SIDES.ON_BOUNDARY;
            }
            HasOnBoundedSide(pt) {
                return this.BoundedSide(pt) == BOUNDED_SIDES.ON_BOUNDED_SIDE;
            }
            HasOnUnboundedSide(pt) {
                return this.BoundedSide(pt) == BOUNDED_SIDES.ON_UNBOUNDED_SIDE;
            }
            IsCCW() {
                if (this.IsEmpty())
                    return true;
                var idx = this.LeftVertexIndex();
                var i0 = (idx - 1 + this.m_points.length) % this.m_points.length;
                var i1 = idx;
                var i2 = (idx + 1) % this.m_points.length;
                var v0 = Polygon2.tmp_v0;
                var v1 = Polygon2.tmp_v1;
                v0.SetSubtract(this.m_points[i0], this.m_points[i1]);
                v1.SetSubtract(this.m_points[i2], this.m_points[i1]);
                v1.LeftRef(v1);
                return U1.Vector2.Dot(v1, v0) > 0;
            }
            IsConvex() {
                if (this.IsEmpty())
                    return true;
                var pi = this.m_points.length - 1;
                var result = 0;
                var v0 = Polygon2.tmp_v0;
                var v1 = Polygon2.tmp_v1;
                for (var i = 0; i < this.m_points.length - 1; pi = i, i++) {
                    var ni = (i + 1) % this.m_points.length;
                    v0.SetSubtract(this.m_points[i], this.m_points[pi]);
                    v1.SetSubtract(this.m_points[ni], this.m_points[i]);
                    v0.LeftRef(v0);
                    var leftDot = U1.Vector2.Dot(v0, v1);
                    if (leftDot > Util.PRECISION) {
                        if (result == -1)
                            return false;
                        result = 1;
                    }
                    else if (leftDot < -Util.PRECISION) {
                        if (result == 1)
                            return false;
                        result = -1;
                    }
                }
                return true;
            }
            IsCW() {
                return !this.IsCCW();
            }
            IsEmpty() {
                return this.m_points == null || this.m_points.length == 0;
            }
            IsSimple() {
                if (this.IsEmpty())
                    return false;
                var out_s_t = {};
                var points = this.m_points;
                var v0 = Polygon2.tmp_v0;
                var v1 = Polygon2.tmp_v1;
                for (var i = 0; i < points.length; i++) {
                    var ni = (i + 1) % points.length;
                    for (var j = i + 1; j < points.length; j++) {
                        var nj = (j + 1) % points.length;
                        if (ni == j || i == nj) {
                            var dot = U1.Vector2.Dot(v0.SetSubtract(points[ni], points[i]).Normalize(), v1.SetSubtract(points[nj], points[j]).Normalize());
                            if (dot < -1 + Util.PRECISION)
                                return false;
                            continue;
                        }
                        if (Util.IntersectSegmentSegment(points[i], points[ni], points[j], points[nj], out_s_t))
                            return false;
                    }
                }
                return true;
            }
            Reverse() {
                if (this.IsEmpty())
                    return;
                var p_len = this.m_points.length;
                var hl = (p_len - 1) / 2;
                for (var i = 1; i <= hl; i++) {
                    var t = this.m_points[i];
                    this.m_points[i] = this.m_points[p_len - i];
                    this.m_points[p_len - i] = t;
                }
            }
            LeftVertex() {
                if (this.IsEmpty())
                    return null;
                return this.m_points[this.LeftVertexIndex()];
            }
            RightVertex() {
                if (this.IsEmpty())
                    return null;
                return this.m_points[this.RightVertexIndex()];
            }
            TopVertex() {
                if (this.IsEmpty())
                    return null;
                return this.m_points[this.TopVertexIndex()];
            }
            BottomVertex() {
                if (this.IsEmpty())
                    return null;
                return this.m_points[this.BottomVertexIndex()];
            }
            LeftVertexIndex() {
                var resultIdx = 0;
                var result = this.m_points[0];
                for (var i = 1; i < this.m_points.length; i++) {
                    if (this.m_points[i].X < result.X) {
                        result = this.m_points[i];
                        resultIdx = i;
                    }
                    else if (this.m_points[i].X == result.X && this.m_points[i].Y < result.Y) {
                        result = this.m_points[i];
                        resultIdx = i;
                    }
                }
                return resultIdx;
            }
            RightVertexIndex() {
                var indx = 0;
                var result = this.m_points[0];
                for (var i = 1; i < this.m_points.length; i++) {
                    if (this.m_points[i].X > result.X) {
                        result = this.m_points[i];
                        indx = i;
                    }
                    else if (this.m_points[i].X == result.X && this.m_points[i].Y > result.Y) {
                        result = this.m_points[i];
                        indx = i;
                    }
                }
                return indx;
            }
            TopVertexIndex() {
                var indx = 0;
                var result = this.m_points[0];
                for (var i = 1; i < this.m_points.length; i++) {
                    if (this.m_points[i].Y > result.Y) {
                        result = this.m_points[i];
                        indx = i;
                    }
                    else if (this.m_points[i].Y == result.Y && this.m_points[i].X > result.X) {
                        result = this.m_points[i];
                        indx = i;
                    }
                }
                return indx;
            }
            BottomVertexIndex() {
                var indx = 0;
                var result = this.m_points[0];
                for (var i = 1; i < this.m_points.length; i++) {
                    if (this.m_points[i].Y < result.Y) {
                        result = this.m_points[i];
                        indx = i;
                    }
                    else if (this.m_points[i].Y == result.Y && this.m_points[i].X < result.X) {
                        result = this.m_points[i];
                        indx = i;
                    }
                }
                return indx;
            }
            get Points() {
                return this.m_points;
            }
            set Points(points) {
                {
                    this.m_points = points;
                }
            }
            DoIntersectEdge(pgon) {
                return Util.DoInersect(this.Points, pgon.Points);
            }
            DoIntersect(pgon) {
                if (this.Count < 3)
                    return false;
                if (this.DoIntersectEdge(pgon))
                    return true;
                if (this.HasOnBoundedSide(pgon.m_points[0]))
                    return true;
                if (pgon.HasOnBoundedSide(this.m_points[0]))
                    return true;
                return false;
            }
            GetPolygonList() {
                return new Array(this.Points);
            }
            GetAllPolygons() {
                return new Array(this);
            }
            GetNotIsectSegs(points) {
                var isect_map = {};
                var result = new Array();
                var pc = points.length;
                var out_s_t = { s: 0, t: 0 };
                for (var i = 0; i < pc; i++) {
                    var ni = (i + 1);
                    if (ni == pc)
                        ni = 0;
                    var isIsect = false;
                    for (var k = 0; k < pc; k++) {
                        var j = (k + i) % pc;
                        var nj = (j + 1);
                        if (nj == pc)
                            nj = 0;
                        if (Util.IntersectSegmentSegment(points[i], points[ni], points[j], points[nj], out_s_t)) {
                            if (out_s_t.s > Util.PRECISION &&
                                out_s_t.s < 1 - Util.PRECISION &&
                                out_s_t.t > Util.PRECISION &&
                                out_s_t.t < 1 - Util.PRECISION) {
                                isIsect = true;
                                break;
                            }
                        }
                    }
                    isect_map[i] = isIsect;
                    if (i == 0 && !isIsect)
                        result.push(i);
                    if (i > 0 && isect_map[i - 1] && !isIsect)
                        result.push(i);
                }
                return result;
            }
            static GetArea(points) {
                var j = points.length - 1;
                var area = 0.0;
                for (var i = 0; i < points.length; i++) {
                    area += (points[j].X + points[i].X) * (points[j].Y - points[i].Y);
                    j = i;
                }
                return Math.abs(area / 2);
            }
            MakeSimple() {
                if (this.Points == null || this.Points.length == 0 || this.IsSimple())
                    return;
                this.Points = VTX2.GetSimplePath(this.Points);
            }
            static Reverse(m_points) {
                var p_len = m_points.length;
                var hl = (p_len - 1) / 2;
                for (var i = 1; i <= hl; i++) {
                    var t = m_points[i];
                    m_points[i] = m_points[p_len - i];
                    m_points[p_len - i] = t;
                }
            }
        }
        Polygon2.tmp_v0 = U1.Vector2.Zero;
        Polygon2.tmp_v1 = U1.Vector2.Zero;
        Polygon2.tmp_v2 = U1.Vector2.Zero;
        Polygon2.tmp_v3 = U1.Vector2.Zero;
        CGAL.Polygon2 = Polygon2;
        class PolygonSet2 {
            constructor(param = null) {
                this.PolygonsWithHoles = new Array();
                if (param != null && param instanceof Polygon2) {
                    var pgon = param;
                    this.PolygonsWithHoles.push(new PolygonWithHoles2(pgon));
                }
            }
            get NumberOfPolygonsWithHoles() {
                return this.PolygonsWithHoles == null ? 0 : this.PolygonsWithHoles.length;
            }
            get IsEmpty() {
                return this.PolygonsWithHoles == null || this.PolygonsWithHoles.length == 0;
            }
            HasOnNegativeSide(pt) {
                if (this.IsEmpty)
                    return true;
                for (var pwh of this.PolygonsWithHoles)
                    if (!pwh.HasOnNegativeSide(pt))
                        return false;
                return true;
            }
            HasOnPositiveSide(pt) {
                if (this.IsEmpty)
                    return true;
                for (var pwh of this.PolygonsWithHoles)
                    if (pwh.HasOnPositiveSide(pt))
                        return true;
                return false;
            }
            Area() {
                var area = 0.0;
                for (var hwp of this.PolygonsWithHoles) {
                    area += hwp.Area();
                }
                return area;
            }
            Clear() {
                this.PolygonsWithHoles = null;
            }
            Insert(polygon) {
                if (polygon == null)
                    return;
                if (this.PolygonsWithHoles == null)
                    this.PolygonsWithHoles = new Array();
                if (polygon instanceof Polygon2)
                    this.PolygonsWithHoles.push(new PolygonWithHoles2(polygon));
                else if (polygon instanceof PolygonWithHoles2)
                    this.PolygonsWithHoles.push(polygon);
            }
            DoIntersect(pgon) {
                if (this.PolygonsWithHoles == null)
                    return false;
                if (pgon instanceof Polygon2) {
                    for (var pwh of this.PolygonsWithHoles)
                        if (pwh.DoIntersect(pgon))
                            return true;
                    var msg = "" + pgon.Points.length + "points";
                }
                else if (pgon instanceof PolygonWithHoles2) {
                    for (var pwh of this.PolygonsWithHoles)
                        if (pwh.DoIntersect(pgon))
                            return true;
                }
                else if (pgon instanceof PolygonSet2) {
                    var pset = pgon;
                    for (var a of this.PolygonsWithHoles) {
                        for (var b of pset.PolygonsWithHoles) {
                            if (a.DoIntersect(b))
                                return true;
                        }
                    }
                }
                return false;
            }
            Intersection(pgons) {
                var pwhs = this.DoIntersection(pgons.GetPolygonList());
                var npwhs = new Array();
                for (var i = 0; i < pwhs.length; i++) {
                    var pwh = pwhs[i];
                    var p = pwh.OuterBoundary.Points[0];
                    if (pgons.HasOnNegativeSide(p) || this.HasOnNegativeSide(p))
                        continue;
                    npwhs.push(pwh);
                }
                this.PolygonsWithHoles = npwhs;
            }
            DoIntersection(b) {
                var loopsA = this.GetPolygonList();
                var loopsB = b;
                var loopsAll = new Array();
                var loopFinder = new CGAL.LoopFinder();
                loopFinder.AddLoops(loopsA, false);
                loopFinder.AddLoops(loopsB, false);
                loopsAll = loopFinder.GetLoops(true);
                return Util.CollectPolygonWithHoles(loopsAll, true);
            }
            Join(polygons) {
                this.DoJoin(polygons.GetPolygonList());
            }
            DoJoin(b) {
                var loopsA = this.GetPolygonList();
                var loopsB = b;
                var loopsAll = new Array();
                if (Util.DoInersectLoops(loopsA, loopsB)) {
                    var loopFinder = new CGAL.LoopFinder();
                    loopFinder.AddLoops(loopsA, false);
                    loopFinder.AddLoops(loopsB, false);
                    loopsAll = loopFinder.GetLoops(false);
                }
                else {
                    loopsAll = loopsA.concat(loopsB);
                }
                this.PolygonsWithHoles = Util.CollectPolygonWithHoles(loopsAll);
            }
            Difference(polygons) {
                this.DoDifference(polygons.GetPolygonList());
            }
            DoDifference(b) {
                var loopsA = this.GetPolygonList();
                var loopsB = b;
                var loopsAll = new Array();
                if (Util.DoInersectLoops(loopsA, loopsB)) {
                    var loopFinder = new CGAL.LoopFinder();
                    loopFinder.AddLoops(loopsA, false);
                    loopFinder.AddLoops(loopsB, true);
                    loopsAll = loopFinder.GetLoops(true);
                }
                else {
                    loopsAll = loopsA;
                    for (var pgon of loopsB) {
                        pgon.reverse();
                        loopsAll.push(pgon);
                    }
                }
                this.PolygonsWithHoles = Util.CollectPolygonWithHoles(loopsAll);
            }
            IntersectLine(line) {
                var loopsA = this.GetPolygonList();
                var xAxis = line.Direction;
                var yAxis = xAxis.Left;
                var side = 0;
                var v = U1.Vector2.Zero;
                for (var loop of loopsA) {
                    for (var i = 0; i < loop.length; i++) {
                        v.SetSubtract(loop[i], line.Position);
                        var d = U1.Vector2.Dot(v, yAxis);
                        if (d < 0.00001 && d > -0.00001)
                            continue;
                        var side_i = d > 0 ? 1 : 2;
                        if (side == 0) {
                            side = side_i;
                            continue;
                        }
                        if (side_i != side)
                            return true;
                    }
                }
                return false;
            }
            Slice(line, res) {
                res.left = this;
                res.right = null;
                if (!this.IntersectLine(line))
                    return false;
                var loopsA = this.GetPolygonList();
                var xAxis = line.Direction;
                var min = Number.MAX_VALUE;
                var max = Number.MIN_VALUE;
                var v = U1.Vector2.Zero;
                for (var loop of loopsA) {
                    for (var i = 0; i < loop.length; i++) {
                        v.SetSubtract(loop[i], line.Position);
                        var d = U1.Vector2.Dot(xAxis, v);
                        min = Math.min(d, min);
                        max = Math.max(d, max);
                    }
                }
                var p0 = U1.Vector2.ScaleAdd(line.Position, (min - 10), xAxis);
                var p1 = U1.Vector2.ScaleAdd(line.Position, (max + 10), xAxis);
                var loopsAll = new Array();
                var loopFinder = new CGAL.LoopFinder();
                loopFinder.AddLoops(loopsA, false);
                loopFinder.AddPath(new Array(p0, p1), false);
                loopsAll = loopFinder.GetLoops(true);
                res.left = new PolygonSet2();
                res.left.PolygonsWithHoles = Util.CollectPolygonWithHoles(loopsAll);
                loopFinder = new CGAL.LoopFinder();
                loopFinder.AddLoops(loopsA, false);
                loopFinder.AddPath(new Array(p0, p1), true);
                loopsAll = loopFinder.GetLoops(true);
                res.right = new PolygonSet2();
                res.right.PolygonsWithHoles = Util.CollectPolygonWithHoles(loopsAll);
                return true;
            }
            GetPolygonList() {
                var result = new Array();
                if (this.IsEmpty)
                    return result;
                for (var pwh of this.PolygonsWithHoles) {
                    for (var pgon of pwh.GetPolygonList()) {
                        result.push(pgon);
                    }
                }
                return result;
            }
            GetAllPolygons() {
                var result = new Array();
                if (this.IsEmpty)
                    return result;
                for (var pwh of this.PolygonsWithHoles) {
                    for (var pgon of pwh.GetAllPolygons()) {
                        result.push(pgon);
                    }
                }
                return result;
            }
        }
        CGAL.PolygonSet2 = PolygonSet2;
        class PolygonWithHoles2 {
            constructor(param = null) {
                if (param != null && param instanceof Polygon2) {
                    var pgon = param;
                    this.OuterBoundary = pgon;
                }
            }
            get OuterBoundary() {
                return this.m_outerBoundary;
            }
            set OuterBoundary(value) {
                this.m_outerBoundary = value;
                if (this.m_outerBoundary.IsCW())
                    this.m_outerBoundary.Reverse();
            }
            HasOnNegativeSide(pt) {
                if (!this.IsUnbounded)
                    if (this.OuterBoundary.OrientedSide(pt) == ORIENTED_SIDES.ON_NEGATIVE_SIDE)
                        return true;
                if (this.HasHoles) {
                    for (var hole of this.Holes) {
                        if (hole.OrientedSide(pt) == ORIENTED_SIDES.ON_NEGATIVE_SIDE)
                            return true;
                    }
                }
                return false;
            }
            HasOnPositiveSide(pt) {
                if (!this.IsUnbounded)
                    if (this.OuterBoundary.OrientedSide(pt) != ORIENTED_SIDES.ON_POSITIVE_SIDE)
                        return false;
                if (this.HasHoles) {
                    for (var hole of this.Holes) {
                        if (hole.OrientedSide(pt) != ORIENTED_SIDES.ON_POSITIVE_SIDE)
                            return false;
                    }
                }
                return true;
            }
            Area() {
                var area = 0.0;
                if (this.OuterBoundary != null)
                    area = this.OuterBoundary.Area();
                if (this.Holes != null) {
                    for (var hole of this.Holes) {
                        area -= hole.Area();
                    }
                }
                return area;
            }
            get Holes() {
                return this.m_holes;
            }
            set Holes(value) {
                this.m_holes = value;
                if (this.m_holes != null) {
                    for (var i = 0; i < this.m_holes.length; i++) {
                        if (this.m_holes[i].IsCCW())
                            this.m_holes[i].Reverse();
                    }
                }
            }
            get HasHoles() {
                return this.Holes != null && this.Holes.length > 0;
            }
            get IsUnbounded() {
                return this.OuterBoundary == null;
            }
            Clear() {
                this.OuterBoundary = null;
                this.Holes = null;
            }
            AddHole(pgn_hole) {
                if (this.m_holes == null)
                    this.m_holes = new Array();
                if (pgn_hole.IsCCW()) {
                    pgn_hole.Reverse();
                }
                this.m_holes.push(pgn_hole);
            }
            EraseHole(pgn_hole) {
                if (this.m_holes == null)
                    return;
                var holes = new Array();
                for (var i = 0; i < this.m_holes.length; i++) {
                    if (this.m_holes[i] == pgn_hole)
                        continue;
                    holes.push(this.m_holes[i]);
                }
                this.m_holes = holes;
            }
            get PolygonsAll() {
                var result = new Array();
                if (this.OuterBoundary != null)
                    result.push(this.OuterBoundary);
                if (this.HasHoles) {
                    for (var i = 0; i < this.m_holes.length; i++) {
                        result.push(this.m_holes[i]);
                    }
                }
                return result;
            }
            DoIntersect(B) {
                var A = this;
                if (this.IsUnbounded)
                    return false;
                if (B instanceof Polygon2) {
                    if (B.HasOnBoundedSide(A.OuterBoundary.Points[0]))
                        return true;
                    if (A.OuterBoundary.DoIntersectEdge(B))
                        return true;
                    if (this.HasHoles) {
                        for (var hole of this.Holes) {
                            if (hole.DoIntersectEdge(B))
                                return true;
                        }
                    }
                    if (A.OuterBoundary.HasOnUnboundedSide(B.Points[0]))
                        return false;
                    if (this.HasHoles) {
                        for (var hole of this.Holes) {
                            if (hole.HasOnBoundedSide(B.Points[0]))
                                return false;
                        }
                    }
                }
                else if (B instanceof PolygonWithHoles2) {
                    for (var a of this.PolygonsAll) {
                        for (var b of B.PolygonsAll)
                            if (a.DoIntersectEdge(b))
                                return true;
                    }
                    if (A.OuterBoundary.HasOnBoundedSide(B.OuterBoundary.Points[0])) {
                        if (this.HasHoles) {
                            for (var hole of this.Holes)
                                if (hole.HasOnBoundedSide(B.OuterBoundary.Points[0]))
                                    return false;
                        }
                        return true;
                    }
                    if (B.OuterBoundary.HasOnBoundedSide(A.OuterBoundary.Points[0])) {
                        if (B.HasHoles) {
                            for (var hole of B.Holes)
                                if (hole.HasOnBoundedSide(B.OuterBoundary.Points[0]))
                                    return false;
                        }
                        return true;
                    }
                }
                return true;
            }
            GetPolygonList() {
                var result = new Array();
                if (this.OuterBoundary != null)
                    result.push(this.OuterBoundary.Points);
                if (this.HasHoles) {
                    for (var hole of this.Holes) {
                        result.push(hole.Points);
                    }
                }
                ;
                return result;
            }
            GetAllPolygons() {
                var result = new Array();
                if (!this.IsUnbounded)
                    result.push(this.OuterBoundary);
                if (this.HasHoles) {
                    for (var hole of this.Holes) {
                        result.push(hole);
                    }
                }
                return result;
            }
        }
        CGAL.PolygonWithHoles2 = PolygonWithHoles2;
        class VTX2 {
            constructor() {
                this.Next = new Array();
            }
            AddNext(next) {
                if (this == next || this.Next.indexOf(next) >= 0)
                    return;
                this.Next.push(next);
            }
            GetNext(prev, turnLeft) {
                if (this.Next.length == 1)
                    return this.Next[0];
                var backward = U1.Vector2.Subtract(prev.P, this.P);
                var sorted = this.Next.sort((a_, b_) => {
                    var a_ang = U1.GeometryHelper2.AngleCCW(backward, U1.Vector2.Subtract(a_.P, this.P));
                    var b_ang = U1.GeometryHelper2.AngleCCW(backward, U1.Vector2.Subtract(b_.P, this.P));
                    if (turnLeft) {
                        a_ang *= -1;
                        b_ang *= -1;
                    }
                    return a_ang < b_ang ? -1 : (a_ang > b_ang) ? 1 : 0;
                });
                return sorted[0];
            }
            toString() {
                return `${this.P.X},${this.P.Y}`;
            }
            static GetSimplePath(points) {
                var vlist = new Array();
                var pc = points.length;
                for (var i = 0; i < pc; i++) {
                    var ni = (i + 1);
                    if (ni == pc)
                        ni = 0;
                    var isect_locs = new Array();
                    isect_locs.push(0);
                    isect_locs.push(1);
                    var out_s_t = { s: 0, t: 0 };
                    for (var j = 0; j < pc; j++) {
                        var nj = (j + 1);
                        if (nj == pc)
                            nj = 0;
                        if (i == j || ni == j || nj == i)
                            continue;
                        if (Util.IntersectSegmentSegment(points[i], points[ni], points[j], points[nj], out_s_t)) {
                            if (out_s_t.s > Util.PRECISION &&
                                out_s_t.s < 1 - Util.PRECISION &&
                                out_s_t.t > Util.PRECISION &&
                                out_s_t.t < 1 - Util.PRECISION) {
                                isect_locs.push(out_s_t.s);
                            }
                        }
                    }
                    isect_locs.sort();
                    var vtxs = new Array();
                    var prev = vlist[vlist.length - 1];
                    for (var loc of isect_locs) {
                        var p = U1.Vector2.ScaleAdd(points[i], loc, U1.Vector2.Subtract(points[ni], points[i]));
                        var vtx = null;
                        for (var v of vlist) {
                            if (U1.Vector2.DistanceSquared(p, v.P) < Util.PRECISION) {
                                vtx = v;
                                break;
                            }
                        }
                        if (vtx == null) {
                            vtx = new VTX2();
                            vtx.P = p;
                            vlist.push(vtx);
                        }
                        if (prev != null && prev != vtx)
                            prev.AddNext(vtx);
                        prev = vtx;
                    }
                }
                var last_v = vlist[vlist.length - 1];
                last_v.AddNext(vlist[0]);
                return VTX2.GetPath(vlist);
            }
            static GetPath(vlist) {
                var points = null;
                var area = 0.0;
                for (var st of vlist) {
                    if (st.Next.length < 2)
                        continue;
                    for (var next of st.Next) {
                        var isLeft = true;
                        for (var i = 0; i < 2; i++) {
                            var t_points = VTX2.GetPathPoints(st, next, isLeft);
                            if (t_points != null) {
                                var t_area = Polygon2.GetArea(t_points);
                                if (area < t_area) {
                                    area = t_area;
                                    points = t_points;
                                }
                            }
                            isLeft = false;
                        }
                    }
                }
                return points;
            }
            static GetPathPoints(start, next, turnLeft) {
                var result = new Array();
                result.push(start.P);
                var visited = new Array();
                visited.push(start);
                var cur = next;
                var prv = start;
                while (cur != start) {
                    if (visited.indexOf(cur) >= 0)
                        return null;
                    visited.push(cur);
                    result.push(cur.P);
                    next = cur.GetNext(prv, turnLeft);
                    prv = cur;
                    cur = next;
                }
                return result;
            }
        }
    })(CGAL = U1.CGAL || (U1.CGAL = {}));
})(U1 || (U1 = {}));
(function (U1) {
    var CGAL;
    (function (CGAL) {
        class Vtx {
            constructor(param = null) {
                this.EList = new Array();
                if (param != null) {
                    this.P = param;
                }
            }
            AddEdge(edge) {
                this.EList.push(edge);
            }
            RemoveEdge(edge) {
                var idx = this.EList.indexOf(edge);
                if (idx >= 0)
                    this.EList = this.EList.slice(idx, 1);
            }
            static SquaredDistanceSegmentPoint(start, end, p, res) {
                if (res == null)
                    res = { s: 0 };
                var es = U1.Vector2.Subtract(end, start);
                var ps = U1.Vector2.Subtract(p, start);
                var es2 = U1.Vector2.Dot(es, es);
                var ps2 = U1.Vector2.Dot(ps, ps);
                var l = U1.Vector2.Dot(es, ps);
                var bb = (l * l) / es2;
                res.s = (Math.sqrt(bb / es2));
                if (U1.Vector2.Dot(es, ps) < 0)
                    res.s = -res.s;
                return ps2 - bb;
            }
            static IntersectSegmentPoint(start, end, p) {
                if (U1.Vector2.DistanceSquared(start, p) < Vtx.SQUARD_DISTANCE)
                    return true;
                if (U1.Vector2.DistanceSquared(end, p) < Vtx.SQUARD_DISTANCE)
                    return true;
                var dist = Vtx.SquaredDistanceSegmentPoint(start, end, p, Vtx.res_s_t);
                if (Vtx.res_s_t.s < 0 || Vtx.res_s_t.s > 1)
                    return false;
                return dist < Vtx.SQUARD_DISTANCE;
            }
            toString() {
                return `${this.P.X},${this.P.Y}`;
            }
        }
        Vtx.DISTANCE = 0.01;
        Vtx.SQUARD_DISTANCE = 0.0001;
        Vtx.res_s_t = { s: 0, t: 0 };
        class Edge {
            get Start() {
                return this.m_start;
            }
            set Start(value) {
                if (this.m_start == value)
                    return;
                if (this.m_start != null)
                    this.m_start.RemoveEdge(this);
                this.m_start = value;
                if (this.m_start != null)
                    this.m_start.AddEdge(this);
            }
            get End() {
                return this.m_end;
            }
            set End(value) {
                if (this.m_end == value)
                    return;
                this.m_end = value;
                if (this.m_end == value)
                    return;
            }
            get Dir() {
                return U1.Vector2.Subtract(this.End.P, this.Start.P).Normalize();
            }
            IntersectPoint(p) {
                return Vtx.IntersectSegmentPoint(this.m_start.P, this.m_end.P, p);
            }
            IntersectSegment(start, end, res) {
                if (res == null)
                    res = { p: U1.Vector2.Zero };
                var line0 = Edge.t_line0;
                var line1 = Edge.t_line1;
                line0.Position.CopyFrom(start);
                line0.Direction.SetSubtract(end, start);
                line1.Position.CopyFrom(this.Start.P);
                line1.Direction.SetSubtract(this.End.P, this.Start.P);
                var st = U1.GeometryHelper2.CrossLineLine(line0.Position, line0.Direction, line1.Position, line1.Direction);
                if (st != null) {
                    if (st.s < 0 || st.s > 1 || st.t < 0 || st.t > 1)
                        return false;
                    res.p.SetScaleAdd(line0.Position, st.s, line0.Direction);
                    return true;
                }
                return false;
            }
            NextEdge(inward) {
                var dir = this.Dir.Negate();
                var edges = new Array();
                for (var e of this.End.EList) {
                    if (e.End != this.Start) {
                        edges.push(e);
                    }
                }
                if (edges.length == 0)
                    return null;
                edges = edges.sort((a_, b_) => {
                    var a_ang = U1.GeometryHelper2.AngleCCW(dir, a_.Dir);
                    var b_ang = U1.GeometryHelper2.AngleCCW(dir, b_.Dir);
                    return (a_ang < b_ang) ? -1 : (a_ang > b_ang ? 1 : 0);
                });
                if (inward)
                    return edges[edges.length - 1];
                else
                    return edges[0];
            }
            toString() {
                return `(${this.m_start.P.X},${this.m_start.P.Y})-(${this.m_end.P.X},${this.m_end.P.Y}) `;
            }
        }
        Edge.res_p = { p: U1.Vector2.Zero };
        Edge.tv0 = U1.Vector2.Zero;
        Edge.t_line0 = new U1.Line2();
        Edge.t_line1 = new U1.Line2();
        Edge.res_s_t = { s: 0, t: 0 };
        class LoopFinder {
            constructor() {
                this.VLIST = new Array();
                this.ELIST = new Array();
            }
            AddVtx(p) {
                var v = this.GetVtx(p);
                if (v == null) {
                    var crossEdge = this.GetCrossEdge(p);
                    if (crossEdge != null) {
                        v = this.Split(crossEdge, p, false);
                    }
                    else {
                        v = new Vtx(p);
                        this.VLIST.push(v);
                    }
                }
                return v;
            }
            GetVtx(p) {
                for (var v of this.VLIST) {
                    if (U1.Vector2.DistanceSquared(p, v.P) < Vtx.SQUARD_DISTANCE)
                        return v;
                }
                return null;
            }
            AddEdge(s, e) {
                this.AddVtx(s);
                this.AddVtx(e);
                var elist = this.ELIST.slice();
                var crossp = LoopFinder.res_p.p;
                for (var edg of elist) {
                    if (edg.IntersectSegment(s, e, LoopFinder.res_p)) {
                        if (U1.Vector2.DistanceSquared(crossp, edg.Start.P) < Vtx.SQUARD_DISTANCE
                            || U1.Vector2.DistanceSquared(crossp, edg.End.P) < Vtx.SQUARD_DISTANCE)
                            continue;
                        this.Split(edg, crossp, true);
                    }
                }
                var vs = this.GetVTXsOnSement(s, e);
                for (var i = 1; i < vs.length; i++) {
                    this.InsertEdge(vs[i - 1], vs[i]);
                }
            }
            GetVTXsOnSement(start, end) {
                var result = new Array();
                for (var v of this.VLIST) {
                    if (!Vtx.IntersectSegmentPoint(start, end, v.P))
                        continue;
                    result.push(v);
                }
                result.sort((a_, b_) => {
                    var a_l = U1.Vector2.DistanceSquared(start, a_.P);
                    var b_l = U1.Vector2.DistanceSquared(start, b_.P);
                    if (a_l < b_l)
                        return -1;
                    if (a_l > b_l)
                        return 1;
                    return 0;
                });
                return result;
            }
            InsertEdge(start, end) {
                if (start == end)
                    return null;
                for (var e of this.ELIST) {
                    if (e.Start === start && e.End === end) {
                        return e;
                    }
                }
                var edg = new Edge();
                edg.Start = start;
                edg.End = end;
                this.ELIST.push(edg);
                return edg;
            }
            Split(edge, p, newPoint) {
                var v = this.GetVtx(p);
                if (v == null) {
                    v = new Vtx(p.Clone());
                    v.IsNew = newPoint;
                    this.VLIST.push(v);
                }
                var nedg = new Edge();
                nedg.Start = v;
                nedg.End = edge.End;
                nedg.IsNew = true;
                edge.End = v;
                this.ELIST.push(nedg);
                return v;
            }
            GetCrossEdge(p) {
                for (var edge of this.ELIST) {
                    if (edge.IntersectPoint(p))
                        return edge;
                }
                return null;
            }
            AddLoop(path, isReverse) {
                if (isReverse)
                    CGAL.Polygon2.Reverse(path);
                var pi = path.length - 1;
                for (var i = 0; i < path.length; i++) {
                    this.AddEdge(path[pi], path[i]);
                    pi = i;
                }
            }
            AddPath(path, isReverse) {
                if (isReverse)
                    path.reverse();
                var pi = 0;
                for (var i = 1; i < path.length; i++) {
                    this.AddEdge(path[pi], path[i]);
                    pi = i;
                }
            }
            AddLoops(loops, isReverse) {
                for (var loop of loops) {
                    this.AddLoop(loop, isReverse);
                }
            }
            GetLoops(inward) {
                var result = new Array();
                while (true) {
                    var startEdge = null;
                    for (var e_ of this.ELIST) {
                        if (!e_.IsVisited && !e_.Start.IsNew) {
                            startEdge = e_;
                            break;
                        }
                    }
                    if (startEdge == null)
                        break;
                    startEdge.IsVisited = true;
                    var visitedVtxis = new Array(startEdge.Start, startEdge.End);
                    var visitedESet = new Array(startEdge);
                    var strVtx = startEdge.Start;
                    var curVtx = startEdge.End;
                    var curEdg = startEdge;
                    while (true) {
                        var nextEdg = curEdg.NextEdge(inward);
                        if (nextEdg == null) {
                            break;
                        }
                        if (visitedESet.indexOf(nextEdg) >= 0) {
                            while (visitedVtxis[0] != nextEdg.Start) {
                                visitedVtxis.splice(0, 1);
                            }
                            visitedVtxis.splice(visitedVtxis.length - 1, 1);
                            var loop = new Array();
                            for (var vt of visitedVtxis) {
                                loop.push(vt.P);
                            }
                            result.push(loop);
                            break;
                        }
                        else if (nextEdg.IsVisited) {
                            break;
                        }
                        nextEdg.IsVisited = true;
                        visitedVtxis.push(nextEdg.End);
                        visitedESet.push(nextEdg);
                        curEdg = nextEdg;
                    }
                }
                return result;
            }
        }
        LoopFinder.res_p = { p: U1.Vector2.Zero };
        CGAL.LoopFinder = LoopFinder;
    })(CGAL = U1.CGAL || (U1.CGAL = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Triangulations;
    (function (Triangulations) {
        var Polygon2 = U1.CGAL.Polygon2;
        class Vtx {
            constructor() {
                this.ELsit = new Array();
                this.Left0 = new U1.Vector2();
                this.Left1 = new U1.Vector2();
                this.BiSect = new U1.Vector2();
            }
            Init() {
                var v = Vtx.tmp;
                v.SetSubtract(this.P, this.Prev.P).Normalize().LeftRef(this.Left0);
                v.SetSubtract(this.Next.P, this.P).Normalize().LeftRef(this.Left1);
                this.BiSect.SetAdd(this.Left0, this.Left1).Normalize();
            }
            IsBoundedSide(pt) {
                var v = Vtx.tmp;
                v.SetSubtract(pt, this.P);
                if (U1.Vector2.Dot(this.Left0, v) > 0 && U1.Vector2.Dot(this.BiSect.Left, v) >= 0)
                    return true;
                if (U1.Vector2.Dot(this.Left1, v) > 0 && U1.Vector2.Dot(this.BiSect.Right, v) >= 0)
                    return true;
                return false;
            }
            toString() {
                return "#" + this.ID + "(" + this.P.X + "," + this.P.Y + ")";
            }
        }
        Vtx.tmp = U1.Vector2.Zero;
        Triangulations.Vtx = Vtx;
        class Edge {
            IntersectSegment(p0, p1) {
                if (this.V0 == p0 || this.V0 == p1 || this.V1 == p0 || this.V1 == p1)
                    return true;
                var s = 0.0;
                var t = 0.0;
                var t0 = p0.P;
                var t1 = p1.P;
                var s0 = this.V0.P;
                var s1 = this.V1.P;
                var a = (t1.X - t0.X) * (s0.Y - t0.Y) - (t1.Y - t0.Y) * (s0.X - t0.X);
                var b = (t1.Y - t0.Y) * (s1.X - s0.X) - (t1.X - t0.X) * (s1.Y - s0.Y);
                if (Math.abs(b) < U1.PRECISION)
                    return false;
                var c = (s1.X - s0.X) * (s0.Y - t0.Y) - (s1.Y - s0.Y) * (s0.X - t0.X);
                t = a / b;
                s = c / b;
                if (s < -U1.PRECISION || s >= 1 + U1.PRECISION)
                    return false;
                if (t < -U1.PRECISION || t >= 1 + U1.PRECISION)
                    return false;
                return true;
            }
            IntersectLine(t0, td) {
                var sd = Edge.tmp;
                var s0 = this.V0.P;
                sd.SetSubtract(this.V1.P, this.V0.P);
                var st = U1.GeometryHelper2.CrossLineLine(s0, sd, t0, td);
                if (st != null) {
                    if (st.s < 0 || st.s > 1)
                        return null;
                    return st.s;
                }
                return null;
            }
            toString() {
                return "[" + this.V0.toString() + "," + this.V1.toString() + "]";
            }
        }
        Edge.tmp = U1.Vector2.Zero;
        Triangulations.Edge = Edge;
        class Face {
            Area() {
                Face.tripoints[0] = this.V0.P;
                Face.tripoints[1] = this.V1.P;
                Face.tripoints[2] = this.V2.P;
                return Polygon2.GetArea(Face.tripoints);
            }
            toString() {
                return "(" + this.V0.ID + "," + this.V1.ID + "," + this.V2.ID + ")";
            }
        }
        Face.tripoints = new Array(3);
        Triangulations.Face = Face;
        class TDS {
            constructor() {
                this.VList = new Array();
                this.EList = new Array();
                this.FList = new Array();
                this.v_id = 0;
            }
            AddPolygon(polygon) {
                var vertics = new Array();
                var points;
                if (polygon instanceof Polygon2) {
                    points = polygon.Points;
                }
                else if (polygon instanceof Array) {
                    points = polygon;
                }
                for (var ci = points.length - 1; ci >= 0; ci--) {
                    var pi = ci - 1;
                    if (pi < 0)
                        pi = points.length - 1;
                    if (U1.Vector2.Distance(points[ci], points[pi]) < U1.PRECISION) {
                        points = points.filter(o_ => o_ != points[ci]);
                    }
                    else {
                        var cp = points[ci];
                        cp.X = Math.round(points[ci].X * 10000) / 10000;
                        cp.Y = Math.round(points[ci].Y * 10000) / 10000;
                        points[ci] = cp;
                    }
                }
                this.AddPolygonVtx(points
                    .map(o_ => {
                    var vtx = new Vtx();
                    vtx.P = o_;
                    vtx.ID = this.v_id++;
                    return vtx;
                }));
            }
            AddPolygonVtx(polygon) {
                for (var i = 0; i < polygon.length; i++) {
                    var pi = (i - 1 + polygon.length) % polygon.length;
                    var ni = (i + 1) % polygon.length;
                    var pv = polygon[pi];
                    var cv = polygon[i];
                    var nv = polygon[ni];
                    pv.Next = cv;
                    cv.Next = nv;
                    nv.Prev = cv;
                    cv.Prev = pv;
                    var edg = new Edge();
                    edg.V0 = cv;
                    edg.V1 = nv;
                    cv.ELsit.push(edg);
                    nv.ELsit.push(edg);
                    cv.Index = this.VList.length;
                    cv.Init();
                    this.VList.push(cv);
                    this.EList.push(edg);
                }
            }
            CalculateEdges() {
                var YMonoTone = (a, b) => {
                    if (a.P.Y > b.P.Y + U1.PRECISION)
                        return -1;
                    if (a.P.Y < b.P.Y - U1.PRECISION)
                        return 1;
                    if (a.P.X > b.P.X + U1.PRECISION)
                        return -1;
                    if (a.P.X < b.P.X - U1.PRECISION)
                        return 1;
                    return 0;
                };
                var EegeSorter = (a, b) => {
                    var y0 = a.V0.P.Y >= a.V1.P.Y + U1.PRECISION ? a.V0.P.Y : a.V1.P.Y;
                    var y1 = b.V0.P.Y >= b.V1.P.Y + U1.PRECISION ? b.V0.P.Y : b.V1.P.Y;
                    if (y0 > y1 + U1.PRECISION)
                        return -1;
                    if (y0 < y1 + U1.PRECISION)
                        return 1;
                    return 0;
                };
                var sortedVs = new Array();
                sortedVs = sortedVs.concat(this.VList);
                sortedVs.sort(YMonoTone);
                this.EList.sort(EegeSorter);
                var d = new U1.Vector2();
                var mp = new U1.Vector2();
                var neg = new U1.Vector2();
                var d0 = new U1.Vector2();
                var d1 = new U1.Vector2();
                for (var i = 0; i < sortedVs.length; i++) {
                    var v0 = sortedVs[i];
                    for (var j = 0; j < i; j++) {
                        var v1 = sortedVs[j];
                        if (!v0.IsBoundedSide(v1.P))
                            continue;
                        var isecEdge = false;
                        d.SetSubtract(v1.P, v0.P).Normalize();
                        for (var vi = j + 1; vi < i; vi++) {
                            var tv = sortedVs[vi];
                            d0.SetSubtract(tv.P, v0.P);
                            if (U1.Vector2.Dot(d0, d) < 0)
                                continue;
                            d1.SetSubtract(tv.P, v1.P);
                            if (U1.Vector2.Dot(d1, neg.SetNegate(d)) < 0)
                                continue;
                            mp.SetAdd(v0.P, d.Scale(U1.Vector2.Dot(d0, d)));
                            if (U1.Vector2.DistanceSquared(mp, tv.P) < U1.PRECISION) {
                                isecEdge = true;
                                break;
                            }
                        }
                        if (isecEdge)
                            continue;
                        for (var ei = 0; ei < this.EList.length; ei++) {
                            var tedge = this.EList[ei];
                            if (tedge.V0.P.Y < v0.P.Y && tedge.V1.P.Y < v0.P.Y)
                                break;
                            isecEdge = (tedge.V0 === v0 && tedge.V1 === v1) ||
                                (tedge.V0 === v1 && tedge.V1 === v0);
                            if (isecEdge)
                                break;
                            if (tedge.V0 === v0 || tedge.V0 === v1)
                                continue;
                            if (tedge.V1 === v0 || tedge.V1 === v1)
                                continue;
                            isecEdge = tedge.IntersectSegment(v0, v1);
                            if (isecEdge)
                                break;
                        }
                        if (isecEdge)
                            continue;
                        var edge = new Edge();
                        edge.V0 = v1;
                        edge.V1 = v0;
                        edge.IsNew = true;
                        v0.ELsit.push(edge);
                        v1.ELsit.push(edge);
                        this.EList.unshift(edge);
                    }
                }
            }
            CalculateFaces() {
                var visitedVtx = new Array();
                var left = U1.Vector2.Zero;
                for (var v0 of this.VList) {
                    var neiVList = v0.ELsit
                        .map(o_ => o_.V1 == v0 ? o_.V0 : o_.V1)
                        .OrderBy(o_ => U1.GeometryHelper2.AngleCCW(U1.Vector2.UnitX, U1.Vector2.Subtract(o_.P, v0.P)));
                    visitedVtx.push(v0);
                    var pi = neiVList.length - 1;
                    for (var nvi = 0; nvi < neiVList.length; pi = nvi, nvi++) {
                        var v1 = neiVList[pi];
                        var v2 = neiVList[nvi];
                        var inDir = U1.Vector2.Normalize(U1.Vector2.Subtract(v1.P, v0.P)).Left;
                        if (U1.Vector2.Dot(inDir, U1.Vector2.Subtract(v2.P, v0.P)) < 0) {
                            continue;
                        }
                        if (visitedVtx.Contains(v1) || visitedVtx.Contains(v2)) {
                            continue;
                        }
                        if (v1 = v0.Next) {
                            left = U1.Vector2.Subtract(v1.P, v0.P).Left;
                            if (U1.Vector2.Dot(left, U1.Vector2.Subtract(v2.P, v0.P)) < 0) {
                                continue;
                            }
                            if (v1 = v0.Prev) {
                                left = U1.Vector2.Subtract(v0.P, v1.P).Left;
                                if (U1.Vector2.Dot(left, U1.Vector2.Subtract(v2.P, v1.P)) < 0) {
                                    continue;
                                }
                            }
                            if (v2 = v0.Next) {
                                left = U1.Vector2.Subtract(v2.P, v0.P).Left;
                                if (U1.Vector2.Dot(left, U1.Vector2.Subtract(v1.P, v0.P)) < 0) {
                                    continue;
                                }
                            }
                            if (v2 == v0.Prev) {
                                left = U1.Vector2.Subtract(v0.P, v2.P).Left;
                                if (U1.Vector2.Dot(left, U1.Vector2.Subtract(v1.P, v2.P)) < 0) {
                                    continue;
                                }
                            }
                            var isOk = false;
                            for (var e of v1.ELsit) {
                                if (e.V0 == v2 || e.V1 == v2) {
                                    isOk = true;
                                    break;
                                }
                            }
                            if (isOk) {
                                var f = new Face();
                                f.V0 = v0;
                                f.V1 = v1;
                                f.V2 = v2;
                                this.FList.push(f);
                            }
                        }
                    }
                }
            }
            IsInside(p) {
                var dir = new U1.Vector2(1, 0);
                for (var a = 0.01; a < Math.PI; a += 0.1) {
                    var front_cross = 0;
                    var back_cross = 0;
                    for (var ei = 0; ei < this.EList.length; ei++) {
                        var e = this.EList[ei];
                        if (e.IsNew)
                            continue;
                        var t = e.IntersectLine(p, dir);
                        if (t != null) {
                            if (t > 0)
                                front_cross++;
                            else if (t < 0)
                                back_cross++;
                        }
                    }
                    if (front_cross % 2 == back_cross % 2) {
                        return (front_cross % 2) == 1;
                    }
                    dir.Set(Math.cos(a), Math.sin(a));
                }
                return false;
            }
            GetMesh() {
                this.CalculateEdges();
                this.CalculateFaces();
                var result = new Mesh2();
                var vlist = new Array();
                var flist = new Array();
                this.VList.forEach((v_, i_, vs_) => {
                    vlist.push(v_.P);
                });
                this.FList.forEach((f_, i_, fs_) => {
                    if (f_.Area() >= TDS.MIN_FACE_AREA)
                        flist.push(new Face2(f_.V0.Index, f_.V1.Index, f_.V2.Index));
                });
                result.VList = vlist;
                result.FList = flist;
                return result;
            }
        }
        TDS.MIN_FACE_AREA = 0.001;
        Triangulations.TDS = TDS;
        class Face2 {
            constructor(v0, v1, v2) {
                this.V0 = v0;
                this.V1 = v1;
                this.V2 = v2;
            }
            toString() {
                return "[" + this.V0.toString() + "," + this.V1.toString() + "," + this.V2.toString() + "]";
            }
        }
        Triangulations.Face2 = Face2;
        class Mesh2 {
            constructor() {
                this.FList = new Array();
                this.VList = new Array();
            }
            Area() {
                var area = 0.0;
                var points = new Array(U1.Vector2.Zero, U1.Vector2.Zero, U1.Vector2.Zero);
                for (var face of this.FList) {
                    points[0] = (this.VList[face.V0]);
                    points[1] = (this.VList[face.V1]);
                    points[2] = (this.VList[face.V2]);
                    area += Polygon2.GetArea(points);
                }
                return area;
            }
        }
        Triangulations.Mesh2 = Mesh2;
        class PolygonTriangulation2 {
            constructor() {
                this.m_TDS = new TDS();
            }
            Fill(pgon) {
                this.m_TDS.AddPolygon(pgon);
            }
            FillPWH(pwh) {
                for (var path of pwh.GetPolygonList()) {
                    this.m_TDS.AddPolygon(path);
                }
            }
            FillPSet(pgonSet) {
                for (var path of pgonSet.GetPolygonList()) {
                    this.m_TDS.AddPolygon(path);
                }
            }
            GetMesh() {
                return this.m_TDS.GetMesh();
            }
        }
        Triangulations.PolygonTriangulation2 = PolygonTriangulation2;
    })(Triangulations = U1.Triangulations || (U1.Triangulations = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class BoundingBox {
        constructor(min, max) {
            this.Min = new U1.Vector3();
            this.Max = new U1.Vector3();
            if (min != null)
                this.Min.CopyFrom(min);
            if (max != null)
                this.Max.CopyFrom(max);
        }
        GetCorners(result) {
            if (result == null)
                result = new Array(8);
            for (var i = 0; i < 8; i++) {
                if (result[i] == null)
                    result[i] = new U1.Vector3();
            }
            var min = this.Min;
            var max = this.Max;
            result[0].Set(min.X, max.Y, max.Z);
            result[1].Set(max.X, max.Y, max.Z);
            result[2].Set(max.X, min.Y, max.Z);
            result[3].Set(min.X, min.Y, max.Z);
            result[4].Set(min.X, max.Y, min.Z);
            result[5].Set(max.X, max.Y, min.Z);
            result[6].Set(max.X, min.Y, min.Z);
            result[7].Set(min.X, min.Y, min.Z);
            return result;
        }
        Equals(other) {
            if (this.Min.X != other.Min.X)
                return false;
            if (this.Min.Y != other.Min.Y)
                return false;
            if (this.Min.Z != other.Min.Z)
                return false;
            if (this.Max.X != other.Max.X)
                return false;
            if (this.Max.Y != other.Max.Y)
                return false;
            if (this.Max.Z != other.Max.Z)
                return false;
            return true;
        }
        Set(...params) {
            this.SetCreateFromPoints(params);
            return this;
        }
        Clone() {
            var result = new BoundingBox(this.Min, this.Max);
            return result;
        }
        ConvertFromStr(value) {
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            var idx = 0;
            this.Min.X = items.length > idx ? items[idx++] : 0;
            this.Min.Y = items.length > idx ? items[idx++] : 0;
            this.Min.Z = items.length > idx ? items[idx++] : 0;
            this.Max.X = items.length > idx ? items[idx++] : 0;
            this.Max.Y = items.length > idx ? items[idx++] : 0;
            this.Max.Z = items.length > idx ? items[idx++] : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this.Min.X, this.Min.Y, this.Min.Z, this.Max.X, this.Max.Y, this.Max.Z);
        }
        CopyFrom(source) {
            this.Min.CopyFrom(source.Min);
            this.Max.CopyFrom(source.Max);
        }
        static CreateMerged(original, additional, result = null) {
            if (result == null)
                result = new BoundingBox();
            result.Min = U1.Vector3.Min(original.Min, additional.Min);
            result.Max = U1.Vector3.Max(original.Max, additional.Max);
            return result;
        }
        SetCreateMerged(original, additional) {
            this.Min = U1.Vector3.Min(original.Min, additional.Min);
            this.Max = U1.Vector3.Max(original.Max, additional.Max);
            return this;
        }
        Merge(additional, tm) {
            var add = tm == null ? additional : new BoundingBox().SetFromBox(additional, tm);
            this.Min = U1.Vector3.Min(this.Min, add.Min);
            this.Max = U1.Vector3.Max(this.Max, add.Max);
            return this;
        }
        static CreateFromSphere(sphere, result = null) {
            if (result == null)
                result = new BoundingBox();
            result.Min.X = sphere.Center.X - sphere.Radius;
            result.Min.Y = sphere.Center.Y - sphere.Radius;
            result.Min.Z = sphere.Center.Z - sphere.Radius;
            result.Max.X = sphere.Center.X + sphere.Radius;
            result.Max.Y = sphere.Center.Y + sphere.Radius;
            result.Max.Z = sphere.Center.Z + sphere.Radius;
            return result;
        }
        SetCreateFromSphere(sphere) {
            this.Min.X = sphere.Center.X - sphere.Radius;
            this.Min.Y = sphere.Center.Y - sphere.Radius;
            this.Min.Z = sphere.Center.Z - sphere.Radius;
            this.Max.X = sphere.Center.X + sphere.Radius;
            this.Max.Y = sphere.Center.Y + sphere.Radius;
            this.Max.Z = sphere.Center.Z + sphere.Radius;
            return this;
        }
        static CreateFromPoints(points, result = null) {
            if (points == null) {
                throw "ArgumentNullException";
            }
            var flag = false;
            var min = BoundingBox[".cfp.min."] || (BoundingBox[".cfp.min."] = new U1.Vector3());
            var max = BoundingBox[".cfp.max."] || (BoundingBox[".cfp.max."] = new U1.Vector3());
            min.SetMaxValue();
            max.SetMinValue();
            for (var i = 0; i < points.length; i++) {
                min = U1.Vector3.Min(min, points[i]);
                max = U1.Vector3.Max(max, points[i]);
                flag = true;
            }
            if (result == null)
                result = new BoundingBox();
            if (!flag) {
                return result;
            }
            result.Min.CopyFrom(min);
            result.Max.CopyFrom(max);
            return result;
        }
        SetCreateFromPoints(points) {
            if (points == null || points.length == 0) {
                return;
            }
            var flag = false;
            var min = this.Min;
            var max = this.Max;
            min.SetMaxValue();
            max.SetMinValue();
            for (var i = 0; i < points.length; i++) {
                min.Minimize(points[i]);
                max.Maximize(points[i]);
            }
            return this;
        }
        SetFromBox(box, m) {
            var s_;
            s_ = BoundingBox[".scf."] || (BoundingBox[".scf."] = s_ = {
                corners: [
                    new U1.Vector3(), new U1.Vector3(), new U1.Vector3(), new U1.Vector3(),
                    new U1.Vector3(), new U1.Vector3(), new U1.Vector3(), new U1.Vector3(),
                ]
            });
            box.GetCorners(s_.corners);
            var points = s_.corners.map(o_ => o_.Transform(m));
            var min = this.Min;
            var max = this.Max;
            min.Set(points[0]);
            max.Set(points[0]);
            for (var i = 1; i < points.length; i++) {
                min.Minimize(points[i]);
                max.Maximize(points[i]);
            }
            return this;
        }
        IntersectsBoundingBox(box) {
            if ((this.Max.X < box.Min.X) || (this.Min.X > box.Max.X)) {
                return false;
            }
            if ((this.Max.Y < box.Min.Y) || (this.Min.Y > box.Max.Y)) {
                return false;
            }
            return ((this.Max.Z >= box.Min.Z) && (this.Min.Z <= box.Max.Z));
        }
        IntersectsBoundingFrustum(frustum) {
            if (null == frustum) {
                throw "ArgumentNullException";
            }
            return frustum.IntersectsBoundingBox(this);
        }
        IntersectsPlane(plane) {
            var vector = new U1.Vector3();
            var vector2 = new U1.Vector3();
            vector2.X = (plane.Normal.X >= 0) ? this.Min.X : this.Max.X;
            vector2.Y = (plane.Normal.Y >= 0) ? this.Min.Y : this.Max.Y;
            vector2.Z = (plane.Normal.Z >= 0) ? this.Min.Z : this.Max.Z;
            vector.X = (plane.Normal.X >= 0) ? this.Max.X : this.Min.X;
            vector.Y = (plane.Normal.Y >= 0) ? this.Max.Y : this.Min.Y;
            vector.Z = (plane.Normal.Z >= 0) ? this.Max.Z : this.Min.Z;
            var num = ((plane.Normal.X * vector2.X) + (plane.Normal.Y * vector2.Y)) + (plane.Normal.Z * vector2.Z);
            if ((num + plane.D) > 0) {
                return U1.PlaneIntersectionTypeEnum.Front;
            }
            num = ((plane.Normal.X * vector.X) + (plane.Normal.Y * vector.Y)) + (plane.Normal.Z * vector.Z);
            if ((num + plane.D) < 0) {
                return U1.PlaneIntersectionTypeEnum.Back;
            }
            return U1.PlaneIntersectionTypeEnum.Intersecting;
        }
        IntersectsRay(ray) {
            var num = 0;
            var maxValue = Number.MAX_VALUE;
            if (Math.abs(ray.Direction.X) < 1E-06) {
                if ((ray.Position.X < this.Min.X) || (ray.Position.X > this.Max.X)) {
                    return null;
                }
            }
            else {
                var num11 = 1 / ray.Direction.X;
                var num8 = (this.Min.X - ray.Position.X) * num11;
                var num7 = (this.Max.X - ray.Position.X) * num11;
                if (num8 > num7) {
                    var num14 = num8;
                    num8 = num7;
                    num7 = num14;
                }
                num = Math.max(num8, num);
                maxValue = Math.min(num7, maxValue);
                if (num > maxValue) {
                    return null;
                }
            }
            if (Math.abs(ray.Direction.Y) < 1E-06) {
                if ((ray.Position.Y < this.Min.Y) || (ray.Position.Y > this.Max.Y)) {
                    return null;
                }
            }
            else {
                var num10 = 1 / ray.Direction.Y;
                var num6 = (this.Min.Y - ray.Position.Y) * num10;
                var num5 = (this.Max.Y - ray.Position.Y) * num10;
                if (num6 > num5) {
                    var num13 = num6;
                    num6 = num5;
                    num5 = num13;
                }
                num = Math.max(num6, num);
                maxValue = Math.min(num5, maxValue);
                if (num > maxValue) {
                    return null;
                }
            }
            if (Math.abs(ray.Direction.Z) < 1E-06) {
                if ((ray.Position.Z < this.Min.Z) || (ray.Position.Z > this.Max.Z)) {
                    return null;
                }
            }
            else {
                var num9 = 1 / ray.Direction.Z;
                var num4 = (this.Min.Z - ray.Position.Z) * num9;
                var num3 = (this.Max.Z - ray.Position.Z) * num9;
                if (num4 > num3) {
                    var num12 = num4;
                    num4 = num3;
                    num3 = num12;
                }
                num = Math.max(num4, num);
                maxValue = Math.min(num3, maxValue);
                if (num > maxValue) {
                    return null;
                }
            }
            return num;
        }
        IntersectsBoundingSphere(sphere) {
            var vector = U1.Vector3.Clamp(sphere.Center, this.Min, this.Max);
            var num = U1.Vector3.DistanceSquared(sphere.Center, vector);
            return (num <= (sphere.Radius * sphere.Radius));
        }
        ContainsBoundingBox(box) {
            if ((this.Max.X < box.Min.X) || (this.Min.X > box.Max.X)) {
                return U1.ContainmentTypeEnum.Disjoint;
            }
            if ((this.Max.Y < box.Min.Y) || (this.Min.Y > box.Max.Y)) {
                return U1.ContainmentTypeEnum.Disjoint;
            }
            if ((this.Max.Z < box.Min.Z) || (this.Min.Z > box.Max.Z)) {
                return U1.ContainmentTypeEnum.Disjoint;
            }
            if ((((this.Min.X <= box.Min.X) && (box.Max.X <= this.Max.X)) && ((this.Min.Y <= box.Min.Y) && (box.Max.Y <= this.Max.Y))) && ((this.Min.Z <= box.Min.Z) && (box.Max.Z <= this.Max.Z))) {
                return U1.ContainmentTypeEnum.Contains;
            }
            return U1.ContainmentTypeEnum.Intersects;
        }
        ContainsBoundingFrustum(frustum) {
            if (null == frustum) {
                throw "ArgumentNullException";
            }
            if (!frustum.IntersectsBoundingBox(this)) {
                return U1.ContainmentTypeEnum.Disjoint;
            }
            var cornerArray = frustum.CornerArray;
            for (var i = 0; i < cornerArray.length; i++) {
                if (this.ContainsPoint(cornerArray[i]) == U1.ContainmentTypeEnum.Disjoint) {
                    return U1.ContainmentTypeEnum.Intersects;
                }
            }
            return U1.ContainmentTypeEnum.Contains;
        }
        ContainsPoint(point) {
            if (this.Min.X <= point.X
                && point.X <= this.Max.X
                && this.Min.Y <= point.Y
                && point.Y <= this.Max.Y
                && this.Min.Z <= point.Z
                && point.Z <= this.Max.Z) {
                return U1.ContainmentTypeEnum.Contains;
            }
            return U1.ContainmentTypeEnum.Disjoint;
        }
        ContainsBoundingSphere(sphere) {
            var vector = U1.Vector3.Clamp(sphere.Center, this.Min, this.Max);
            var num2 = U1.Vector3.DistanceSquared(sphere.Center, vector);
            var radius = sphere.Radius;
            if (num2 > (radius * radius)) {
                return U1.ContainmentTypeEnum.Disjoint;
            }
            if (this.Min.X + radius <= sphere.Center.X
                && sphere.Center.X <= this.Max.X - radius
                && this.Max.X - this.Min.X > radius
                && this.Min.Y + radius <= sphere.Center.Y
                && sphere.Center.Y <= this.Max.Y - radius
                && this.Max.Y - this.Min.Y > radius
                && this.Min.Z + radius <= sphere.Center.Z
                && sphere.Center.Z <= this.Max.Z - radius
                && this.Max.X - this.Min.X > radius) {
                return U1.ContainmentTypeEnum.Contains;
            }
            return U1.ContainmentTypeEnum.Intersects;
        }
        SupportMapping(v) {
            var result = new U1.Vector3();
            result.X = (v.X >= 0) ? this.Max.X : this.Min.X;
            result.Y = (v.Y >= 0) ? this.Max.Y : this.Min.Y;
            result.Z = (v.Z >= 0) ? this.Max.Z : this.Min.Z;
            return result;
        }
    }
    U1.BoundingBox = BoundingBox;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Gjk {
        constructor() {
            this.closestPoint = U1.Vector3.Zero;
            this.det = [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ];
            this.edgeLengthSquared = [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ];
            this.edges = [
                [U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero],
                [U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero],
                [U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero],
                [U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero]
            ];
            this.y = [U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero];
            this.yLengthSquared = [0, 0, 0, 0];
        }
        AddSupportPoint(newPoint) {
            var index = (Gjk.BitsToIndices[this.simplexBits ^ 15] & 7) - 1;
            this.y[index] = newPoint;
            this.yLengthSquared[index] = newPoint.LengthSquareduared();
            for (var i = Gjk.BitsToIndices[this.simplexBits]; i != 0; i = i >> 3) {
                var num2 = (i & 7) - 1;
                var vector = U1.Vector3.Subtract(this.y[num2], newPoint);
                this.edges[num2][index] = vector;
                this.edges[index][num2] = U1.Vector3.Negate(vector);
                this.edgeLengthSquared[index][num2] = this.edgeLengthSquared[num2][index] = vector.LengthSquareduared();
            }
            this.UpdateDeterminant(index);
            return this.UpdateSimplex(index);
        }
        ComputeClosestPoint() {
            var num3 = 0;
            var result = U1.Vector3.Zero;
            this.maxLengthSquared = 0;
            for (var i = Gjk.BitsToIndices[this.simplexBits]; i != 0; i = i >> 3) {
                var index = (i & 7) - 1;
                var num4 = this.det[this.simplexBits][index];
                num3 += num4;
                result = U1.Vector3.Add(result, U1.Vector3.Scale(this.y[index], num4));
                this.maxLengthSquared = Math.max(this.maxLengthSquared, this.yLengthSquared[index]);
            }
            result.Scale(1 / num3);
            return result;
        }
        static Dot(a, b) {
            return (((a.X * b.X) + (a.Y * b.Y)) + (a.Z * b.Z));
        }
        IsSatisfiesRule(xBits, yBits) {
            for (var i = Gjk.BitsToIndices[yBits]; i != 0; i = i >> 3) {
                var index = (i & 7) - 1;
                var num3 = (1) << index;
                if ((num3 & xBits) != 0) {
                    if (this.det[xBits][index] <= 0) {
                        return false;
                    }
                }
                else if (this.det[xBits | num3][index] > 0) {
                    return false;
                }
            }
            return true;
        }
        Reset() {
            this.simplexBits = 0;
            this.maxLengthSquared = 0;
        }
        UpdateDeterminant(xmIdx) {
            var index = (1) << xmIdx;
            this.det[index][xmIdx] = 1;
            var num14 = Gjk.BitsToIndices[this.simplexBits];
            var num8 = num14;
            for (var i = 0; num8 != 0; i++) {
                var num = (num8 & 7) - 1;
                var num12 = (1) << num;
                var num6 = num12 | index;
                this.det[num6][num] = Gjk.Dot(this.edges[xmIdx][num], this.y[xmIdx]);
                this.det[num6][xmIdx] = Gjk.Dot(this.edges[num][xmIdx], this.y[num]);
                var num11 = num14;
                for (var j = 0; j < i; j++) {
                    var num3 = (num11 & 7) - 1;
                    var num5 = (1) << num3;
                    var num9 = num6 | num5;
                    var num4 = (this.edgeLengthSquared[num][num3] < this.edgeLengthSquared[xmIdx][num3]) ? num : xmIdx;
                    this.det[num9][num3] = (this.det[num6][num] * Gjk.Dot(this.edges[num4][num3], this.y[num]))
                        + (this.det[num6][xmIdx] * Gjk.Dot(this.edges[num4][num3], this.y[xmIdx]));
                    num4 = (this.edgeLengthSquared[num3][num] < this.edgeLengthSquared[xmIdx][num]) ? num3 : xmIdx;
                    this.det[num9][num] = (this.det[num5 | index][num3] * Gjk.Dot(this.edges[num4][num], this.y[num3]))
                        + (this.det[num5 | index][xmIdx] * Gjk.Dot(this.edges[num4][num], this.y[xmIdx]));
                    num4 = (this.edgeLengthSquared[num][xmIdx] < this.edgeLengthSquared[num3][xmIdx]) ? num : num3;
                    this.det[num9][xmIdx] = (this.det[num12 | num5][num3] * Gjk.Dot(this.edges[num4][xmIdx], this.y[num3]))
                        + (this.det[num12 | num5][num] * Gjk.Dot(this.edges[num4][xmIdx], this.y[num]));
                    num11 = num11 >> 3;
                }
                num8 = num8 >> 3;
            }
            if ((this.simplexBits | index) == 15) {
                var num2 = (this.edgeLengthSquared[1][0] < this.edgeLengthSquared[2][0]) ? ((this.edgeLengthSquared[1][0] < this.edgeLengthSquared[3][0]) ? 1 : 3) : ((this.edgeLengthSquared[2][0] < this.edgeLengthSquared[3][0]) ? 2 : 3);
                this.det[15][0] = ((this.det[14][1] * Gjk.Dot(this.edges[num2][0], this.y[1])) + (this.det[14][2] * Gjk.Dot(this.edges[num2][0], this.y[2]))) + (this.det[14][3] * Gjk.Dot(this.edges[num2][0], this.y[3]));
                num2 = (this.edgeLengthSquared[0][1] < this.edgeLengthSquared[2][1]) ? ((this.edgeLengthSquared[0][1] < this.edgeLengthSquared[3][1]) ? 0 : 3) : ((this.edgeLengthSquared[2][1] < this.edgeLengthSquared[3][1]) ? 2 : 3);
                this.det[15][1] = ((this.det[13][0] * Gjk.Dot(this.edges[num2][1], this.y[0])) + (this.det[13][2] * Gjk.Dot(this.edges[num2][1], this.y[2]))) + (this.det[13][3] * Gjk.Dot(this.edges[num2][1], this.y[3]));
                num2 = (this.edgeLengthSquared[0][2] < this.edgeLengthSquared[1][2]) ? ((this.edgeLengthSquared[0][2] < this.edgeLengthSquared[3][2]) ? 0 : 3) : ((this.edgeLengthSquared[1][2] < this.edgeLengthSquared[3][2]) ? 1 : 3);
                this.det[15][2] = ((this.det[11][0] * Gjk.Dot(this.edges[num2][2], this.y[0])) + (this.det[11][1] * Gjk.Dot(this.edges[num2][2], this.y[1]))) + (this.det[11][3] * Gjk.Dot(this.edges[num2][2], this.y[3]));
                num2 = (this.edgeLengthSquared[0][3] < this.edgeLengthSquared[1][3]) ? ((this.edgeLengthSquared[0][3] < this.edgeLengthSquared[2][3]) ? 0 : 2) : ((this.edgeLengthSquared[1][3] < this.edgeLengthSquared[2][3]) ? 1 : 2);
                this.det[15][3] = ((this.det[7][0] * Gjk.Dot(this.edges[num2][3], this.y[0])) + (this.det[7][1] * Gjk.Dot(this.edges[num2][3], this.y[1]))) + (this.det[7][2] * Gjk.Dot(this.edges[num2][3], this.y[2]));
            }
        }
        UpdateSimplex(newIndex) {
            var yBits = this.simplexBits | ((1) << newIndex);
            var xBits = (1) << newIndex;
            for (var i = this.simplexBits; i != 0; i--) {
                if (((i & yBits) == i) && this.IsSatisfiesRule(i | xBits, yBits)) {
                    this.simplexBits = i | xBits;
                    this.closestPoint = this.ComputeClosestPoint();
                    return true;
                }
            }
            var flag = false;
            if (this.IsSatisfiesRule(xBits, yBits)) {
                this.simplexBits = xBits;
                this.closestPoint = this.y[newIndex];
                this.maxLengthSquared = this.yLengthSquared[newIndex];
                flag = true;
            }
            return flag;
        }
        get ClosestPoint() {
            return this.closestPoint;
        }
        get FullSimplex() {
            return (this.simplexBits == 15);
        }
        get MaxLengthSquareduared() {
            return this.maxLengthSquared;
        }
    }
    Gjk.BitsToIndices = [0, 1, 2, 0x11, 3, 0x19, 0x1a, 0xd1, 4, 0x21, 0x22, 0x111, 0x23, 0x119, 0x11a, 0x8d1];
    class BoundingFrustum {
        constructor(value = null) {
            this.matrix = U1.Matrix4.Identity;
            this.cornerArray = [
                U1.Vector3.Zero,
                U1.Vector3.Zero,
                U1.Vector3.Zero,
                U1.Vector3.Zero,
                U1.Vector3.Zero,
                U1.Vector3.Zero,
                U1.Vector3.Zero,
                U1.Vector3.Zero
            ];
            this.planes = [
                new U1.Plane(),
                new U1.Plane(),
                new U1.Plane(),
                new U1.Plane(),
                new U1.Plane(),
                new U1.Plane(),
            ];
            if (value != null) {
                this.SetMatrix(value);
            }
        }
        Equals(other) {
            if (other == null) {
                return false;
            }
            return (this.matrix.Equals(other.matrix));
        }
        static ComputeIntersection(plane, ray, result = null) {
            if (result == null)
                result = new U1.Vector3();
            var num = (-plane.D - U1.Vector3.Dot(plane.Normal, ray.Position)) / U1.Vector3.Dot(plane.Normal, ray.Direction);
            return result.SetScaleAdd(ray.Position, num, ray.Direction);
        }
        static ComputeIntersectionLine(p1, p2, result = null) {
            if (result == null)
                result = new U1.Ray3();
            result.Direction.SetCross(p1.Normal, p2.Normal);
            var num = result.Direction.LengthSquareduared();
            var s1 = U1.Vector3.Scale(p2.Normal, -p1.D);
            var s2 = U1.Vector3.Scale(p1.Normal, p2.D);
            var v1 = U1.Vector3.Add(s1, s2);
            v1.Cross(result.Direction);
            v1.Scale(1 / num);
            result.Position.CopyFrom(v1);
            return result;
        }
        ContainsBoundingBox(box) {
            var flag = false;
            for (var i = 0; i < this.planes.length; i++) {
                var plane = this.planes[i];
                switch (box.IntersectsPlane(plane)) {
                    case U1.PlaneIntersectionTypeEnum.Front:
                        return U1.ContainmentTypeEnum.Disjoint;
                    case U1.PlaneIntersectionTypeEnum.Intersecting:
                        flag = true;
                        break;
                }
            }
            if (!flag) {
                return U1.ContainmentTypeEnum.Contains;
            }
            return U1.ContainmentTypeEnum.Intersects;
        }
        ContainsBoundingFrustum(frustum) {
            if (frustum == null) {
                throw "ArgumentNullException";
            }
            var disjoint = U1.ContainmentTypeEnum.Disjoint;
            if (this.IntersectsBoundingFrustum(frustum)) {
                disjoint = U1.ContainmentTypeEnum.Contains;
                for (var i = 0; i < this.cornerArray.length; i++) {
                    if (this.ContainsPoint(frustum.cornerArray[i]) == U1.ContainmentTypeEnum.Disjoint) {
                        return U1.ContainmentTypeEnum.Intersects;
                    }
                }
            }
            return disjoint;
        }
        ContainsBoundingSphere(sphere) {
            var center = sphere.Center;
            var radius = sphere.Radius;
            var num2 = 0;
            for (var i = 0; i < this.planes.length; i++) {
                var plane = this.planes[i];
                var num5 = ((plane.Normal.X * center.X) + (plane.Normal.Y * center.Y)) + (plane.Normal.Z * center.Z);
                var num3 = num5 + plane.D;
                if (num3 > radius) {
                    return U1.ContainmentTypeEnum.Disjoint;
                }
                if (num3 < -radius) {
                    num2++;
                }
            }
            if (num2 != 6) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            return U1.ContainmentTypeEnum.Contains;
        }
        ContainsPoint(point) {
            for (var i = 0; i < this.planes.length; i++) {
                var plane = this.planes[i];
                var num2 = (((plane.Normal.X * point.X) + (plane.Normal.Y * point.Y)) + (plane.Normal.Z * point.Z)) + plane.D;
                if (num2 > 1E-05) {
                    return U1.ContainmentTypeEnum.Disjoint;
                }
            }
            return U1.ContainmentTypeEnum.Contains;
        }
        get CornerArray() {
            return this.cornerArray;
        }
        GetCornersCopy() {
            return [
                this.cornerArray[0].Clone(),
                this.cornerArray[1].Clone(),
                this.cornerArray[2].Clone(),
                this.cornerArray[3].Clone(),
                this.cornerArray[4].Clone(),
                this.cornerArray[5].Clone(),
                this.cornerArray[6].Clone(),
                this.cornerArray[7].Clone()
            ];
        }
        IntersectsBoundingBox(box) {
            var ps = BoundingFrustum.tmp_box_points;
            ps[0].Set(box.Min.X, box.Min.Y, box.Min.Z);
            ps[1].Set(box.Max.X, box.Min.Y, box.Min.Z);
            ps[2].Set(box.Max.X, box.Max.Y, box.Min.Z);
            ps[3].Set(box.Min.X, box.Max.Y, box.Min.Z);
            ps[4].Set(box.Min.X, box.Min.Y, box.Max.Z);
            ps[5].Set(box.Max.X, box.Min.Y, box.Max.Z);
            ps[6].Set(box.Max.X, box.Max.Y, box.Max.Z);
            ps[7].Set(box.Min.X, box.Max.Y, box.Max.Z);
            for (var i = 0; i < ps.length; i++) {
                var p = ps[i];
                var count = 0;
                for (var j = 0; j < this.planes.length; j++) {
                    var d = this.planes[j].DotCoordinate(p);
                    if (d > 0)
                        break;
                    count++;
                }
                if (count == this.planes.length)
                    return true;
            }
            return false;
        }
        IntersectsBoundingFrustum(frustum) {
            var closestPoint;
            if (frustum == null) {
                throw "ArgumentNullException(\"frustum\")";
            }
            var ps = frustum.CornerArray;
            for (var i = 0; i < ps.length; i++) {
                var p = ps[i];
                var count = 0;
                for (var j = 0; j < this.planes.length; j++) {
                    var d = this.planes[j].DotCoordinate(p);
                    if (d > 0)
                        break;
                    count++;
                }
                if (count == this.planes.length)
                    return true;
            }
            return false;
        }
        IntersectsBoundingSphere(sphere) {
            for (var i = 0; i < this.planes.length; i++) {
                var d = this.planes[i].DotCoordinate(sphere.Center);
                if (d > sphere.Radius)
                    return false;
            }
            return true;
        }
        IntersectsPlane(plane) {
            var num = 0;
            for (var i = 0; i < 8; i++) {
                var num3 = U1.Vector3.Dot(this.cornerArray[i], plane.Normal);
                if ((num3 + plane.D) > 0) {
                    num |= 1;
                }
                else {
                    num |= 2;
                }
                if (num == 3) {
                    return U1.PlaneIntersectionTypeEnum.Intersecting;
                }
            }
            if (num != 1) {
                return U1.PlaneIntersectionTypeEnum.Back;
            }
            return U1.PlaneIntersectionTypeEnum.Front;
        }
        IntersectsRay(ray) {
            var result;
            var type_ = this.ContainsPoint(ray.Position);
            if (type_ == U1.ContainmentTypeEnum.Contains) {
                result = 0;
            }
            else {
                var minValue = Number.MIN_VALUE;
                var maxValue = Number.MAX_VALUE;
                result = 0;
                for (var i = 0; i < this.planes.length; i++) {
                    var plane = this.planes[i];
                    var num3;
                    var num6;
                    var normal = plane.Normal;
                    num6 = U1.Vector3.Dot(ray.Direction, normal);
                    num3 = U1.Vector3.Dot(ray.Position, normal);
                    num3 += plane.D;
                    if (Math.abs(num6) < 1E-05) {
                        if (num3 > 0) {
                            return;
                        }
                    }
                    else {
                        var num = -num3 / num6;
                        if (num6 < 0) {
                            if (num > maxValue) {
                                return;
                            }
                            if (num > minValue) {
                                minValue = num;
                            }
                        }
                        else {
                            if (num < minValue) {
                                return;
                            }
                            if (num < maxValue) {
                                maxValue = num;
                            }
                        }
                    }
                }
                var num7 = (minValue >= 0) ? minValue : maxValue;
                if (num7 >= 0) {
                    result = num7;
                }
            }
            return result;
        }
        SupportMapping(v) {
            var num3 = U1.Vector3.Dot(this.cornerArray[0], v);
            var index = 0;
            for (var i = 1; i < this.cornerArray.length; i++) {
                var num2 = U1.Vector3.Dot(this.cornerArray[i], v);
                if (num2 > num3) {
                    index = i;
                    num3 = num2;
                }
            }
            return this.cornerArray[index];
        }
        SetMatrix(value) {
            this.matrix = value;
            this.planes[2].Normal.X = -value.M14 - value.M11;
            this.planes[2].Normal.Y = -value.M24 - value.M21;
            this.planes[2].Normal.Z = -value.M34 - value.M31;
            this.planes[2].D = -value.M44 - value.M41;
            this.planes[3].Normal.X = -value.M14 + value.M11;
            this.planes[3].Normal.Y = -value.M24 + value.M21;
            this.planes[3].Normal.Z = -value.M34 + value.M31;
            this.planes[3].D = -value.M44 + value.M41;
            this.planes[4].Normal.X = -value.M14 + value.M12;
            this.planes[4].Normal.Y = -value.M24 + value.M22;
            this.planes[4].Normal.Z = -value.M34 + value.M32;
            this.planes[4].D = -value.M44 + value.M42;
            this.planes[5].Normal.X = -value.M14 - value.M12;
            this.planes[5].Normal.Y = -value.M24 - value.M22;
            this.planes[5].Normal.Z = -value.M34 - value.M32;
            this.planes[5].D = -value.M44 - value.M42;
            this.planes[0].Normal.X = -value.M13;
            this.planes[0].Normal.Y = -value.M23;
            this.planes[0].Normal.Z = -value.M33;
            this.planes[0].D = -value.M43;
            this.planes[1].Normal.X = -value.M14 + value.M13;
            this.planes[1].Normal.Y = -value.M24 + value.M23;
            this.planes[1].Normal.Z = -value.M34 + value.M33;
            this.planes[1].D = -value.M44 + value.M43;
            for (var i = 0; i < 6; i++) {
                var num2 = this.planes[i].Normal.Length();
                this.planes[i].Normal.SetScale(this.planes[i].Normal, 1 / num2);
                this.planes[i].D /= num2;
            }
            var ray = BoundingFrustum[".sm.ray"] || (BoundingFrustum[".sm.ray"] = new U1.Ray3());
            ray = BoundingFrustum.ComputeIntersectionLine(this.planes[0], this.planes[2], ray);
            BoundingFrustum.ComputeIntersection(this.planes[4], ray, this.cornerArray[0]);
            BoundingFrustum.ComputeIntersection(this.planes[5], ray, this.cornerArray[3]);
            ray = BoundingFrustum.ComputeIntersectionLine(this.planes[3], this.planes[0], ray);
            BoundingFrustum.ComputeIntersection(this.planes[4], ray, this.cornerArray[1]);
            BoundingFrustum.ComputeIntersection(this.planes[5], ray, this.cornerArray[2]);
            ray = BoundingFrustum.ComputeIntersectionLine(this.planes[2], this.planes[1], ray);
            BoundingFrustum.ComputeIntersection(this.planes[4], ray, this.cornerArray[4]);
            BoundingFrustum.ComputeIntersection(this.planes[5], ray, this.cornerArray[7]);
            ray = BoundingFrustum.ComputeIntersectionLine(this.planes[1], this.planes[3], ray);
            BoundingFrustum.ComputeIntersection(this.planes[4], ray, this.cornerArray[5]);
            BoundingFrustum.ComputeIntersection(this.planes[5], ray, this.cornerArray[6]);
        }
        get Bottom() {
            return this.planes[5];
        }
        get Far() {
            return this.planes[1];
        }
        get Left() {
            return this.planes[2];
        }
        get Near() {
            return this.planes[0];
        }
        get Right() {
            return this.planes[3];
        }
        get Top() {
            return this.planes[4];
        }
        get Matrix() {
            return this.matrix;
        }
        set Matrix(value) {
            this.SetMatrix(value);
        }
    }
    BoundingFrustum.CornerCount = 8;
    BoundingFrustum.NearPlaneIndex = 0;
    BoundingFrustum.FarPlaneIndex = 1;
    BoundingFrustum.LeftPlaneIndex = 2;
    BoundingFrustum.RightPlaneIndex = 3;
    BoundingFrustum.TopPlaneIndex = 4;
    BoundingFrustum.BottomPlaneIndex = 5;
    BoundingFrustum.NumPlanes = 6;
    BoundingFrustum.tmp_v3_0 = U1.Vector3.Zero;
    BoundingFrustum.tmp_v3_1 = U1.Vector3.Zero;
    BoundingFrustum.tmp_v3_2 = U1.Vector3.Zero;
    BoundingFrustum.tmp_v3_3 = U1.Vector3.Zero;
    BoundingFrustum.tmp_box_points = [
        U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero,
        U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero
    ];
    U1.BoundingFrustum = BoundingFrustum;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class BoundingSphere {
        constructor(center = U1.Vector3.Zero, radius = 0) {
            if (radius < 0) {
                throw "ArgumentException(\"NegativeRadius\")";
            }
            this.Center = new U1.Vector3(center.X, center.Y, center.Z);
            this.Radius = radius;
        }
        ConvertFromStr(value) {
            this.Center = this.Center == null ? new U1.Vector3() : this.Center;
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            var idx = 0;
            this.Center.X = items.length > idx ? (items[idx++]) : 0;
            this.Center.Y = items.length > idx ? (items[idx++]) : 0;
            this.Center.Z = items.length > idx ? (items[idx++]) : 0;
            this.Radius = items.length > idx ? (items[idx++]) : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this.Center.X, this.Center.Y, this.Center.Z, this.Radius);
        }
        Equals(other) {
            if (this.Center.Y != other.Center.Y)
                return false;
            if (this.Center.Z != other.Center.Z)
                return false;
            if (this.Center.X != other.Center.X)
                return false;
            if (this.Radius != other.Radius)
                return false;
            return true;
        }
        Clone() {
            var result = new BoundingSphere(this.Center.Clone(), this.Radius);
            return result;
        }
        CopyFrom(source) {
            this.Center.CopyFrom(source.Center);
            this.Radius = source.Radius;
        }
        static CreateMerged(original, additional, result = null) {
            var vect1 = U1.Vector3.Subtract(additional.Center, original.Center);
            var num = vect1.Length();
            var radius = original.Radius;
            var num2 = additional.Radius;
            if ((radius + num2) >= num) {
                if ((radius - num2) >= num) {
                    return original;
                }
                if ((num2 - radius) >= num) {
                    return additional;
                }
            }
            var vect2 = U1.Vector3.Scale(vect1, (1 / num));
            var num5 = Math.min(-radius, num - num2);
            var num4 = (Math.max(radius, num + num2) - num5) * 0.5;
            if (result == null)
                result = new BoundingSphere();
            result.Center.SetScaleAdd(original.Center, (num4 + num5), vect2);
            result.Radius = num4;
            return result;
        }
        SetCreateMerged(original, additional) {
            var vect = U1.Vector3.Subtract(additional.Center, original.Center);
            var num = vect.Length();
            var radius = original.Radius;
            var num2 = additional.Radius;
            if ((radius + num2) >= num) {
                if ((radius - num2) >= num) {
                    return original;
                }
                if ((num2 - radius) >= num) {
                    return additional;
                }
            }
            vect.Scale((1 / num));
            var num5 = Math.min(-radius, num - num2);
            var num4 = (Math.max(radius, num + num2) - num5) * 0.5;
            this.Center.SetAdd(original.Center, vect.Scale((num4 + num5)));
            this.Radius = num4;
            return this;
        }
        static CreateFromBoundingBox(box, result = null) {
            if (result == null)
                result = new BoundingSphere();
            result.Center.SetLerp(box.Min, box.Max, 0.5);
            var num = U1.Vector3.Distance(box.Min, box.Max);
            result.Radius = num * 0.5;
            return result;
        }
        SetCreateFromBoundingBox(box) {
            this.Center.SetLerp(box.Min, box.Max, 0.5);
            var num = U1.Vector3.Distance(box.Min, box.Max);
            this.Radius = num * 0.5;
            return this;
        }
        static CreateFromPoints(points, result = null) {
            var min = BoundingSphere[".cfp.min"] || (BoundingSphere[".cfp.min"] = new U1.Vector3());
            var max = BoundingSphere[".cfp.max"] || (BoundingSphere[".cfp.max"] = new U1.Vector3());
            min.SetMaxValue();
            max.SetMinValue();
            for (var i = 0; i < points.length; i++) {
                min = U1.Vector3.Min(points[i], min);
                max = U1.Vector3.Max(points[i], max);
            }
            if (result == null)
                result = new BoundingSphere();
            result.Center.SetAdd(min, max).Scale(0.5);
            result.Radius = U1.Vector3.Distance(min, max) / 2;
            return result;
        }
        SetCreateFromPoints(points) {
            var min = BoundingSphere[".scfp.min"] || (BoundingSphere[".scfp.min"] = new U1.Vector3());
            var max = BoundingSphere[".scfp.max"] || (BoundingSphere[".scfp.max"] = new U1.Vector3());
            min.SetMaxValue();
            max.SetMinValue();
            for (var i = 0; i < points.length; i++) {
                min.Minimize(points[i]);
                max.Maximize(points[i]);
            }
            this.Center.SetAdd(min, max).Scale(0.5);
            this.Radius = U1.Vector3.Distance(min, max) * 0.5;
            return this;
        }
        static CreateFromFrustum(frustum, result = null) {
            if (frustum == null) {
                throw "ArgumentNullException(\"frustum\")";
            }
            var points = frustum.CornerArray;
            result = this.CreateFromPoints(points, result);
            return result;
        }
        SetCreateFromFrustum(frustum) {
            if (frustum == null) {
                throw "ArgumentNullException(\"frustum\")";
            }
            return this.SetCreateFromPoints(frustum.CornerArray);
        }
        IntersectsBoundingBox(box) {
            var vector = U1.Vector3.Clamp(this.Center, box.Min, box.Max);
            var num = U1.Vector3.DistanceSquared(this.Center, vector);
            return (num <= (this.Radius * this.Radius));
        }
        IntersectsBoundingFrustum(frustum) {
            if (null == frustum) {
                throw "ArgumentNullException(\"frustum\", \"NullNotAllowed\")";
            }
            return frustum.IntersectsBoundingSphere(this);
        }
        IntersectsPlane(plane) {
            return plane.IntersectsBoundingSphere(this);
        }
        Intersects(ray) {
            return ray.IntersectsBoundingSphere(this);
        }
        IntersectsBoundingSphere(sphere) {
            var num3 = U1.Vector3.DistanceSquared(this.Center, sphere.Center);
            var radius1 = this.Radius;
            var radius2 = sphere.Radius;
            if ((((radius1 * radius1) + ((2 * radius1) * radius2)) + (radius2 * radius2)) <= num3) {
                return false;
            }
            return true;
        }
        ContainsBoundingBox(box) {
            if (!box.IntersectsBoundingSphere(this)) {
                return U1.ContainmentTypeEnum.Disjoint;
            }
            var vector = new U1.Vector3();
            var num = this.Radius * this.Radius;
            vector.X = this.Center.X - box.Min.X;
            vector.Y = this.Center.Y - box.Max.Y;
            vector.Z = this.Center.Z - box.Max.Z;
            if (vector.LengthSquareduared() > num) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            vector.X = this.Center.X - box.Max.X;
            vector.Y = this.Center.Y - box.Max.Y;
            vector.Z = this.Center.Z - box.Max.Z;
            if (vector.LengthSquareduared() > num) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            vector.X = this.Center.X - box.Max.X;
            vector.Y = this.Center.Y - box.Min.Y;
            vector.Z = this.Center.Z - box.Max.Z;
            if (vector.LengthSquareduared() > num) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            vector.X = this.Center.X - box.Min.X;
            vector.Y = this.Center.Y - box.Min.Y;
            vector.Z = this.Center.Z - box.Max.Z;
            if (vector.LengthSquareduared() > num) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            vector.X = this.Center.X - box.Min.X;
            vector.Y = this.Center.Y - box.Max.Y;
            vector.Z = this.Center.Z - box.Min.Z;
            if (vector.LengthSquareduared() > num) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            vector.X = this.Center.X - box.Max.X;
            vector.Y = this.Center.Y - box.Max.Y;
            vector.Z = this.Center.Z - box.Min.Z;
            if (vector.LengthSquareduared() > num) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            vector.X = this.Center.X - box.Max.X;
            vector.Y = this.Center.Y - box.Min.Y;
            vector.Z = this.Center.Z - box.Min.Z;
            if (vector.LengthSquareduared() > num) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            vector.X = this.Center.X - box.Min.X;
            vector.Y = this.Center.Y - box.Min.Y;
            vector.Z = this.Center.Z - box.Min.Z;
            if (vector.LengthSquareduared() > num) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            return U1.ContainmentTypeEnum.Contains;
        }
        ContainsBoundingFrustum(frustum) {
            if (null == frustum) {
                throw "ArgumentNullException(\"frustum\", \"NullNotAllowed\")";
            }
            if (!frustum.IntersectsBoundingSphere(this)) {
                return U1.ContainmentTypeEnum.Disjoint;
            }
            var num2 = this.Radius * this.Radius;
            var cornerarray = frustum.CornerArray;
            var vector = BoundingSphere[".cbf.v"] || (BoundingSphere[".cbf.v"] = new U1.Vector3());
            for (var i = 0; i < cornerarray.length; i++) {
                vector.X = cornerarray[i].X - this.Center.X;
                vector.Y = cornerarray[i].Y - this.Center.Y;
                vector.Z = cornerarray[i].Z - this.Center.Z;
                if (vector.LengthSquareduared() > num2) {
                    return U1.ContainmentTypeEnum.Intersects;
                }
            }
            return U1.ContainmentTypeEnum.Contains;
        }
        ContainsPoint(point) {
            if (U1.Vector3.DistanceSquared(point, this.Center) >= (this.Radius * this.Radius)) {
                return U1.ContainmentTypeEnum.Disjoint;
            }
            return U1.ContainmentTypeEnum.Contains;
        }
        ContainsBoundingSphere(sphere) {
            var num3 = U1.Vector3.Distance(this.Center, sphere.Center);
            var radius = this.Radius;
            var num = sphere.Radius;
            if ((radius + num) < num3) {
                return U1.ContainmentTypeEnum.Disjoint;
            }
            if ((radius - num) < num3) {
                return U1.ContainmentTypeEnum.Intersects;
            }
            return U1.ContainmentTypeEnum.Contains;
        }
        SupportMapping(v, result = null) {
            var result = new U1.Vector3();
            var num2 = v.Length();
            var num = this.Radius / num2;
            if (result == null)
                result = new U1.Vector3();
            result.X = this.Center.X + (v.X * num);
            result.Y = this.Center.Y + (v.Y * num);
            result.Z = this.Center.Z + (v.Z * num);
            return result;
        }
        static Transform(src, matrix, result = null) {
            if (result == null)
                result = new BoundingSphere();
            result.Center.SetTransform(src.Center, matrix);
            var num = ((matrix.M11 * matrix.M11) + (matrix.M12 * matrix.M12)) + (matrix.M13 * matrix.M13);
            var num2 = ((matrix.M21 * matrix.M21) + (matrix.M22 * matrix.M22)) + (matrix.M23 * matrix.M23);
            var num3 = ((matrix.M31 * matrix.M31) + (matrix.M32 * matrix.M32)) + (matrix.M33 * matrix.M33);
            var num4 = Math.max(num, Math.max(num2, num3));
            result.Radius = src.Radius * (Math.sqrt(num4));
            return result;
        }
        Transform(matrix, result = null) {
            this.Center.SetTransform(this.Center, matrix);
            var num = ((matrix.M11 * matrix.M11) + (matrix.M12 * matrix.M12)) + (matrix.M13 * matrix.M13);
            var num2 = ((matrix.M21 * matrix.M21) + (matrix.M22 * matrix.M22)) + (matrix.M23 * matrix.M23);
            var num3 = ((matrix.M31 * matrix.M31) + (matrix.M32 * matrix.M32)) + (matrix.M33 * matrix.M33);
            var num4 = Math.max(num, Math.max(num2, num3));
            this.Radius = this.Radius * (Math.sqrt(num4));
            return result;
        }
    }
    U1.BoundingSphere = BoundingSphere;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class GeometryHelper2 {
        static AngleBetween(start, end) {
            if (start.Equals(end))
                return 0;
            start = start.Clone();
            start.Normalize();
            end = end.Clone();
            end.Normalize();
            if (start.Equals(end))
                return 0;
            var a = U1.Vector2.Dot(start, end);
            a = U1.Clamp(a, -1, 1);
            return (Math.acos(a));
        }
        static AngleCCW(baseAxis, vector) {
            baseAxis = baseAxis.Clone();
            vector = vector.Clone();
            baseAxis.Normalize();
            vector.Normalize();
            var dotu = U1.Vector2.Dot(baseAxis, vector);
            if (dotu >= 1 - U1.Epsilon)
                return 0;
            var leftSide = new U1.Vector2(-baseAxis.Y, baseAxis.X);
            var dotv = U1.Vector2.Dot(leftSide, vector);
            dotu = U1.Clamp(dotu, -1, 1);
            if (dotv >= 0) {
                return Math.acos(dotu);
            }
            else {
                var pi2 = (Math.PI * 2);
                var a = (Math.acos(dotu));
                return pi2 - a;
            }
        }
        static CrossLineLine(s0, sd, t0, td) {
            var diff = U1.Vector2.Subtract(t0, s0);
            var a = U1.Vector2.Dot(diff, sd) / U1.Vector2.Dot(sd, sd);
            var b = U1.Vector2.Dot(td, sd) / U1.Vector2.Dot(sd, sd);
            var c = U1.Vector2.Dot(U1.Vector2.Negate(diff), td) / U1.Vector2.Dot(td, td);
            var d = U1.Vector2.Dot(sd, td) / U1.Vector2.Dot(td, td);
            if (1 - U1.PRECISION < b * d && b * d < 1 + U1.PRECISION) {
                return null;
            }
            else {
                var s = (a + b * c) / (1 - b * d);
                var t = c + d * s;
                return { s: s, t: t };
            }
        }
        static CrossLineLine1(line0, line1, result) {
            var d01 = GeometryHelper2[".cll1.v0"] || (GeometryHelper2[".cll1.v0"] = new U1.Vector2());
            var p0 = line0.Position, d0 = line0.Direction;
            var p1 = line1.Position, d1 = line1.Direction;
            d01.SetSubtract(p0, p1);
            if (result == null)
                result = new U1.Vector2();
            var o_crossv = result;
            var a = (d1.X) * (d01.Y) - (d1.Y) * (d01.X);
            var b = (d1.Y) * (d0.X) - (d1.X) * (d0.Y);
            if (Math.abs(b) < U1.MathHelper.PRECISION)
                return null;
            var t = a / b;
            o_crossv.SetScaleAdd(p0, t, d0);
            return o_crossv;
        }
        static CrossSegSeg(s0, s1, t0, t1, SAME_DIST = U1.Epsilon) {
            var ss;
            var ts;
            if (s0.X + SAME_DIST < t0.X &&
                s0.X + SAME_DIST < t1.X &&
                s1.X + SAME_DIST < t0.X &&
                s1.X + SAME_DIST < t1.X)
                return null;
            if (s0.X - SAME_DIST > t0.X &&
                s0.X - SAME_DIST > t1.X &&
                s1.X - SAME_DIST > t0.X &&
                s1.X - SAME_DIST > t1.X)
                return null;
            if (s0.Y + SAME_DIST < t0.Y &&
                s0.Y + SAME_DIST < t1.Y &&
                s1.Y + SAME_DIST < t0.Y &&
                s1.Y + SAME_DIST < t1.Y)
                return null;
            if (s0.Y - SAME_DIST > t0.Y &&
                s0.Y - SAME_DIST > t1.Y &&
                s1.Y - SAME_DIST > t0.Y &&
                s1.Y - SAME_DIST > t1.Y)
                return null;
            if (U1.EpsilonEqualsPointPoint(s0, t0, SAME_DIST) && U1.EpsilonEqualsPointPoint(s1, t1, SAME_DIST)) {
                ss = [0, 1];
                ts = [0, 1];
                return { ss: ss, ts: ts };
            }
            if (U1.EpsilonEqualsPointPoint(s0, t1, SAME_DIST) && U1.EpsilonEqualsPointPoint(s1, t0, SAME_DIST)) {
                ss = [0, 1];
                ts = [0, 1];
                return { ss: ss, ts: ts };
            }
            var sd = U1.Vector2.Subtract(s1, s0);
            var td = U1.Vector2.Subtract(t1, t0);
            var s, t;
            var isect = GeometryHelper2.CrossLineLine(s0, sd, t0, td);
            if (isect != null) {
                var left = U1.Vector2.Normalize(sd.Left);
                var dt = Math.abs(U1.Vector2.Dot(left, U1.Vector2.Subtract(t0, s0)));
                if (dt > SAME_DIST)
                    return null;
                var s_l = sd.Length();
                var t_l = td.Length();
                sd.Normalize();
                td.Normalize();
                var s_list = new Array();
                var t_list = new Array();
                var vs = new Array();
                s = U1.Vector2.Dot(sd, U1.Vector2.Subtract(t0, s0));
                if (s >= 0 && s <= s_l) {
                    if (s < SAME_DIST)
                        s = 0;
                    if (s > s_l - SAME_DIST)
                        s = s_l;
                    s /= s_l;
                    s_list.push(s);
                    t_list.push(0);
                }
                s = U1.Vector2.Dot(sd, U1.Vector2.Subtract(t1, s0));
                if (s >= 0 && s <= s_l) {
                    if (s < SAME_DIST)
                        s = 0;
                    if (s > s_l - SAME_DIST)
                        s = s_l;
                    s /= s_l;
                    s_list.push(s);
                    t_list.push(1);
                }
                t = U1.Vector2.Dot(td, U1.Vector2.Subtract(s0, t0));
                if (t >= 0 && t <= t_l) {
                    if (t < SAME_DIST)
                        t = 0;
                    if (t > t_l - SAME_DIST)
                        t = t_l;
                    t /= t_l;
                    if (s_list.indexOf(0) < 0)
                        s_list.push(0);
                    if (t_list.indexOf(t) < 0)
                        t_list.push(t);
                }
                t = U1.Vector2.Dot(td, U1.Vector2.Subtract(s1, t0));
                if (t >= 0 && t <= t_l) {
                    if (t < SAME_DIST)
                        t = 0;
                    if (t > t_l - SAME_DIST)
                        t = t_l;
                    t /= t_l;
                    if (s_list.indexOf(1) < 0)
                        s_list.push(1);
                    if (t_list.indexOf(t) < 0)
                        t_list.push(t);
                }
                return { ss: s_list, ts: t_list };
            }
            else {
                if (s < 0 || s > 1 || t < 0 || t > 1)
                    return null;
                return { ss: [s], ts: [t] };
            }
        }
        static CrossCircleCircle(circle0, circle1) {
            var c = U1.Vector2.Distance(circle0.Center, circle1.Center);
            if (c < 0.00001)
                return null;
            if (c > circle0.Radius + circle1.Radius)
                return null;
            var cc = c * c;
            var rr = circle0.Radius * circle0.Radius;
            var ss = circle1.Radius * circle1.Radius;
            var a = (cc + rr - ss) / (2 * c);
            var l = rr - a * a;
            if (l < 0)
                return null;
            l = (Math.sqrt(l));
            var d = U1.Vector2.Normalize(U1.Vector2.Subtract(circle1.Center, circle0.Center));
            var rdir = new U1.Vector2(d.Y, -d.X);
            rdir.Normalize();
            var m = U1.Vector2.Add(circle0.Center, U1.Vector2.Scale(d, a));
            var p = U1.Vector2.Add(m, U1.Vector2.Scale(rdir, l));
            var p2 = U1.Vector2.Subtract(m, U1.Vector2.Scale(rdir, l));
            if (l == 0)
                return [p];
            return [p, p2];
        }
        static CrossSegmentSegment(segment0, segment1) {
            var max0 = U1.Vector2.Max(segment0.Start, segment0.End);
            var min0 = U1.Vector2.Min(segment0.Start, segment0.End);
            var max1 = U1.Vector2.Max(segment1.Start, segment1.End);
            var min1 = U1.Vector2.Min(segment1.Start, segment1.End);
            if (max0.X < min1.X || max0.Y < min1.Y)
                return null;
            if (min0.X > max1.X || min0.Y > max1.Y)
                return null;
            if (U1.EpsilonEqualsPointPoint(segment0.Start, segment1.Start) && U1.EpsilonEqualsPointPoint(segment0.End, segment1.End))
                return [segment0.Start, segment0.End];
            if (U1.EpsilonEqualsPointPoint(segment0.Start, segment1.End) && U1.EpsilonEqualsPointPoint(segment0.End, segment1.Start))
                return [segment0.Start, segment0.End];
            var d0 = U1.Vector2.Subtract(segment0.End, segment0.Start);
            var d1 = U1.Vector2.Subtract(segment1.End, segment1.Start);
            var line0 = new U1.Line2(segment0.Start, d0);
            var line1 = new U1.Line2(segment1.Start, d1);
            var l0 = d0.Length();
            d0.Normalize();
            var l1 = d1.Length();
            d1.Normalize();
            var crossv = U1.Line2.GetIntersectPoint(line0, line1);
            if (crossv == null) {
                if (U1.Line2.DistanceSquared(line0, line1.Position) > U1.PRECISION)
                    return null;
                var vs = new Array();
                var l2 = U1.Vector2.Dot(d0, U1.Vector2.Subtract(segment1.Start, segment0.Start));
                if (l2 >= 0 && l2 <= l0)
                    vs.push(segment1.Start);
                l2 = U1.Vector2.Dot(d0, U1.Vector2.Subtract(segment1.End, segment0.Start));
                if (l2 >= 0 && l2 <= l0) {
                    if (vs.indexOf(segment1.End) < 0)
                        vs.push(segment1.End);
                }
                l2 = U1.Vector2.Dot(d1, U1.Vector2.Subtract(segment0.Start, segment1.Start));
                if (l2 >= 0 && l2 <= l1) {
                    if (vs.indexOf(segment0.Start) < 0)
                        vs.push(segment0.Start);
                }
                l2 = U1.Vector2.Dot(d1, U1.Vector2.Subtract(segment0.End, segment1.Start));
                if (l2 >= 0 && l2 <= l1) {
                    if (vs.indexOf(segment0.End) < 0)
                        vs.push(segment0.End);
                }
                if (vs.length == 0)
                    return null;
                return vs;
            }
            else {
                var s = U1.Vector2.Dot(d0, U1.Vector2.Subtract(crossv, segment0.Start));
                var t = U1.Vector2.Dot(d1, U1.Vector2.Subtract(crossv, segment1.Start));
                if (s < 0 || s > l0 || t < 0 || t > l1)
                    return null;
                if (U1.EpsilonEqualsPointPoint(segment0.Start, segment1.Start) || U1.EpsilonEqualsPointPoint(segment0.Start, segment1.End))
                    return [segment0.Start];
                if (U1.EpsilonEqualsPointPoint(segment0.End, segment1.Start) || U1.EpsilonEqualsPointPoint(segment0.End, segment1.End))
                    return [segment0.End];
                return [crossv];
            }
        }
        static CrossLineCircle(line, circle) {
            var d = U1.Vector2.Normalize(line.Direction);
            var cp = U1.Vector2.Subtract(circle.Center, line.Position);
            var rr = circle.Radius * circle.Radius;
            var ll = cp.LengthSquareduared();
            var l2 = U1.Vector2.Dot(cp, d);
            var mm = ll - l2 * l2;
            if (mm > rr)
                return null;
            var t = (Math.sqrt(rr - mm));
            if (t == 0) {
                return [U1.Vector2.ScaleAdd(line.Position, (l2 - t), d)];
            }
            else {
                return [
                    U1.Vector2.ScaleAdd(line.Position, (l2 - t), d),
                    U1.Vector2.ScaleAdd(line.Position, (l2 + t), d)
                ];
            }
        }
        static CrossSegmentCircle(segment, circle) {
            var d = U1.Vector2.Subtract(segment.End, segment.Start);
            var ps = GeometryHelper2.CrossLineCircle(new U1.Line2(segment.Start, U1.Vector2.Subtract(segment.End, segment.Start)), circle);
            if (ps == null)
                return null;
            var len = d.Length();
            d.Normalize();
            var vs = new Array();
            for (var i = 0; i < ps.length; i++) {
                var p = U1.Vector2.Subtract(ps[i], segment.Start);
                var l1 = U1.Vector2.Dot(d, p);
                if (l1 >= 0 && l1 <= len) {
                    vs.push(ps[i]);
                }
            }
            if (vs.length > 0) {
                return vs;
            }
            return null;
        }
        static CrossSegmentArc(segment, arc) {
            var line0 = GeometryHelper2[".cros.l0"] || (GeometryHelper2[".cros.l0"] = new U1.Line2());
            var circ0 = GeometryHelper2[".cros.c0"] || (GeometryHelper2[".cros.c0"] = new U1.Circle2());
            line0.Position.CopyFrom(segment.Start);
            line0.Direction.SetSubtract(segment.End, segment.Start);
            circ0.Center.CopyFrom(arc.Center);
            circ0.Radius = arc.Radius;
            var vs = GeometryHelper2.CrossLineCircle(line0, circ0);
            if (vs == null)
                return null;
            var vs = [];
            for (var i = 0; i < vs.length; i++) {
                var p = vs[i];
                if (GeometryHelper2.CheckOnArc(p, arc))
                    vs.push(p);
            }
            return vs;
        }
        static CrossArcArc(arc0, arc1) {
            var IsSame = GeometryHelper2.IsSame;
            if (IsSame(arc0.Start, arc1.Start) && IsSame(arc0.End, arc1.End))
                return [arc0.Start, arc0.End];
            if (IsSame(arc0.End, arc1.Start) && IsSame(arc0.Start, arc1.End))
                return [arc0.Start, arc0.End];
            var c0 = arc0.Center;
            var r0 = U1.Vector2.Subtract(arc0.Start, c0).Length();
            var c1 = arc1.Center;
            var r1 = U1.Vector2.Subtract(arc1.Start, c1).Length();
            var ps = GeometryHelper2.CrossCircleCircle(new U1.Circle2(c0, r0), new U1.Circle2(c1, r1));
            if (ps == null)
                return null;
            for (var i = 0; i < ps.length; i++) {
                var p = ps[i];
                if (IsSame(arc0.Start, p))
                    ps[i] = arc0.Start;
                if (IsSame(arc0.End, p))
                    ps[i] = arc0.End;
                if (IsSame(arc1.Start, p))
                    ps[i] = arc1.Start;
                if (IsSame(arc1.End, p))
                    ps[i] = arc1.End;
            }
            var vs = [];
            for (var i = 0; i < ps.length; i++) {
                if (GeometryHelper2.CheckOnArc(ps[i], arc0)
                    && GeometryHelper2.CheckOnArc(ps[i], arc1))
                    vs.push(ps[i]);
            }
            if (vs.length > 0) {
                return vs;
            }
            return null;
        }
        static IsSame(point0, point1) {
            if (Math.abs(point1.X - point0.X) > U1.MathHelper.PRECISION)
                return false;
            if (Math.abs(point1.Y - point0.Y) > U1.MathHelper.PRECISION)
                return false;
            return true;
        }
        static CheckOnArc(pos, arc) {
            if (Math.abs(U1.Vector2.Distance(pos, arc.Center) - arc.Radius) > U1.MathHelper.PRECISION) {
                return false;
            }
            var tv0 = GeometryHelper2[".coa.v0"] || (GeometryHelper2[".coa.v0"] = new U1.Vector2());
            var tv1 = GeometryHelper2[".coa.v1"] || (GeometryHelper2[".coa.v1"] = new U1.Vector2());
            var tv2 = GeometryHelper2[".coa.v2"] || (GeometryHelper2[".coa.v2"] = new U1.Vector2());
            var vec0 = tv0.SetSubtract(arc.Start, arc.Center);
            var vec1 = tv1.SetSubtract(arc.End, arc.Center);
            var vec2 = tv2.SetSubtract(pos, arc.Center);
            var ang = GeometryHelper2.AngleCCW(vec0, vec1);
            var ta = GeometryHelper2.AngleCCW(vec0, vec2);
            if (arc.Bulge >= 0)
                return ta <= ang;
            else
                return (ta == 0) || (ang <= ta && ta <= U1.MathHelper.TwoPi);
        }
        static GetOffsetArc(arc, offset) {
            var offsetArc = new U1.Arc2();
            var cent = arc.Center;
            var n0 = new U1.Vector2();
            var n1 = new U1.Vector2();
            var len = U1.Vector2.Distance(arc.Start, cent);
            if (arc.Bulge == 0) {
                n0 = n1 = U1.Vector2.Normalize(arc.Right());
            }
            else {
                n0.SetSubtract(arc.Start, cent).Normalize();
                n1.SetSubtract(arc.End, cent).Normalize();
            }
            if (arc.Bulge > 0) {
                offsetArc.Start.SetScaleAdd(arc.Start, offset, n0);
                offsetArc.End.SetScaleAdd(arc.End, offset, n1);
            }
            else {
                offsetArc.Start.SetScaleAdd(arc.Start, -offset, n0);
                offsetArc.End.SetScaleAdd(arc.End, -offset, n1);
            }
            offsetArc.Bulge = arc.Bulge * U1.Vector2.Distance(offsetArc.Start, cent) / len;
            return offsetArc;
        }
        static SplitArc(baseAxis, startAngle, endAngle, segmentCount) {
            var left = new U1.Vector2(-baseAxis.Y, baseAxis.X);
            var rv = [];
            var delt = (endAngle - startAngle) / segmentCount;
            var ang = startAngle;
            for (var i = 0; i <= segmentCount; i++, ang += delt) {
                if (i == segmentCount)
                    ang = endAngle;
                var cosA = Math.cos(ang);
                var sinA = Math.sin(ang);
                rv[i] = U1.Vector2.Scale(baseAxis, cosA).Add(U1.Vector2.Scale(left, sinA));
            }
            return rv;
        }
        static OffsetPolygon(polygon, offset) {
            if (polygon.length < 3)
                return null;
            var result = [];
            var pi = polygon.length - 1;
            for (var ci = 0; ci < polygon.length; pi = ci, ++ci) {
                var ni = ci + 1;
                if (ni >= polygon.length)
                    ni = 0;
                var pp = polygon[pi];
                var cp = polygon[ci];
                var np = polygon[ni];
                var d1 = U1.Vector2.Subtract(cp, pp).Normalize();
                var d2 = U1.Vector2.Subtract(np, cp).Normalize();
                var r1 = d1.Right;
                var r2 = d2.Right;
                var cp1 = U1.Vector2.ScaleAdd(cp, offset, r1);
                var cp2 = U1.Vector2.ScaleAdd(cp, offset, r2);
                if (isNaN(cp1.X) || isNaN(cp1.Y)) {
                    if (isNaN(cp2.X) || isNaN(cp2.Y))
                        continue;
                    result.push(cp2);
                    continue;
                }
                else if (isNaN(cp2.X) || isNaN(cp2.Y)) {
                    result.push(cp1);
                    continue;
                }
                if (U1.Vector2.Dot(d1, d2) < -1 + U1.PRECISION) {
                    result.push(cp1);
                    result.push(cp2);
                    continue;
                }
                if (U1.Vector2.DistanceSquared(cp1, cp2) < U1.PRECISION) {
                    result.push(U1.Vector2.Add(cp1, cp2).Scale(1 / 2));
                }
                else {
                    var cross_res = GeometryHelper2.CrossLineLine(cp1, d1, cp2, d2);
                    if (cross_res != null)
                        result.push(U1.Vector2.ScaleAdd(cp1, cross_res.s, d1));
                }
            }
            return result;
        }
        static OffsetPolyline(polyline, offset) {
            if (offset == 0)
                return polyline;
            if (polyline.length < 2)
                return null;
            var result = [];
            var pi = polyline.length - 1;
            for (var ci = 0; ci < polyline.length; pi = ci, ++ci) {
                var ni = ci + 1;
                if (ni >= polyline.length)
                    ni = 0;
                var pp = polyline[pi];
                var cp = polyline[ci];
                var np = polyline[ni];
                var d1 = U1.Vector2.Subtract(cp, pp).Normalize();
                var d2 = U1.Vector2.Subtract(np, cp).Normalize();
                var r1 = d1.Right;
                var r2 = d2.Right;
                var cp1 = U1.Vector2.ScaleAdd(cp, offset, r1);
                var cp2 = U1.Vector2.ScaleAdd(cp, offset, r2);
                if (ci == 0) {
                    result.push(cp2);
                    continue;
                }
                else if (ci == polyline.length - 1) {
                    result.push(cp1);
                    continue;
                }
                if (U1.Vector2.Dot(d1, d2) < -1 + U1.PRECISION) {
                    result.push(cp1);
                    result.push(cp2);
                    continue;
                }
                if (U1.Vector2.DistanceSquared(cp1, cp2) < U1.PRECISION) {
                    result.push(U1.Vector2.Add(cp1, cp2).Scale(1 / 2));
                }
                else {
                    var res = GeometryHelper2.CrossLineLine(cp1, d1, cp2, d2);
                    if (res != null)
                        result.push(U1.Vector2.ScaleAdd(cp1, res.s, d1));
                }
            }
            return result;
        }
    }
    U1.GeometryHelper2 = GeometryHelper2;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class GeometryHelper3 {
        static AngleBetween(start, end) {
            if (start == U1.Vector3.Zero || end == U1.Vector3.Zero)
                return 0;
            start.Normalize();
            end.Normalize();
            if (start == end)
                return 0;
            var a = U1.Vector3.Dot(start, end);
            a = U1.MathHelper.Clamp(a, -1, 1);
            var result = Math.acos(a);
            if (Number.NaN == result || Number.MIN_VALUE == result || Number.MAX_VALUE == result)
                result = 0;
            return Math.max(0, Math.min(Math.PI, Math.acos(a)));
        }
        static AngleCCW(baseVector, planeNormal, vector) {
            if (planeNormal.IsZero)
                return 0;
            vector.Normalize();
            baseVector.Normalize();
            var leftSide = U1.Vector3.Cross(planeNormal, baseVector);
            var dotu = U1.Vector3.Dot(baseVector, vector);
            var dotv = U1.Vector3.Dot(leftSide, vector);
            dotu = U1.Clamp(dotu, -1, 1);
            if (dotv >= 0) {
                return Math.acos(dotu);
            }
            else {
                var pi2 = (Math.PI * 2);
                var a = Math.acos(dotu);
                return pi2 - a;
            }
        }
        static PolygonNormal(points, start, length, normalize, res_normal) {
            var okPolygon = (start < points.length)
                && (start + length <= points.length)
                && (length > 2);
            if (okPolygon) {
                res_normal.Set(0.0, 0.0, 0.0);
                for (var i = 0; i < length; i++) {
                    var p1 = points[(start + i)];
                    var p2 = points[(start + (i + 1) % length)];
                    res_normal.X += (p1.Y - p2.Y) * (p1.Z + p2.Z);
                    res_normal.Y += (p1.Z - p2.Z) * (p1.X + p2.X);
                    res_normal.Z += (p1.X - p2.X) * (p1.Y + p2.Y);
                }
                if (normalize) {
                    var lengthSqr = res_normal.X * res_normal.X + res_normal.Y * res_normal.Y + res_normal.Z * res_normal.Z;
                    if (lengthSqr > 0.0) {
                        var invLength = 1.0 / Math.sqrt(lengthSqr);
                        res_normal.Scale(invLength);
                    }
                    else {
                        okPolygon = false;
                    }
                }
            }
            return okPolygon;
        }
        static PolygonNormalByValues(values, start, normalize, res_normal) {
            var okPolygon = (start * 3 < values.length)
                && (start + length * 3 <= values.length)
                && (length > 2);
            var p1 = new U1.Vector3();
            var p2 = new U1.Vector3();
            if (okPolygon) {
                res_normal.Set(0.0, 0.0, 0.0);
                for (var i = 0; i < length; i++) {
                    var vi = (i + start) * 3;
                    p1.X = values[vi++];
                    p1.Y = values[vi++];
                    p1.Z = values[vi++];
                    p2.X = values[vi++];
                    p2.Y = values[vi++];
                    p2.Z = values[vi];
                    res_normal.X += (p1.Y - p2.Y) * (p1.Z + p2.Z);
                    res_normal.Y += (p1.Z - p2.Z) * (p1.X + p2.X);
                    res_normal.Z += (p1.X - p2.X) * (p1.Y + p2.Y);
                }
                if (normalize) {
                    var lengthSqr = res_normal.X * res_normal.X + res_normal.Y * res_normal.Y + res_normal.Z * res_normal.Z;
                    if (lengthSqr > 0.0) {
                        var invLength = 1.0 / Math.sqrt(lengthSqr);
                        res_normal.Scale(invLength);
                    }
                    else {
                        okPolygon = false;
                    }
                }
            }
            return okPolygon;
        }
        static GetArbitraryAxis(normal, udir, vdir) {
            var unit_y = GeometryHelper3[".gaa.v."] || (GeometryHelper3[".gaa.v."] = new U1.Vector3());
            var t = 0.015625;
            if ((Math.abs(normal.X) < t) && (Math.abs(normal.Y) < t)) {
                unit_y.SetUnitY();
            }
            else {
                unit_y.SetUnitZ();
            }
            udir.SetCross(unit_y, normal).Normalize();
            vdir.SetCross(normal, udir).Normalize();
        }
        static GetArcCenter(start, end, normal, bulge) {
            if (start == end)
                return start;
            if (bulge == 0)
                throw (new Error("Line"));
            var middle = U1.Vector3.Add(start, end);
            middle = new U1.Vector3(middle.X * 0.5, middle.Y * 0.5, middle.Z * 0.5);
            var dir = U1.Vector3.Subtract(end, start);
            var l = dir.Length() / 2.0;
            dir.Normalize();
            var rightDir = U1.Vector3.Cross(dir, normal);
            rightDir.Normalize();
            var m = Math.abs(bulge);
            var d = (l * l - m * m) / (2 * m);
            d = Math.round(d);
            if (bulge > 0)
                d *= -1;
            var p = U1.Vector3.Add(middle, rightDir);
            return new U1.Vector3(p.X * d, p.Y * d, p.Z * d);
        }
        static SplitArc(baseAxis, normal, startAngle, endAngle, segmentCount) {
            var left = U1.Vector3.Cross(normal, baseAxis);
            var rv = new U1.Vector3[segmentCount + 1];
            var delt = (endAngle - startAngle) / segmentCount;
            var ang = startAngle;
            for (var i = 0; i <= segmentCount; i++, ang += delt) {
                if (i == segmentCount)
                    ang = endAngle;
                var cosA = Math.cos(ang);
                var sinA = Math.sin(ang);
                var a = new U1.Vector3(baseAxis.X * cosA, baseAxis.Y * cosA, baseAxis.Z * cosA);
                var b = new U1.Vector3(left.X * sinA, left.Y * sinA, left.Z * sinA);
                rv[i] = U1.Vector3.Add(a, b);
            }
            return rv;
        }
        static GetRotationM2M(src, target) {
            var result = { axis: U1.Vector3.Zero, angle: 0, roll: 0 };
            var srcv = src.Backward;
            var tgtv = target.Backward;
            if (Math.abs(src.Backward.Z - target.Backward.Z) < 0.0001) {
                srcv.Z = tgtv.Z = 0;
                srcv.Normalize();
                tgtv.Normalize();
            }
            result.axis.SetCross(srcv, tgtv).Normalize();
            var dt = U1.Vector3.Dot(srcv, tgtv);
            if (dt > 0.999 || dt < -0.999)
                result.axis.SetUnitZ();
            result.angle = (Math.acos(dt));
            var rm = GeometryHelper3[".grm.rm"] || (GeometryHelper3[".grm.rm"] = new U1.Matrix4());
            rm.SetCreateFromAxisAngle(result.axis, result.angle);
            rm.SetMultiply(src, rm);
            var src_right = rm.Right;
            var tgt_right = target.Right;
            var normal = rm.Backward;
            result.roll = GeometryHelper3.AngleCCW(src_right, normal, tgt_right);
            if (result.roll > Math.PI)
                result.roll = -(Math.PI * 2 - result.roll);
            return result;
        }
        static RayBoxIntersection(rayOrigin, rayDir, boxMin, boxMax, dirCheck) {
            var maxS = -1.7976931348623157E308;
            var minT = Number.MAX_VALUE;
            if ((rayDir.X > -1.0E-6) && (rayDir.X < 1.0E-6)) {
                if ((rayOrigin.X < boxMin.X) || (rayOrigin.X > boxMax.X)) {
                    return false;
                }
            }
            else {
                var s = (boxMin.X - rayOrigin.X) / rayDir.X;
                var t = (boxMax.X - rayOrigin.X) / rayDir.X;
                if (s > t) {
                    var temp = s;
                    s = t;
                    t = temp;
                }
                if (s > maxS) {
                    maxS = s;
                }
                if (t < minT) {
                    minT = t;
                }
                if ((maxS > minT) || ((dirCheck) && (minT < 0.0))) {
                    return false;
                }
            }
            if ((rayDir.Y > -1.0E-6) && (rayDir.Y < 1.0E-6)) {
                if ((rayOrigin.Y < boxMin.Y) || (rayOrigin.Y > boxMax.Y)) {
                    return false;
                }
            }
            else {
                var s = (boxMin.Y - rayOrigin.Y) / rayDir.Y;
                var t = (boxMax.Y - rayOrigin.Y) / rayDir.Y;
                if (s > t) {
                    var temp = s;
                    s = t;
                    t = temp;
                }
                if (s > maxS) {
                    maxS = s;
                }
                if (t < minT) {
                    minT = t;
                }
                if ((maxS > minT) || ((dirCheck) && (minT < 0.0))) {
                    return false;
                }
            }
            if ((rayDir.Z > -1.0E-6) && (rayDir.Z < 1.0E-6)) {
                if ((rayOrigin.Z < boxMin.Z) || (rayOrigin.Z > boxMax.Z)) {
                    return false;
                }
            }
            else {
                var s = (boxMin.Z - rayOrigin.Z) / rayDir.Z;
                var t = (boxMax.Z - rayOrigin.Z) / rayDir.Z;
                if (s > t) {
                    var temp = s;
                    s = t;
                    t = temp;
                }
                if (s > maxS) {
                    maxS = s;
                }
                if (t < minT) {
                    minT = t;
                }
                if ((maxS > minT) || ((dirCheck) && (minT < 0.0))) {
                    return false;
                }
            }
            return true;
        }
        static BoxBoxIntersection(min1, max1, min2, max2) {
            if ((min1.X > max2.X) || (min2.X > max1.X)) {
                return false;
            }
            if ((min1.Y > max2.Y) || (min2.Y > max1.Y)) {
                return false;
            }
            if ((min1.Z > max2.Z) || (min2.Z > max1.Z)) {
                return false;
            }
            return true;
        }
        static PolygonPlaneIntersection(pgon, plane) {
            var fc = 0;
            var bc = 0;
            for (var i = 0; i < pgon.length; i++) {
                var tsign = plane.DotCoordinate(pgon[i]);
                if (tsign < 0.0001 && tsign > -0.0001)
                    continue;
                if (tsign < 0)
                    bc++;
                else
                    fc++;
                if (bc * fc > 0)
                    break;
            }
            if (fc === 0 || bc === 0)
                return fc > 0 ? U1.PlaneIntersectionTypeEnum.Front : U1.PlaneIntersectionTypeEnum.Back;
            return U1.PlaneIntersectionTypeEnum.Intersecting;
        }
    }
    GeometryHelper3.tmp_v30 = U1.Vector3.Zero;
    GeometryHelper3.tmp_v31 = U1.Vector3.Zero;
    U1.GeometryHelper3 = GeometryHelper3;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Line3 {
        constructor(position = null, direction = null) {
            this.Position = U1.Vector3.Zero;
            this.Direction = U1.Vector3.Zero;
            if (position != null)
                this.Position.CopyFrom(position);
            if (direction != null)
                this.Direction.CopyFrom(direction);
        }
        static SquardDistance(line0, line1, result) {
            var line0_p = line0.Position, line0_dir = line0.Direction, line1_p = line1.Position, line1_dir = line1.Direction;
            var diff = U1.Vector3.Subtract(line0_p, line1_p);
            var a = U1.Vector3.Dot(line0_dir, line0_dir);
            var b = -U1.Vector3.Dot(line0_dir, line1_dir);
            var c = U1.Vector3.Dot(line1_dir, line1_dir);
            var d = U1.Vector3.Dot(line0_dir, diff);
            var f = U1.Vector3.Dot(diff, diff);
            var det = a * c - b * b;
            var s = 0.0, t = 0.0;
            if (det > 0) {
                var e = -U1.Vector3.Dot(line1_dir, diff);
                var invDet = 1 / det;
                result.s = s = (b * e - c * d) * invDet;
                result.t = t = (b * d - a * e) * invDet;
                return s * (a * s + b * t + 2 * d) + t * (b * s + c * t + 2 * e) + f;
            }
            else {
                result.s = s = -d / a;
                result.t = t = 0;
                return d * s + f;
            }
        }
        static SquardDistance1(p0, d0, p1, d1, result) {
            var diff = U1.Vector3.Subtract(p0, p1);
            var a = U1.Vector3.Dot(d0, d0);
            var b = -U1.Vector3.Dot(d0, d1);
            var c = U1.Vector3.Dot(d1, d1);
            var d = U1.Vector3.Dot(d0, diff);
            var f = U1.Vector3.Dot(diff, diff);
            var det = a * c - b * b;
            var s = 0.0, t = 0.0;
            if (det > 0) {
                var e = -U1.Vector3.Dot(d1, diff);
                var invDet = 1 / det;
                result.s = s = (b * e - c * d) * invDet;
                result.t = t = (b * d - a * e) * invDet;
                return U1.Vector3.DistanceSquared(U1.Vector3.ScaleAdd(p0, s, d0), U1.Vector3.ScaleAdd(p1, t, d1));
            }
            else {
                result.s = s = -d / a;
                result.t = t = 0;
                return d * s + f;
            }
        }
    }
    U1.Line3 = Line3;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    U1.PRECISION = 0.00001;
    U1.Epsilon = 0.000001;
    function WithinEpsilon(a, b) {
        var num = a - b;
        return ((-0.00001 <= num) && (num <= 0.00001));
    }
    U1.WithinEpsilon = WithinEpsilon;
    function Clamp(value, min, max) {
        value = (value > max) ? max : value;
        value = (value < min) ? min : value;
        return value;
    }
    U1.Clamp = Clamp;
    function EpsilonEqualsPointPoint(point0, point1, epsilon = U1.Epsilon) {
        if (Math.abs(point1.X - point0.X) > epsilon)
            return false;
        if (Math.abs(point1.Y - point0.Y) > epsilon)
            return false;
        return true;
    }
    U1.EpsilonEqualsPointPoint = EpsilonEqualsPointPoint;
    var randomVector3s;
    var N_RANDOMS = 100;
    function CustomRandom(nseed) {
        var seed, constant = Math.pow(2, 13) + 1, prime = 37, maximum = Math.pow(2, 10);
        seed = nseed;
        return {
            next: function () {
                seed *= constant;
                seed += prime;
                seed %= maximum;
                return seed / maximum;
            }
        };
    }
    function RandomVector3() {
        if (randomVector3s == null) {
            randomVector3s = new Array();
            var random = CustomRandom(613973267);
            for (var i = 0; i < N_RANDOMS; i++) {
                var x = random.next() - 0.5;
                var y = random.next() - 0.5;
                var z = random.next() - 0.5;
                var ray = new U1.Vector3(x, y, z);
                ray.Normalize();
                randomVector3s[i] = ray;
            }
        }
        return randomVector3s;
    }
    U1.RandomVector3 = RandomVector3;
    let PlaneIntersectionTypeEnum;
    (function (PlaneIntersectionTypeEnum) {
        PlaneIntersectionTypeEnum[PlaneIntersectionTypeEnum["Front"] = 0] = "Front";
        PlaneIntersectionTypeEnum[PlaneIntersectionTypeEnum["Back"] = 1] = "Back";
        PlaneIntersectionTypeEnum[PlaneIntersectionTypeEnum["Intersecting"] = 2] = "Intersecting";
    })(PlaneIntersectionTypeEnum = U1.PlaneIntersectionTypeEnum || (U1.PlaneIntersectionTypeEnum = {}));
    let FaceIntersectionTypeEnum;
    (function (FaceIntersectionTypeEnum) {
        FaceIntersectionTypeEnum[FaceIntersectionTypeEnum["Outside"] = 0] = "Outside";
        FaceIntersectionTypeEnum[FaceIntersectionTypeEnum["Inside"] = 1] = "Inside";
        FaceIntersectionTypeEnum[FaceIntersectionTypeEnum["Boundary"] = 2] = "Boundary";
    })(FaceIntersectionTypeEnum = U1.FaceIntersectionTypeEnum || (U1.FaceIntersectionTypeEnum = {}));
    let ContainmentTypeEnum;
    (function (ContainmentTypeEnum) {
        ContainmentTypeEnum[ContainmentTypeEnum["Disjoint"] = 0] = "Disjoint";
        ContainmentTypeEnum[ContainmentTypeEnum["Contains"] = 1] = "Contains";
        ContainmentTypeEnum[ContainmentTypeEnum["Intersects"] = 2] = "Intersects";
    })(ContainmentTypeEnum = U1.ContainmentTypeEnum || (U1.ContainmentTypeEnum = {}));
    let ProjectionTypeEnum;
    (function (ProjectionTypeEnum) {
        ProjectionTypeEnum[ProjectionTypeEnum["Perspective"] = 0] = "Perspective";
        ProjectionTypeEnum[ProjectionTypeEnum["Orthographic"] = 1] = "Orthographic";
    })(ProjectionTypeEnum = U1.ProjectionTypeEnum || (U1.ProjectionTypeEnum = {}));
    class Viewport {
        constructor() {
            this.X = 0;
            this.Y = 0;
            this.Width = 100;
            this.Height = 100;
            this.MinDepth = 0;
            this.MaxDepth = 1;
        }
        toString() {
            return `X:${this.X} Y:${this.Y} Width:${this.Width} Height:${this.Height}`
                + ` MinDepth:${this.MinDepth} MaxDepth:${this.MaxDepth}`;
        }
        Project(source, projection, view, world, result) {
            var matrix = U1.Matrix4.Multiply(U1.Matrix4.Multiply(world, view), projection);
            var vector = U1.Vector3.Transform(source, matrix, result);
            var a = (((source.X * matrix.M14) + (source.Y * matrix.M24)) + (source.Z * matrix.M34)) + matrix.M44;
            if (!WithinEpsilon(a, 1)) {
                vector.Scale(1 / a);
            }
            vector.X = (((vector.X + 1) * 0.5) * this.Width) + this.X;
            vector.Y = (((-vector.Y + 1) * 0.5) * this.Height) + this.Y;
            vector.Z = (vector.Z * (this.MaxDepth - this.MinDepth)) + this.MinDepth;
            return vector;
        }
        ProjectWVP(source, wvp, result) {
            var vector = U1.Vector3.Transform(source, wvp, result);
            var a = (((source.X * wvp.M14) + (source.Y * wvp.M24)) + (source.Z * wvp.M34)) + wvp.M44;
            if (!WithinEpsilon(a, 1)) {
                vector.Scale(1 / a);
            }
            vector.X = ((((vector.X + 1) * 0.5) * this.Width) + this.X);
            vector.Y = ((((-vector.Y + 1) * 0.5) * this.Height) + this.Y);
            vector.Z = (vector.Z * (this.MaxDepth - this.MinDepth)) + this.MinDepth;
            return vector;
        }
        Unproject(source, projection, view, world, result) {
            var src = Viewport[".uprj.src"] || (Viewport[".uprj.src"] = new U1.Vector3());
            var matrix = Viewport[".uprj.m"] || (Viewport[".uprj.m"] = new U1.Matrix4());
            source = src.CopyFrom(source);
            matrix.SetMultiply(world, view).Multiply(projection).Invert();
            source.X = (((source.X - this.X) / (this.Width)) * 2) - 1;
            source.Y = -((((source.Y - this.Y) / (this.Height)) * 2) - 1);
            source.Z = (source.Z - this.MinDepth) / (this.MaxDepth - this.MinDepth);
            var vector = U1.Vector3.Transform(source, matrix, result);
            var a = (((source.X * matrix.M14) + (source.Y * matrix.M24)) + (source.Z * matrix.M34)) + matrix.M44;
            if (!WithinEpsilon(a, 1)) {
                vector.Scale(1 / a);
            }
            return vector;
        }
        get AspectRatio() {
            if ((this.Height != 0) && (this.Width != 0)) {
                return ((this.Width) / (this.Height));
            }
            return 0;
        }
        static Project(source, projection, view, world, minDepth, maxDepth, x, y, width, heiht, result) {
            var matrix = Viewport[".prj.m"] || (Viewport[".prj.m"] = new U1.Matrix4());
            matrix.SetMultiply(world, view).Multiply(projection);
            var vector = U1.Vector3.Transform(source, matrix, result);
            var a = (((source.X * matrix.M14) + (source.Y * matrix.M24)) + (source.Z * matrix.M34)) + matrix.M44;
            if (!WithinEpsilon(a, 1)) {
                vector.Scale(1 / a);
            }
            vector.X = (((vector.X + 1) * 0.5) * width) + x;
            vector.Y = (((-vector.Y + 1) * 0.5) * heiht) + y;
            vector.Z = (vector.Z * (maxDepth - minDepth)) + minDepth;
            return vector;
        }
        Equals(other) {
            return this.X == other.X &&
                this.Y == other.Y &&
                this.MinDepth == other.MinDepth &&
                this.MaxDepth == other.MaxDepth &&
                this.Width == other.Width &&
                this.Height == other.Height;
        }
    }
    Viewport.PRECISION = 0.000001;
    U1.Viewport = Viewport;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UElement {
        constructor() {
            this._hnd = ++UElement.s_hnd;
        }
        get PropertyChanged() {
            if (this._PropertyChanged == null)
                this._PropertyChanged = new U1.PropertyChangedEvent();
            return this._PropertyChanged;
        }
        get Removing() {
            if (this._Removing == null)
                this._Removing = new U1.Event1();
            return this._Removing;
        }
        get ID() {
            return this._id;
        }
        get Document() {
            return this._document;
        }
        get HND() {
            return this._hnd;
        }
        get IsFrozen() {
            if (this._isfrozen === true)
                return true;
            return false;
        }
        GetTypeName() {
            var funcNameRegex = /function (.{1,})\(/;
            var results = (funcNameRegex).exec((this).constructor.toString());
            return (results && results.length > 1) ? results[1] : "";
        }
        InvokePropertyChanged(prop) {
            this.OnPropertyChanged(prop);
            if (this._PropertyChanged != null) {
                this.PropertyChanged.Invoke(this, prop);
            }
            if (this.Document != null)
                this.Document.InvokeElementChanged(this, prop);
        }
        InvokeRemoving() {
            if (this._Removing != null) {
                this._Removing.Invoke(this);
            }
        }
        OnPropertyChanged(prop) {
        }
        get PropertyCategory() {
            return this.GetTypeName();
        }
        GetProperties() {
            return [];
        }
        ClassifiedByType() {
            return true;
        }
        OnInitAfterLoaded() {
        }
        OnInitAfterCreated() {
        }
        OnBeforeEndTransaction() {
        }
        SetProperty(prop_name, field_name, new_val) {
            if (typeof prop_name !== "string")
                return;
            if (this._isfrozen === true)
                return;
            let old_val = this[field_name];
            if (old_val === new_val)
                return;
            this[field_name] = new_val;
            if (this.Document != null && this.Document.CurrentTransaction != null) {
                var cmd = new U1.UUndoCmdProp(this, prop_name, field_name, old_val, new_val);
                this.Document.CurrentTransaction.AddCommand(cmd);
            }
            this.InvokePropertyChanged(prop_name);
        }
        SetRelProperty(prop_name, field_name, new_val) {
            if (typeof prop_name !== "string")
                return;
            if (this._isfrozen === true)
                return;
            let old_val = this[field_name];
            if (old_val === new_val)
                return;
            this[field_name] = new_val;
            if (this.Document != null && this.Document.CurrentTransaction != null) {
                var cmd = new U1.UUndoCmdRefProp(this, prop_name, field_name, old_val, new_val);
                this.Document.CurrentTransaction.AddCommand(cmd);
            }
            this.UpdateInverce(prop_name, old_val, new_val);
            this.InvokePropertyChanged(prop_name);
        }
        UpdateInverce(prop_name, ov, nv) {
            if (ov instanceof UElement) {
                ov.RemoveInv(this, prop_name);
            }
            else if (Array.isArray(ov)) {
                for (var v of ov) {
                    if (v instanceof UElement) {
                        v.RemoveInv(this, prop_name);
                    }
                }
            }
            if (nv instanceof UElement) {
                nv.AddInv(this, prop_name);
            }
            else if (Array.isArray(nv)) {
                for (var v of nv) {
                    if (v instanceof UElement) {
                        v.AddInv(this, prop_name);
                    }
                }
            }
        }
        GetInverse(type, prop) {
            if (this._inv_map == null || !this._inv_map[prop])
                return [];
            return this._inv_map[prop].filter(o_ => o_ instanceof type);
        }
        AddInv(source, prop) {
            if (this._inv_map == null)
                this._inv_map = {};
            if (this._inv_map[prop] == null)
                this._inv_map[prop] = [];
            if (this._inv_map[prop].indexOf(source) > -1)
                return;
            this._inv_map[prop].push(source);
        }
        RemoveInv(source, prop) {
            if (this._inv_map == null)
                return;
            if (this._inv_map[prop] == null)
                return;
            let list = this._inv_map[prop];
            if (list.indexOf(source) < 0)
                return;
            list.splice(list.indexOf(source), 1);
        }
        Detach() {
            if (this.Document != null)
                this.Document.Remove(this);
        }
        Attach(doc) {
            doc.Append(this);
        }
        Clone(res_map) {
            let copy = new this.constructor;
            if (res_map != null) {
                res_map[this.HND] = copy;
            }
            let propBag = new U1.UPropertyBag();
            this.WriteProps(propBag);
            copy.ReadProps(propBag);
            return copy;
        }
        ReadProps(props) {
            props.Doc = props.Doc || this.Document;
        }
        WriteProps(props) {
            props.Doc = props.Doc || this.Document;
        }
        freeze() {
            this._isfrozen = true;
        }
        unfreeze() {
            this._isfrozen = undefined;
        }
        GetUPropsCategory() {
            return this.GetTypeName();
        }
        GetUProps() {
            return null;
        }
    }
    UElement.s_hnd = 0;
    U1.UElement = UElement;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UNode extends U1.UElement {
        constructor() {
            super(...arguments);
            this.num = 0;
        }
        get Parent() {
            return this.parent;
        }
        set Parent(val) {
            this.SetRelProperty("Parent", "parent", val);
        }
        get Num() {
            return this.num;
        }
        set Num(value) {
            this.SetProperty("Num", "num", value);
        }
        get Name() {
            return this.name;
        }
        set Name(value) {
            this.SetProperty("Name", "name", value);
        }
        get Children() {
            var children = this.GetInverse(UNode, "Parent");
            children = children.sort((a_, b_) => {
                if (a_.Num == b_.Num)
                    return 0;
                if (a_.Num < b_.Num)
                    return -1;
                return 1;
            });
            return children;
        }
        FindAncestor(type) {
            if (this.parent == null)
                return null;
            if (this.parent.constructor === type ||
                this.parent instanceof type)
                return this.parent;
            return this.parent.FindAncestor(type);
        }
        GetChildren(type, name = null) {
            var children = this.GetInverse(type, "Parent");
            if (name != null)
                children = children.filter(o_ => o_.Name === name);
            children = children.sort((a_, b_) => {
                if (a_.Num == b_.Num)
                    return 0;
                if (a_.Num < b_.Num)
                    return -1;
                return 1;
            });
            return children;
        }
        Append(child) {
            if (child.Document != null && child.Document != this.Document)
                throw "Other document has already been assigned.";
            if (child.Parent != null)
                throw "Other parent has already been assigned.";
            if (child.Document == null && this.Document != null)
                child.Attach(this.Document);
            child.Parent = this;
            if (this.last_num === undefined) {
                var children = this.Children;
                this.last_num = -1;
                for (var ch of children) {
                    if (this.last_num < ch.Num) {
                        this.last_num = ch.Num;
                    }
                }
            }
            child.Num = ++this.last_num;
        }
        Remove(child) {
            if (this.Children.indexOf(child) > -1) {
                child.Parent = null;
                if (this.Document != null)
                    this.Document.Remove(child);
            }
        }
        AddChild(ctr, name) {
            var child = new ctr();
            child.Name = name;
            this.Append(child);
            return child;
        }
        AddChildCopy(child, name) {
            let nch = child.Clone();
            nch.name = name;
            this.Append(nch);
            return child;
        }
        GetChild(ctor, name) {
            if (name == null || name == "")
                return null;
            name = name.toUpperCase();
            for (var ch of this.Children) {
                if (ctor == null || ch instanceof ctor) {
                    if (ch.Name == null)
                        continue;
                    if (ch.Name.toUpperCase() == name) {
                        return ch;
                    }
                }
            }
            return null;
        }
        OnPropertyChanged(prop) {
            if (prop === "Parent") {
                if (this.Parent != null)
                    this.Parent.OnChildAdded(this);
            }
            if (this.Parent != null)
                this.Parent.InvokeChildPropertyChanged(this, name);
        }
        OnChildPropertyChanged(source, name) {
        }
        OnChildAdded(child) {
        }
        OnChildDeleting(child) {
        }
        TransmitChildPropertyChanged(source, name) {
            return true;
        }
        InvokeChildPropertyChanged(source, name) {
            this.OnChildPropertyChanged(source, name);
            if (this.Parent != null && this.Parent.TransmitChildPropertyChanged(source, name))
                this.Parent.InvokeChildPropertyChanged(source, name);
        }
        Clone(res_map) {
            let copy = super.Clone(res_map);
            for (let child of this.Children) {
                let nch = child.Clone(res_map);
                nch.Parent = copy;
            }
            copy.Parent = undefined;
            return copy;
        }
        ReadProps(props) {
            super.ReadProps(props);
            this.Num = props.GetInt("Num", this.num);
            this.Name = props.GetStr("Name", this.name);
            this.Parent = props.GetRef("Parent", this.parent);
        }
        WriteProps(props) {
            super.WriteProps(props);
            props.SetInt("Num", this.num);
            props.SetStr("Name", this.name);
            props.SetRef("Parent", this.parent);
        }
        freeze() {
            this._isfrozen = true;
            for (let ch of this.Children) {
                ch.freeze();
            }
        }
        unfreeze() {
            this._isfrozen = undefined;
            for (let ch of this.Children) {
                ch.unfreeze();
            }
        }
    }
    U1.UNode = UNode;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MModel extends U1.UNode {
            constructor() {
                super(...arguments);
                this._transform = U1.Matrix4.Identity;
                this._isWorldTransfornInvalid = true;
                this._worldTransform = U1.Matrix4.Identity;
            }
            get Transform() {
                return this._transform;
            }
            set Transform(value) {
                this.SetProperty("Transform", "_transform", value);
            }
            get WorldTransform() {
                if (!this._isWorldTransfornInvalid)
                    return this._worldTransform;
                if (this.Parent instanceof MModel) {
                    this._worldTransform
                        .SetMultiply(this.Parent.WorldTransform, this.Transform);
                }
                else {
                    this._worldTransform.CopyFrom(this.Transform);
                }
                return this._worldTransform;
            }
            get Mesh() {
                return this._mesh;
            }
            set Mesh(value) {
                this.SetRelProperty("Mesh", "_mesh", value);
            }
            get Mats() {
                return this.GetChildren(Meshes.MMtlUse);
            }
            set Mats(value) {
                let oldMats = this.Mats;
                for (let muse of oldMats)
                    this.Remove(muse);
                if (value != null) {
                    for (let muse of value) {
                        if (muse.Parent != null)
                            muse = muse.Clone();
                        this.Append(muse);
                    }
                }
            }
            GetMat(mgrp) {
                return this.Mats.filter(o_ => o_.MGrp == mgrp)[0];
            }
            SetMat(mgrp, mtl) {
                let muse = this.GetMat(mgrp);
                if (muse == null) {
                    muse = this.AddChild(Meshes.MMtlUse);
                    muse.MGrp = mgrp;
                }
                muse.Mat = mtl;
            }
            GetWorldOBB(res) {
                let obb = res || new U1.BoundingBox();
                this.Mesh.GetBoundingBox(obb, this.WorldTransform);
                return obb;
            }
            InvalidWorldTransform() {
                this._isWorldTransfornInvalid = true;
                for (var ch of this.Children) {
                    if (ch instanceof MModel) {
                        ch.InvalidWorldTransform();
                    }
                }
            }
            OnPropertyChanged(prop) {
                if (prop === "Transform") {
                    this.InvalidWorldTransform();
                }
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.Mesh = props.GetRef("Mesh", this.Mesh);
                this.Transform = props.GetValue(U1.Matrix4, "Transform", this.Transform);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetRef("Mesh", this.Mesh);
                props.SetValue("Transform", this.Transform);
            }
            Clone(res_map) {
                res_map = res_map || {};
                let copy = super.Clone(res_map);
                if (this.Mesh != null) {
                    let ch_mesh = res_map[this.Mesh.HND];
                    if (ch_mesh instanceof Meshes.MMesh) {
                        copy.Mesh = ch_mesh;
                    }
                }
                return copy;
            }
        }
        Meshes.MModel = MModel;
        U1.UDocument.Creaters["MModel"] = MModel;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MParamModel extends Meshes.MModel {
            UpdateMesh() {
                this.isMeshInvalid = false;
            }
            OnPropertyChanged(prop) {
                super.OnPropertyChanged(prop);
                if (prop !== "Transform") {
                    this.isMeshInvalid = true;
                }
            }
            OnBeforeEndTransaction() {
                if (this.isMeshInvalid) {
                    this.UpdateMesh();
                    this.isMeshInvalid = undefined;
                }
            }
        }
        Meshes.MParamModel = MParamModel;
        U1.UDocument.Creaters["MParamModel"] = MParamModel;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MWindowCube extends Meshes.MParamModel {
            constructor() {
                super(...arguments);
                this._w = 1.0;
                this._l = 1.0;
                this._h = 1.0;
            }
            get W() {
                return this._w;
            }
            set W(value) {
                this.SetProperty("W", "_w", value);
            }
            get L() {
                return this._l;
            }
            set L(value) {
                this.SetProperty("L", "_l", value);
            }
            get H() {
                return this._h;
            }
            set H(value) {
                this.SetProperty("H", "_h", value);
            }
            get BottomMargin() {
                return this.H * MWindowCube._bottomThick;
            }
            get TopMargin() {
                return this.H * MWindowCube._topThick;
            }
            get LeftMargin() {
                return this.W * MWindowCube._leftThick;
            }
            get RightMargin() {
                return this.W * MWindowCube._rightThick;
            }
            UpdateMesh() {
                let _vs = MWindowCube._vs;
                let _fs = MWindowCube._fs;
                let w = this.W;
                let l = this.L;
                let h = this.H;
                let size = new U1.Vector3(w, l, h);
                let mesh = this.Mesh;
                if (mesh != null) {
                    if (mesh.Parent == this)
                        this.Remove(mesh);
                }
                {
                    mesh = this.AddChild(Meshes.MMesh);
                }
                let texPrj = new Meshes.MTexPrj();
                texPrj.PrjKind = Meshes.MTexPrjKinds.Box;
                texPrj.XForm = U1.Matrix4.CreateScale(size);
                let ps = mesh.Vertics;
                let vmap = {};
                for (let i = 0; i < _vs.length; i++) {
                    let p = ps[i];
                    if (p == null) {
                        p = mesh.NewVert(U1.Vector3.Zero);
                    }
                    var v3 = _vs[i].Clone();
                    v3.Multiply(size);
                    p.P = v3;
                    vmap[i] = p;
                }
                var fs = mesh.Faces;
                for (let i = 0; i < _fs.length; i++) {
                    let f = fs[i];
                    if (f == null) {
                        f = mesh.NewFace();
                    }
                    f.Init({
                        loops: [_fs[i].map(o_ => vmap[o_])],
                        smgrp: i,
                        mgrp: i,
                        texPrj: texPrj
                    });
                }
                this.Mesh = mesh;
                super.UpdateMesh();
            }
            ReadProps(props) {
                super.ReadProps(props);
                this._w = props.GetFloat("W", this.W);
                this._l = props.GetFloat("L", this.L);
                this._h = props.GetFloat("H", this.H);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetFloat("W", this.W);
                props.SetFloat("L", this.L);
                props.SetFloat("H", this.H);
            }
            GetUPropsCategory() {
                return "WindowBox";
            }
            GetUProps() {
                var this_ = this;
                let props = [
                    new U1.UPropDouble({
                        GetValueFunc: () => this_.W,
                        SetValueFunc: (p_, v_) => this_.W = v_,
                        Label: "W",
                        EndChangeFunc: () => this_.UpdateMesh()
                    }),
                    new U1.UPropDouble({
                        GetValueFunc: () => this_.H,
                        SetValueFunc: (p_, v_) => this_.H = v_,
                        Label: "H",
                        EndChangeFunc: () => this_.UpdateMesh()
                    }),
                    new U1.UPropDouble({
                        GetValueFunc: () => this_.L,
                        SetValueFunc: (p_, v_) => this_.L = v_,
                        Label: "L",
                        EndChangeFunc: () => this_.UpdateMesh()
                    }),
                ];
                return props;
            }
        }
        MWindowCube._bottomThick = 0.02;
        MWindowCube._topThick = 0.02;
        MWindowCube._leftThick = 0.02;
        MWindowCube._rightThick = 0.02;
        MWindowCube._backThick = 0.02;
        MWindowCube._vs = [
            new U1.Vector3(-0.5, -0.5, 0),
            new U1.Vector3(0.5, -0.5, 0),
            new U1.Vector3(0.5, 0.5, 0),
            new U1.Vector3(-0.5, 0.5, 0),
            new U1.Vector3(-0.5, -0.5, 0 + MWindowCube._bottomThick),
            new U1.Vector3(0.5, -0.5, 0 + MWindowCube._bottomThick),
            new U1.Vector3(0.5, 0.5, 0 + MWindowCube._bottomThick),
            new U1.Vector3(-0.5, 0.5, 0 + MWindowCube._bottomThick),
            new U1.Vector3(-0.5, -0.5, 1 - MWindowCube._topThick),
            new U1.Vector3(0.5, -0.5, 1 - MWindowCube._topThick),
            new U1.Vector3(0.5, 0.5, 1 - MWindowCube._topThick),
            new U1.Vector3(-0.5, 0.5, 1 - MWindowCube._topThick),
            new U1.Vector3(-0.5, -0.5, 1),
            new U1.Vector3(0.5, -0.5, 1),
            new U1.Vector3(0.5, 0.5, 1),
            new U1.Vector3(-0.5, 0.5, 1),
            new U1.Vector3(-0.5, -0.5, 0 + MWindowCube._leftThick),
            new U1.Vector3(-0.5 + MWindowCube._leftThick, -0.5, 0 + MWindowCube._leftThick),
            new U1.Vector3(-0.5 + MWindowCube._leftThick, 0.5, 0 + MWindowCube._leftThick),
            new U1.Vector3(-0.5, 0.5, 0 + MWindowCube._leftThick),
            new U1.Vector3(-0.5, -0.5, 1 - MWindowCube._leftThick),
            new U1.Vector3(-0.5 + MWindowCube._leftThick, -0.5, 1 - MWindowCube._leftThick),
            new U1.Vector3(-0.5 + MWindowCube._leftThick, 0.5, 1 - MWindowCube._leftThick),
            new U1.Vector3(-0.5, 0.5, 1 - MWindowCube._leftThick),
            new U1.Vector3(0.5 - MWindowCube._rightThick, -0.5, 0 + MWindowCube._rightThick),
            new U1.Vector3(0.5, -0.5, 0 + MWindowCube._rightThick),
            new U1.Vector3(0.5, 0.5, 0 + MWindowCube._rightThick),
            new U1.Vector3(0.5 - MWindowCube._rightThick, 0.5, 0 + MWindowCube._rightThick),
            new U1.Vector3(0.5 - MWindowCube._rightThick, -0.5, 1 - MWindowCube._rightThick),
            new U1.Vector3(0.5, -0.5, 1 - MWindowCube._rightThick),
            new U1.Vector3(0.5, 0.5, 1 - MWindowCube._rightThick),
            new U1.Vector3(0.5 - MWindowCube._rightThick, 0.5, 1 - MWindowCube._rightThick),
            new U1.Vector3(0, -0.5, 0 + MWindowCube._leftThick),
            new U1.Vector3(0 + MWindowCube._leftThick, -0.5, 0 + MWindowCube._leftThick),
            new U1.Vector3(0 + MWindowCube._leftThick, 0.5, 0 + MWindowCube._leftThick),
            new U1.Vector3(0, 0.5, 0 + MWindowCube._leftThick),
            new U1.Vector3(0, -0.5, 1 - MWindowCube._leftThick),
            new U1.Vector3(0 + MWindowCube._leftThick, -0.5, 1 - MWindowCube._leftThick),
            new U1.Vector3(0 + MWindowCube._leftThick, 0.5, 1 - MWindowCube._leftThick),
            new U1.Vector3(0, 0.5, 1 - MWindowCube._leftThick),
            new U1.Vector3(-0.5, -0.5, 0.5),
            new U1.Vector3(0.5, -0.5, 0.5),
            new U1.Vector3(0.5, 0.5, 0.5),
            new U1.Vector3(-0.5, 0.5, 0.5),
            new U1.Vector3(-0.5, -0.5, 0.5 + MWindowCube._bottomThick),
            new U1.Vector3(0.5, -0.5, 0.5 + MWindowCube._bottomThick),
            new U1.Vector3(0.5, 0.5, 0.5 + MWindowCube._bottomThick),
            new U1.Vector3(-0.5, 0.5, 0.5 + MWindowCube._bottomThick)
        ];
        MWindowCube._fs = [
            [0, 1, 5, 4],
            [1, 2, 6, 5],
            [2, 3, 7, 6],
            [3, 0, 4, 7],
            [4, 5, 6, 7],
            [1, 0, 3, 2],
            [8, 9, 13, 12],
            [9, 10, 14, 13],
            [10, 11, 15, 14],
            [11, 8, 12, 15],
            [12, 13, 14, 15],
            [9, 8, 11, 10],
            [16, 17, 21, 20],
            [17, 18, 22, 21],
            [18, 19, 23, 22],
            [19, 16, 20, 23],
            [20, 21, 22, 23],
            [17, 16, 19, 18],
            [24, 25, 29, 28],
            [25, 26, 30, 29],
            [26, 27, 31, 30],
            [27, 24, 28, 31],
            [28, 29, 30, 31],
            [25, 24, 27, 26],
            [32, 33, 37, 36],
            [33, 34, 38, 37],
            [34, 35, 39, 38],
            [35, 32, 36, 39],
            [36, 37, 38, 39],
            [33, 32, 35, 34],
            [40, 41, 45, 44],
            [41, 42, 46, 45],
            [42, 43, 47, 46],
            [43, 40, 44, 47],
            [44, 45, 46, 47],
            [41, 40, 43, 42]
        ];
        Meshes.MWindowCube = MWindowCube;
        U1.UDocument.Creaters["MWindowCube"] = MWindowCube;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MHoleyCube extends Meshes.MParamModel {
            constructor() {
                super(...arguments);
                this._w = 1.0;
                this._l = 1.0;
                this._h = 1.0;
            }
            get W() {
                return this._w;
            }
            set W(value) {
                this.SetProperty("W", "_w", value);
            }
            get L() {
                return this._l;
            }
            set L(value) {
                this.SetProperty("L", "_l", value);
            }
            get H() {
                return this._h;
            }
            set H(value) {
                this.SetProperty("H", "_h", value);
            }
            get BottomMargin() {
                return this.H * MHoleyCube._bottomThick;
            }
            get TopMargin() {
                return this.H * MHoleyCube._topThick;
            }
            get LeftMargin() {
                return this.W * MHoleyCube._leftThick;
            }
            get RightMargin() {
                return this.W * MHoleyCube._rightThick;
            }
            UpdateMesh() {
                let _vs = MHoleyCube._vs;
                let _fs = MHoleyCube._fs;
                let w = this.W;
                let l = this.L;
                let h = this.H;
                let size = new U1.Vector3(w, l, h);
                let mesh = this.Mesh;
                if (mesh != null) {
                    if (mesh.Parent == this)
                        this.Remove(mesh);
                }
                {
                    mesh = this.AddChild(Meshes.MMesh);
                }
                let texPrj = new Meshes.MTexPrj();
                texPrj.PrjKind = Meshes.MTexPrjKinds.Box;
                texPrj.XForm = U1.Matrix4.CreateScale(size);
                let ps = mesh.Vertics;
                let vmap = {};
                for (let i = 0; i < _vs.length; i++) {
                    let p = ps[i];
                    if (p == null) {
                        p = mesh.NewVert(U1.Vector3.Zero);
                    }
                    var v3 = _vs[i].Clone();
                    v3.Multiply(size);
                    p.P = v3;
                    vmap[i] = p;
                }
                var fs = mesh.Faces;
                for (let i = 0; i < _fs.length; i++) {
                    let f = fs[i];
                    if (f == null) {
                        f = mesh.NewFace();
                    }
                    f.Init({
                        loops: [_fs[i].map(o_ => vmap[o_])],
                        smgrp: i,
                        mgrp: i,
                        texPrj: texPrj
                    });
                }
                this.Mesh = mesh;
                super.UpdateMesh();
            }
            ReadProps(props) {
                super.ReadProps(props);
                this._w = props.GetFloat("W", this.W);
                this._l = props.GetFloat("L", this.L);
                this._h = props.GetFloat("H", this.H);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetFloat("W", this.W);
                props.SetFloat("L", this.L);
                props.SetFloat("H", this.H);
            }
            GetUPropsCategory() {
                return "HoleyBox";
            }
            GetUProps() {
                var this_ = this;
                let props = [
                    new U1.UPropDouble({
                        GetValueFunc: () => this_.W,
                        SetValueFunc: (p_, v_) => this_.W = v_,
                        Label: "W",
                        EndChangeFunc: () => this_.UpdateMesh()
                    }),
                    new U1.UPropDouble({
                        GetValueFunc: () => this_.H,
                        SetValueFunc: (p_, v_) => this_.H = v_,
                        Label: "H",
                        EndChangeFunc: () => this_.UpdateMesh()
                    }),
                    new U1.UPropDouble({
                        GetValueFunc: () => this_.L,
                        SetValueFunc: (p_, v_) => this_.L = v_,
                        Label: "L",
                        EndChangeFunc: () => this_.UpdateMesh()
                    }),
                ];
                return props;
            }
        }
        MHoleyCube._bottomThick = 0.02;
        MHoleyCube._topThick = 0.02;
        MHoleyCube._leftThick = 0.02;
        MHoleyCube._rightThick = 0.02;
        MHoleyCube._backThick = 0.02;
        MHoleyCube._backExpansionThick = 0.000;
        MHoleyCube._leftExpansionThick = 0.000;
        MHoleyCube._rightExpansionThick = 0.000;
        MHoleyCube._vs = [
            new U1.Vector3(-0.5, -0.5, 0),
            new U1.Vector3(0.5, -0.5, 0),
            new U1.Vector3(0.5, 0.5, 0),
            new U1.Vector3(-0.5, 0.5, 0),
            new U1.Vector3(-0.5, -0.5, 0 + MHoleyCube._bottomThick),
            new U1.Vector3(0.5, -0.5, 0 + MHoleyCube._bottomThick),
            new U1.Vector3(0.5, 0.5, 0 + MHoleyCube._bottomThick),
            new U1.Vector3(-0.5, 0.5, 0 + MHoleyCube._bottomThick),
            new U1.Vector3(-0.5, -0.5, 1 - MHoleyCube._topThick),
            new U1.Vector3(0.5, -0.5, 1 - MHoleyCube._topThick),
            new U1.Vector3(0.5, 0.5, 1 - MHoleyCube._topThick),
            new U1.Vector3(-0.5, 0.5, 1 - MHoleyCube._topThick),
            new U1.Vector3(-0.5, -0.5, 1),
            new U1.Vector3(0.5, -0.5, 1),
            new U1.Vector3(0.5, 0.5, 1),
            new U1.Vector3(-0.5, 0.5, 1),
            new U1.Vector3(-0.5, -0.5, 0 + (MHoleyCube._leftThick + MHoleyCube._leftExpansionThick)),
            new U1.Vector3(-0.5 + MHoleyCube._leftThick, -0.5, 0 + (MHoleyCube._leftThick + MHoleyCube._leftExpansionThick)),
            new U1.Vector3(-0.5 + MHoleyCube._leftThick, 0.5, 0 + (MHoleyCube._leftThick + MHoleyCube._leftExpansionThick)),
            new U1.Vector3(-0.5, 0.5, 0 + (MHoleyCube._leftThick + MHoleyCube._leftExpansionThick)),
            new U1.Vector3(-0.5, -0.5, 1 - (MHoleyCube._leftThick + MHoleyCube._leftExpansionThick)),
            new U1.Vector3(-0.5 + MHoleyCube._leftThick, -0.5, 1 - (MHoleyCube._leftThick + MHoleyCube._leftExpansionThick)),
            new U1.Vector3(-0.5 + MHoleyCube._leftThick, 0.5, 1 - (MHoleyCube._leftThick + MHoleyCube._leftExpansionThick)),
            new U1.Vector3(-0.5, 0.5, 1 - (MHoleyCube._leftThick + MHoleyCube._leftExpansionThick)),
            new U1.Vector3(0.5 - MHoleyCube._rightThick, -0.5, 0 + (MHoleyCube._rightThick + MHoleyCube._rightExpansionThick)),
            new U1.Vector3(0.5, -0.5, 0 + (MHoleyCube._rightThick + MHoleyCube._rightExpansionThick)),
            new U1.Vector3(0.5, 0.5, 0 + (MHoleyCube._rightThick + MHoleyCube._rightExpansionThick)),
            new U1.Vector3(0.5 - MHoleyCube._rightThick, 0.5, 0 + (MHoleyCube._rightThick + MHoleyCube._rightExpansionThick)),
            new U1.Vector3(0.5 - MHoleyCube._rightThick, -0.5, 1 - (MHoleyCube._rightThick + MHoleyCube._rightExpansionThick)),
            new U1.Vector3(0.5, -0.5, 1 - (MHoleyCube._rightThick + MHoleyCube._rightExpansionThick)),
            new U1.Vector3(0.5, 0.5, 1 - (MHoleyCube._rightThick + MHoleyCube._rightExpansionThick)),
            new U1.Vector3(0.5 - MHoleyCube._rightThick, 0.5, 1 - (MHoleyCube._rightThick + MHoleyCube._rightExpansionThick)),
        ];
        MHoleyCube._fs = [
            [0, 1, 5, 4],
            [1, 2, 6, 5],
            [2, 3, 7, 6],
            [3, 0, 4, 7],
            [4, 5, 6, 7],
            [1, 0, 3, 2],
            [8, 9, 13, 12],
            [9, 10, 14, 13],
            [10, 11, 15, 14],
            [11, 8, 12, 15],
            [12, 13, 14, 15],
            [9, 8, 11, 10],
            [16, 17, 21, 20],
            [17, 18, 22, 21],
            [18, 19, 23, 22],
            [19, 16, 20, 23],
            [20, 21, 22, 23],
            [17, 16, 19, 18],
            [24, 25, 29, 28],
            [25, 26, 30, 29],
            [26, 27, 31, 30],
            [27, 24, 28, 31],
            [28, 29, 30, 31],
            [25, 24, 27, 26],
        ];
        Meshes.MHoleyCube = MHoleyCube;
        U1.UDocument.Creaters["MHoleyCube"] = MHoleyCube;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UGeomElement extends U1.UNode {
        constructor() {
            super(...arguments);
            this.scale = U1.Vector3.One;
            this.isUpdating = false;
            this.IsInvalid = false;
        }
        get AfterGeometryChanged() {
            if (this._afterGeometryChanged == null)
                this._afterGeometryChanged = new U1.Event2();
            return this._afterGeometryChanged;
        }
        get AfterTransformChanged() {
            if (this._afterTransformChanged == null)
                this._afterTransformChanged = new U1.Event2();
            return this._afterTransformChanged;
        }
        CanUserRotate() {
            return true;
        }
        CanUserScale() {
            return true;
        }
        CanUserTranslate() {
            return true;
        }
        get Transform() {
            if (this.m_invalidTransform || this.m_transform === undefined) {
                if (this.m_transform === undefined)
                    this.m_transform = U1.Matrix4.Identity;
                this.UpdateTransform();
                this.m_invalidTransform = false;
            }
            return this.m_transform;
        }
        get BoundingBox() {
            if (this.m_invalidBounding || this.m_boundingBox === undefined) {
                if (this.m_boundingBox === undefined)
                    this.m_boundingBox = new U1.BoundingBox();
                this.UpdateBounding();
                this.m_invalidBounding = false;
            }
            return this.m_boundingBox;
        }
        get BoundingSphere() {
            if (this.m_invalidBounding || this.m_boundingSphere === undefined) {
                if (this.m_boundingSphere === undefined)
                    this.m_boundingSphere = new U1.BoundingSphere();
                this.UpdateBounding();
                this.m_invalidBounding = false;
            }
            return this.m_boundingSphere;
        }
        get OrientedBBox3() {
            if (this.m_invalidOBB || this.m_obb3 === undefined) {
                this.UpdateOBB();
            }
            return this.m_obb3;
        }
        get OrientedBBox2() {
            if (this.m_invalidOBB || this.m_obb2 === undefined) {
                this.UpdateOBB();
            }
            return this.m_obb2;
        }
        get GeometryParent() {
            var geomParent = this.Parent;
            while (geomParent != null && !(geomParent instanceof UGeomElement)) {
                geomParent = geomParent.Parent;
            }
            if (geomParent instanceof UGeomElement)
                return geomParent;
            return null;
        }
        getPivot() {
            return null;
        }
        get Axis() {
            return this.axis;
        }
        set Axis(value) {
            this.SetProperty("Axis", "axis", value);
        }
        get Angle() {
            return this.angle;
        }
        set Angle(value) {
            this.SetProperty("Angle", "angle", value);
        }
        get ImportBase() {
            return this.importBase;
        }
        set ImportBase(value) {
            this.SetProperty("ImportBase", "importBase", value);
        }
        get BasePosition() {
            return this.basePosition;
        }
        set BasePosition(value) {
            this.SetProperty("BasePosition", "basePosition", value);
        }
        get Scale() {
            return this.scale;
        }
        set Scale(value) {
            this.SetProperty("Scale", "scale", value);
        }
        get Location() {
            return this.location;
        }
        set Location(value) {
            this.SetProperty("Location", "location", value);
        }
        get BasePositionType() {
            return this.basePositionType;
        }
        set BasePositionType(value) {
            this.SetProperty("BasePositionType", "basePositionType", value);
        }
        init() {
            if (this.Document != null) {
                this.Document.BeforeEndTransaction.Add(this, this.OnBeforeEndTransaction);
            }
        }
        Detach() {
            if (this.Document != null) {
                this.Document.BeforeEndTransaction.Remove(this, this.OnBeforeEndTransaction);
            }
            super.Detach();
        }
        Invalidate() {
            if (this.IsInvalid)
                return;
            this.IsInvalid = true;
        }
        OnInvalidated(source) {
        }
        Update() {
            if (this.isUpdating)
                return;
            this.isUpdating = true;
            try {
                this.OnUpdate();
                this.UpdateOBB();
            }
            catch (_a) {
            }
            this.isUpdating = false;
        }
        OnUpdate() {
        }
        GeometryChanged(source) {
            if (this.propagateInvalidGeom)
                return;
            this.m_invalidOBB = true;
            this.m_invalidBounding = true;
            this.propagateInvalidGeom = true;
            if (this._afterGeometryChanged != null)
                this._afterGeometryChanged.Invoke(this, source);
            var geomParent = this.GeometryParent;
            if (geomParent != null)
                geomParent.GeometryChanged(source);
            this.OnGeometryChanged(source);
            this.propagateInvalidGeom = false;
        }
        TransformChanged(source) {
            if (this.propagateInvalidTran)
                return;
            this.m_invalidTransform = true;
            this.m_invalidBounding = true;
            this.m_invalidOBB = true;
            this.propagateInvalidTran = true;
            if (this._afterTransformChanged != null)
                this._afterTransformChanged.Invoke(this, source);
            var geomParent = this.GeometryParent;
            if (geomParent != null)
                geomParent.TransformChanged(source);
            this.OnTransformChanged(source);
            this.propagateInvalidTran = false;
        }
        OnBeforeEndTransaction() {
            if (this.IsInvalid) {
                this.OnUpdate();
                this.IsInvalid = false;
            }
        }
        OnGeometryChanged(source) {
        }
        OnTransformChanged(source) {
        }
        InvokeGeometryChanged() {
            this.GeometryChanged(this);
        }
        InvokeTransformChanged() {
            this.TransformChanged(this);
        }
        InvalidateBounding() {
            this.m_invalidBounding = true;
            this.m_invalidOBB = true;
        }
        OnChildAdded(child) {
            super.OnChildAdded(child);
            if (child instanceof UGeomElement) {
                this.InvokeGeometryChanged();
                this.InvalidateBounding();
            }
        }
        OnChildDeleting(element) {
            super.OnChildDeleting(element);
            if (element instanceof UGeomElement) {
                this.InvokeGeometryChanged();
                this.InvalidateBounding();
            }
        }
        GetGeomNodes(parentXForm, nodes) {
            var geNode = new U1.Geoms.GeNode();
            geNode.Element = this;
            geNode.Transform = U1.Matrix4.Multiply(this.Transform, parentXForm);
            var geoms = new Array();
            this.UpdateGeoms(geoms);
            geNode.AddEntities(geoms);
            nodes.push(geNode);
        }
        UpdateGeoms(geoms) {
        }
        UpdateOBB() {
            this.m_invalidOBB = false;
            var tm = this.Transform;
            var bbx = this.BoundingBox;
            var s_;
            s_ = UGeomElement[".uob."] || (UGeomElement[".uob."] = s_ = {
                v0: U1.Vector3.Zero, v1: U1.Vector3.Zero, v2: U1.Vector3.Zero, v3: U1.Vector3.Zero,
                v4: U1.Vector3.Zero, v5: U1.Vector3.Zero, v6: U1.Vector3.Zero, v7: U1.Vector3.Zero
            });
            var hsize = s_.v0;
            var xAxis = s_.v1;
            var yAxis = s_.v2;
            var zAxis = s_.v3;
            var cent = s_.v4;
            var xp = s_.v5;
            var yp = s_.v6;
            var zp = s_.v7;
            hsize = hsize.SetSubtract(bbx.Max, bbx.Min).Scale(0.5);
            xAxis.SetUnitX();
            yAxis.SetUnitY();
            zAxis.SetUnitZ();
            xAxis.TransformNormal(tm).Normalize();
            yAxis.TransformNormal(tm).Normalize();
            zAxis.TransformNormal(tm).Normalize();
            cent.SetAdd(bbx.Max, bbx.Min).Scale(0.5);
            xp.Set(hsize.X, 0, 0).Add(cent).Transform(tm);
            yp.Set(0, hsize.Y, 0).Add(cent).Transform(tm);
            zp.Set(0, 0, hsize.Z).Add(cent).Transform(tm);
            cent.Transform(tm);
            if (this.m_obb3 === undefined)
                this.m_obb3 = new U1.OrientedBox3();
            if (this.m_obb2 === undefined)
                this.m_obb2 = new U1.OrientedBox3();
            this.m_obb3.Axes[0].CopyFrom(xAxis);
            this.m_obb3.Axes[1].CopyFrom(yAxis);
            this.m_obb3.Axes[2].CopyFrom(zAxis);
            this.m_obb3.Extents[0] = U1.Vector3.Distance(xp, cent);
            this.m_obb3.Extents[1] = U1.Vector3.Distance(yp, cent);
            this.m_obb3.Extents[2] = U1.Vector3.Distance(zp, cent);
            this.m_obb3.Center.CopyFrom(cent);
            this.m_obb2 = UGeomElement.GetOrientedBox2(this.m_obb3, this.m_obb2);
        }
        UpdateTransform() {
            this.Transform.SetIdentity();
        }
        UpdateBounding() {
        }
        SetTransform(xform) {
        }
        AddTransform(xform) {
            var m = UGeomElement[".adt.m"] || (UGeomElement[".adt.m"] = U1.Matrix4.Identity);
            m.SetMultiply(this.Transform, xform);
            this.SetTransform(m);
        }
        AddTranslation(offset) {
            var m = UGeomElement[".atr.m"] || (UGeomElement[".atr.m"] = U1.Matrix4.Identity);
            m.SetMultiply(this.Transform, m.SetCreateTranslation(offset));
            this.SetTransform(m);
        }
        AddRotation(center, axis, angle) {
            var m0 = UGeomElement[".art.m0"] || (UGeomElement[".art.m0"] = U1.Matrix4.Identity);
            var m1 = UGeomElement[".art.m1"] || (UGeomElement[".art.m1"] = U1.Matrix4.Identity);
            var m2 = UGeomElement[".art.m2"] || (UGeomElement[".art.m2"] = U1.Matrix4.Identity);
            var rm = m0.SetCreateTranslationFloats(-center.X, -center.Y, -center.Z)
                .Multiply(m1.SetCreateFromAxisAngle(axis, angle))
                .Multiply(m2.SetCreateTranslation(center));
            var xform = rm.SetMultiply(this.Transform, rm);
            this.SetTransform(xform);
        }
        AddScale(center, from, to) {
            var obb = UGeomElement[".asc.ob"] || (UGeomElement[".asc.ob"] = new U1.OrientedBox3());
            var m0 = UGeomElement[".asc.m0"] || (UGeomElement[".asc.m0"] = U1.Matrix4.Identity);
            obb.SetIdentity();
            obb.Axes[0].CopyFrom(this.OrientedBBox3.Axes[0]);
            obb.Axes[1].CopyFrom(this.OrientedBBox3.Axes[1]);
            obb.Axes[2].CopyFrom(this.OrientedBBox3.Axes[2]);
            var xForm = m0.SetMultiply(this.Transform, UGeomElement.CreateOBBScaleMatrix(obb, center, from, to, m0));
            this.SetTransform(xForm);
        }
        static GetOrientedBox2(obb3, result) {
            var unitx = UGeomElement[".ux"] || (UGeomElement[".ux"] = U1.Vector3.UnitX);
            var unity = UGeomElement[".uy"] || (UGeomElement[".uy"] = U1.Vector3.UnitY);
            var unitz = UGeomElement[".uz"] || (UGeomElement[".uz"] = U1.Vector3.UnitZ);
            var xAxis = UGeomElement[".gob.v1"] || (UGeomElement[".gob.v1"] = new U1.Vector3());
            var yAxis = UGeomElement[".gob.v2"] || (UGeomElement[".gob.v2"] = new U1.Vector3());
            var zAxis = UGeomElement[".gob.v3"] || (UGeomElement[".gob.v3"] = new U1.Vector3());
            xAxis.SetUnitX();
            yAxis.SetUnitY();
            zAxis.SetUnitZ();
            var obb2 = result || (new U1.OrientedBox3());
            obb2.CopyFrom(obb3);
            if (Math.abs(U1.Vector3.Dot(unitz, obb2.Axes[0]))
                < Math.abs(U1.Vector3.Dot(unitz, obb2.Axes[1]))) {
                xAxis.CopyFrom(obb2.Axes[0]);
                xAxis.Z = 0;
                xAxis.Normalize();
                yAxis.SetCross(unitz, xAxis);
            }
            else {
                yAxis.CopyFrom(obb2.Axes[1]);
                yAxis.Z = 0;
                yAxis.Normalize();
                xAxis.SetCross(yAxis, U1.Vector3.UnitZ);
            }
            obb2.Axes[0].CopyFrom(xAxis).Normalize();
            obb2.Axes[1].CopyFrom(yAxis).Normalize();
            obb2.Axes[2].SetUnitZ();
            return obb2;
        }
        static CreateOBBScaleMatrix(obb, center, from, to, result) {
            if (result === undefined)
                result = U1.Matrix4.Identity;
            var xformedOBB = UGeomElement[".obb.1"] || (UGeomElement[".obb.1"] = new U1.OrientedBox3());
            var sm = UGeomElement[".m4.1"] || (UGeomElement[".m4.1"] = new U1.Matrix4());
            var tm = UGeomElement[".m4.2"] || (UGeomElement[".m4.2"] = new U1.Matrix4());
            xformedOBB.SetScaleWithTowPoints(obb, center, from, to);
            var sx = xformedOBB.Extents[0] / obb.Extents[0];
            var sy = xformedOBB.Extents[1] / obb.Extents[1];
            var sz = xformedOBB.Extents[2] / obb.Extents[2];
            var loc = xformedOBB.Center;
            tm.SetCreateTranslation(loc);
            return result.SetCreateScaleByFloats(sx, sy, sz).Multiply(tm);
        }
    }
    U1.UGeomElement = UGeomElement;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UItemSet extends U1.UNode {
        Items(type) {
            return this.GetChildren(type);
        }
        get count() {
            return this.Items.length;
        }
        Clear() {
            this.Children.forEach(elm => {
                elm.Detach();
            });
        }
        AddItem(type) {
            var item = this.AddChild(type, null);
            return item;
        }
        SetItem(type, name) {
            var item = this.GetOrCreateItem(type, name);
            return item;
        }
        GetOrCreateItem(type, name) {
            var item = this.GetItemByName(type, name);
            if (item == null) {
                item = this.AddItemByName(type, name);
            }
            return item;
        }
        GetItemByID(type, id) {
            var children = this.GetChildren(type, null);
            for (var ch of children) {
                if (ch.ID == id)
                    return ch;
            }
            return null;
        }
        GetItemByName(type, name) {
            var children = this.GetChildren(type, null);
            for (var ch of children) {
                if (ch.Name == name)
                    return ch;
            }
            return null;
        }
        AddItemByName(type, name) {
            var item = this.AddChild(type, name);
            return item;
        }
        AddItemCopy(item, name) {
            var nitem = this.AddChildCopy(item, null);
            nitem.Name = name;
            return nitem;
        }
    }
    U1.UItemSet = UItemSet;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class GeomUtils {
        static Project2D(v3List, center, uVector, vVector) {
            var vs = new Array();
            v3List
                .forEach(o_ => {
                let v3 = U1.Vector3.Subtract(o_, center);
                vs.push(new U1.Vector2(U1.Vector3.Dot(uVector, v3), U1.Vector3.Dot(vVector, v3)));
            });
            return vs;
        }
        static Project2DList(v3List, center, normal, uVector, vVector) {
            U1.GeometryHelper3.GetArbitraryAxis(normal, uVector, vVector);
            return this.Project2D(v3List, center, uVector, vVector);
        }
        static GetNormal(points) {
            if (points == null || points.length < 3)
                throw new DOMException();
            let lmostIx = 0;
            let lmostP = new U1.Vector3();
            this.GetLeftMost(points, lmostIx, lmostP);
            var prevIx = (lmostIx + points.length - 1) % points.length;
            var nextIx = (lmostIx + 1) % points.length;
            var v0 = points[prevIx];
            var v1 = lmostP;
            var v2 = points[nextIx];
            while (U1.Vector3.DistanceSquared(v0, v1) < 0.0001 || U1.Vector3.DistanceSquared(v0, v2) < 0.0001) {
                prevIx = (prevIx + points.length - 1) % points.length;
                if (prevIx == nextIx)
                    break;
                v0 = points[prevIx];
            }
            while (U1.Vector3.DistanceSquared(v2, v1) < 0.0001) {
                nextIx = (nextIx + 1) % points.length;
                if (nextIx == prevIx)
                    break;
                v2 = points[nextIx];
            }
            var normal = U1.Vector3.Normalize(U1.Vector3.Cross(U1.Vector3.Subtract(v1, v0), U1.Vector3.Subtract(v2, v0)));
            return normal;
        }
        static GetLeftMost(points, lmostIx, lmostP) {
            lmostIx = 0;
            lmostP = points[0];
            for (var i = 1; i < points.length; i++) {
                var p = points[i];
                if (p.X < lmostP.X
                    || (p.X == lmostP.X && p.Y < lmostP.Y)
                    || (p.X == lmostP.X && p.Y == lmostP.Y && p.Z < lmostP.Z)) {
                    lmostIx = i;
                    lmostP = p;
                }
            }
        }
    }
    U1.GeomUtils = GeomUtils;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        let BoxCornerTypes;
        (function (BoxCornerTypes) {
            BoxCornerTypes[BoxCornerTypes["None"] = 0] = "None";
            BoxCornerTypes[BoxCornerTypes["LFB"] = 1] = "LFB";
            BoxCornerTypes[BoxCornerTypes["RFB"] = 2] = "RFB";
            BoxCornerTypes[BoxCornerTypes["RKB"] = 3] = "RKB";
            BoxCornerTypes[BoxCornerTypes["LKB"] = 4] = "LKB";
            BoxCornerTypes[BoxCornerTypes["LFT"] = 5] = "LFT";
            BoxCornerTypes[BoxCornerTypes["RFT"] = 6] = "RFT";
            BoxCornerTypes[BoxCornerTypes["RKT"] = 7] = "RKT";
            BoxCornerTypes[BoxCornerTypes["LKT"] = 8] = "LKT";
            BoxCornerTypes[BoxCornerTypes["Center"] = 9] = "Center";
            BoxCornerTypes[BoxCornerTypes["LC"] = 10] = "LC";
            BoxCornerTypes[BoxCornerTypes["FC"] = 11] = "FC";
            BoxCornerTypes[BoxCornerTypes["RC"] = 12] = "RC";
            BoxCornerTypes[BoxCornerTypes["KC"] = 13] = "KC";
            BoxCornerTypes[BoxCornerTypes["TC"] = 14] = "TC";
            BoxCornerTypes[BoxCornerTypes["BC"] = 15] = "BC";
        })(BoxCornerTypes = Geoms.BoxCornerTypes || (Geoms.BoxCornerTypes = {}));
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var LibEarcus;
(function (LibEarcus) {
    function earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode)
            return triangles;
        var minX, minY, maxX, maxY, x, y, size;
        if (hasHoles)
            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
            }
            size = Math.max(maxX - minX, maxY - minY);
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, size);
        return triangles;
    }
    LibEarcus.earcut = earcut;
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim)
                last = insertNode(i, data[i], data[i + 1], last);
        }
        else {
            for (i = end - dim; i >= start; i -= dim)
                last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }
        return last;
    }
    function filterPoints(start, end) {
        if (!start)
            return start;
        if (!end)
            end = start;
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next)
                    return null;
                again = true;
            }
            else {
                p = p.next;
            }
        } while (again || p !== end);
        return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
        if (!ear)
            return;
        if (!pass && size)
            indexCurve(ear, minX, minY, size);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear);
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            if (ear === stop) {
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
                }
                else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, size, 2);
                }
                else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, size);
                }
                break;
            }
        }
    }
    function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
            return false;
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0)
                return false;
            p = p.next;
        }
        return true;
    }
    function isEarHashed(ear, minX, minY, size) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
            return false;
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size);
        var p = ear.nextZ;
        while (p && p.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0)
                return false;
            p = p.nextZ;
        }
        p = ear.prevZ;
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0)
                return false;
            p = p.prevZ;
        }
        return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                removeNode(p);
                removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
        return p;
    }
    function splitEarcut(start, triangles, dim, minX, minY, size) {
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    var c = splitPolygon(a, b);
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    earcutLinked(a, triangles, dim, minX, minY, size);
                    earcutLinked(c, triangles, dim, minX, minY, size);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next)
                list.steiner = true;
            queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    function compareX(a, b) {
        return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }
    function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
            if (hy <= p.y && hy >= p.next.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y)
                            return p;
                        if (hy === p.next.y)
                            return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m)
            return null;
        if (hx === qx)
            return m.prev;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m.next;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x);
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }
        return m;
    }
    function indexCurve(start, minX, minY, size) {
        var p = start;
        do {
            if (p.z === null)
                p.z = zOrder(p.x, p.y, minX, minY, size);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
    }
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q)
                        break;
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize === 0) {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    else if (qSize === 0 || !q) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else if (p.z <= q.z) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail)
                        tail.nextZ = e;
                    else
                        list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    function zOrder(x, y, minX, minY, size) {
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            if (p.x < leftmost.x)
                leftmost = p;
            p = p.next;
        } while (p !== start);
        return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
            locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
        if ((equals(p1, q1) && equals(p2, q2)) ||
            (equals(p1, q2) && equals(p2, q1)))
            return true;
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
            area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b))
                return true;
            p = p.next;
        } while (p !== a);
        return false;
    }
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                inside = !inside;
            p = p.next;
        } while (p !== a);
        return inside;
    }
    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        }
        else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
            p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
            p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
    }
    function deviation(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
            for (var i = 0, len = holeIndices.length; i < len; i++) {
                var start = holeIndices[i] * dim;
                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                polygonArea -= Math.abs(signedArea(data, start, end, dim));
            }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
            var a = triangles[i] * dim;
            var b = triangles[i + 1] * dim;
            var c = triangles[i + 2] * dim;
            trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 :
            Math.abs((trianglesArea - polygonArea) / polygonArea);
    }
    ;
    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    LibEarcus.signedArea = signedArea;
    function flatten(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].length; j++) {
                for (var d = 0; d < dim; d++)
                    result.vertices.push(data[i][j][d]);
            }
            if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
            }
        }
        return result;
    }
    LibEarcus.flatten = flatten;
    ;
})(LibEarcus || (LibEarcus = {}));
var U1;
(function (U1) {
    var BRep;
    (function (BRep) {
        class Face {
            constructor() {
                this.State = BRep.FaceStates.None;
            }
            get IsFlat() {
                return (this.State & BRep.FaceStates.Flat) == BRep.FaceStates.Flat;
            }
            set IsFlat(isFlat) {
                if (isFlat)
                    this.State = this.State | BRep.FaceStates.Flat;
                else
                    this.State = this.State & ~BRep.FaceStates.Flat;
            }
            get IsCap() {
                return (this.State & BRep.FaceStates.Cap) == BRep.FaceStates.Cap;
            }
            set IsCap(value) {
                if (value)
                    this.State = this.State | BRep.FaceStates.Cap;
                else
                    this.State = this.State & ~BRep.FaceStates.Cap;
            }
            get HasHoles() {
                return this.Holes != null && this.Holes.length > 0;
            }
            get HoleCount() {
                return this.Holes != null ? this.Holes.length : 0;
            }
            get Normal() {
                if (this._normal == null || this._normal.IsZero) {
                    this._normal = this._normal || new U1.Vector3();
                    var vs = this.Shell.Vertices;
                    var ps = this.Boundary.map(o_ => vs[o_]);
                    U1.GeometryHelper3.PolygonNormal(ps, 0, this.Boundary.length, true, this._normal);
                }
                return this._normal;
            }
            get Plane() {
                if (this._plane == null || this._plane.IsZero) {
                    this._plane = U1.Plane.FromPointNormal(new U1.Vector3(this.Boundary[0], this.Boundary[1], this.Boundary[2]), this.Normal, this._plane);
                    this._plane.Normal.Set(this.Normal);
                }
                return this._plane;
            }
            get TriFaces() {
                if (this._triFaces === undefined) {
                    this.Tesselate();
                }
                return this._triFaces;
            }
            set TriFaces(value) {
                this._triFaces = value;
            }
            Invalidate() {
                if (this._normal != null)
                    this._normal.SetZero();
                if (this._plane != null)
                    this._plane.Set(0, 0, 0, 0);
            }
            Clone() {
                var nf = new Face();
                nf.State = this.State;
                nf.MId = this.MId;
                nf._normal = this._normal != null ? this._normal.Clone() : undefined;
                nf.Boundary = this.Boundary.slice();
                if (this.Holes != null) {
                    nf.Holes = this.Holes.map(o_ => o_.slice());
                }
                return nf;
            }
            CutByFace(face, front, back) {
                return false;
            }
            CutByPlane(plane, fronts, backs) {
                var f_path = [];
                var b_path = [];
                var f_loops;
                var b_loops;
                var f_holes;
                var b_holes;
                var polygon = this.Boundary.map(o_ => this.Shell.Vertices[o_]);
                if (!this.SplitPolygon(polygon, plane, f_path, b_path))
                    return false;
                f_loops = [];
                b_loops = [];
                if (this.HasHoles) {
                    for (var i = 0; i < this.Holes.length; i++) {
                        polygon = this.Holes[i].map(o_ => this.Shell.Vertices[o_]);
                        if (!this.SplitPolygon(polygon, plane, f_path, b_path)) {
                            var isect = U1.GeometryHelper3.PolygonPlaneIntersection(polygon, plane);
                            if (isect == U1.PlaneIntersectionTypeEnum.Front) {
                                f_holes = f_holes || [];
                                f_holes.push(polygon);
                            }
                            else if (isect == U1.PlaneIntersectionTypeEnum.Back) {
                                b_holes = b_holes || [];
                                b_holes.push(polygon);
                            }
                        }
                    }
                }
                if (f_path.length == 0 || b_path.length == 0)
                    return false;
                this.ConnectPolygon(f_path, f_loops);
                this.ConnectPolygon(b_path, b_loops);
                for (var path of f_path) {
                    let face = this.Clone();
                    face.Boundary = path.map(o_ => o_.Num);
                    fronts.push(face);
                    if (f_holes != null) {
                        for (let i = f_holes.length - 1; i >= 0; i--) {
                            let hole = f_holes[i];
                            if (face.CheckInside(hole[0])) {
                                face.Holes = face.Holes || [];
                                face.Holes.push(hole.map(o_ => o_.Num));
                                f_holes.splice(i, 1);
                            }
                        }
                    }
                }
                for (var path of b_path) {
                    let face = this.Clone();
                    face.Boundary = path.map(o_ => o_.Num);
                    backs.push(face);
                    if (b_holes != null) {
                        for (let i = b_holes.length - 1; i >= 0; i--) {
                            let hole = b_holes[i];
                            if (face.CheckInside(hole[0])) {
                                face.Holes = face.Holes || [];
                                face.Holes.push(hole.map(o_ => o_.Num));
                                f_holes.splice(i, 1);
                            }
                        }
                    }
                }
                return true;
            }
            getMin() {
                if (this._min == null) {
                    this._min = U1.Vector3.MaxValue.Minimize(this.Boundary.map(o_ => this.Shell.Vertices[o_]));
                }
                return this._min;
            }
            getMax() {
                if (this._max == null) {
                    this._max = U1.Vector3.MinValue.Maximize(this.Boundary.map(o_ => this.Shell.Vertices[o_]));
                }
                return this._max;
            }
            CheckCross(plane) {
                var fc = 0;
                var bc = 0;
                for (var i = 0; i < this.Boundary.length; i++) {
                    var p = this.Shell.Vertices[this.Boundary[i]];
                    var tsign = plane.DotCoordinate(p);
                    if (tsign < 0.0001 && tsign > -0.0001)
                        continue;
                    if (tsign < 0)
                        bc++;
                    else
                        fc++;
                    if (fc > 0 && bc > 0)
                        return true;
                }
                return fc > 0 && bc > 0;
            }
            SplitPolygon(ps, plane, fronts, backs) {
                var isect = U1.GeometryHelper3.PolygonPlaneIntersection(ps, plane);
                if (isect != U1.PlaneIntersectionTypeEnum.Intersecting)
                    return false;
                var dir = new U1.Vector3();
                var p = new U1.Vector3();
                var polygons = [];
                var polygon = [];
                for (var i = 0; i < ps.length; i++) {
                    var ni = (i + 1) % ps.length;
                    var p0 = ps[i];
                    var p1 = ps[ni];
                    var d0 = plane.DotCoordinate(p0);
                    var d1 = plane.DotCoordinate(p0);
                    if (d1 < 0.0001 && d1 > -0.0001) {
                        continue;
                    }
                    if (d0 < 0.0001 && d0 > -0.0001) {
                        polygon.push(p0);
                        polygons.push(polygon);
                        polygon = [p0];
                        continue;
                    }
                    if (d0 * d1 > 0) {
                        polygon.push(p0);
                        continue;
                    }
                    else {
                        dir.SetSubtract(p1, p0);
                        var amount = plane.IntersectsLine(p0, dir);
                        var mp = this.Shell.SplitEdge(p0, p1, amount);
                        polygon.push(p0);
                        polygon.push(mp);
                        polygons.push(polygon);
                        polygon = [mp];
                    }
                }
                if (polygons.length > 1)
                    polygons[polygons.length - 1].push(...polygons[0]);
                var tfronts = [];
                var tbacks = [];
                for (var polygon of polygons) {
                    if (polygon.length < 3)
                        continue;
                    if (plane.DotCoordinate(polygon[1]) > 0)
                        tfronts.push(polygon);
                    else
                        tbacks.push(polygon);
                }
                return true;
            }
            ConnectPolygon(polygons, result) {
                var pgon = polygons[0];
                var dir = new U1.Vector3().SetSubtract(pgon[pgon.length - 1], pgon[0]);
                var endInfos = [];
                for (var pgon of polygons) {
                    var sp = pgon[0];
                    var ep = pgon[pgon.length - 1];
                    var t0 = U1.Vector3.Dot(dir, sp);
                    var t1 = U1.Vector3.Dot(dir, ep);
                    var si = { t: t0, pgon: pgon, isStart: true };
                    var ei = { t: t1, pgon: pgon, isStart: false };
                    si.opp = ei;
                    ei.opp = si;
                    endInfos.push(si);
                    endInfos.push(ei);
                }
                endInfos.sort((a, b) => {
                    if (a.t === b.t)
                        return 0;
                    a.t < b.t ? -1 : 1;
                });
                for (var i = 0; i < endInfos.length; i += 2) {
                    var e0 = endInfos[i];
                    var e1 = endInfos[i + 1];
                    if (e0.pgon === e1.pgon) {
                        result.push(e0.pgon);
                        continue;
                    }
                    if (!e0.isStart && e1.isStart) {
                        e0.pgon.push(...e1.pgon);
                        e1.pgon = e0.pgon;
                    }
                    else if (!e0.isStart && !e1.isStart) {
                        e1.pgon.reverse();
                        e1.opp.isStart = false;
                        e0.pgon.push(...e1.pgon);
                        e1.pgon = e0.pgon;
                    }
                    else if (e0.isStart && !e1.isStart) {
                        e1.pgon.push(...e0.pgon);
                        e0.pgon = e1.pgon;
                    }
                    else if (e0.isStart && e1.isStart) {
                        e0.pgon.reverse();
                        e0.opp.isStart = true;
                        e1.pgon.push(...e0.pgon);
                        e0.pgon = e1.pgon;
                    }
                }
            }
            Tesselate_() {
                if (this.Boundary.length == 3 && !this.HasHoles) {
                    this._triFaces = this.Boundary;
                }
                var tess = new U1.LibTess.Tess();
                var contour = new Array(this.Boundary.length);
                var vmap = {};
                this.Shell.Vertices.forEach((v_, i_, vs_) => {
                    vmap[i_] = v_;
                });
                this.Boundary.forEach((v_, i_) => {
                    let v = vmap[v_];
                    let cv = new U1.LibTess.ContourVertex();
                    cv.Data = v;
                    cv.Position.SetValues(v.X, v.Y, v.Z);
                    contour[i_] = cv;
                });
                tess.AddContour(contour);
                if (this.HasHoles) {
                    for (var hole of this.Holes) {
                        let contour = new Array(hole.length);
                        hole.forEach((v_, i_) => {
                            let v = vmap[v_];
                            let cv = new U1.LibTess.ContourVertex();
                            cv.Data = v;
                            cv.Position.SetValues(v.X, v.Y, v.Z);
                            contour[i_] = cv;
                        });
                        tess.AddContour(contour);
                    }
                }
                tess.Tessellate(U1.LibTess.WindingRule.EvenOdd, U1.LibTess.ElementType.Polygons, 3, null);
                var tri_faces = new Array();
                for (var i = 0; i < tess.ElementCount; i++) {
                    let i0 = tess.Elements[i * 3];
                    let i1 = tess.Elements[i * 3 + 1];
                    let i2 = tess.Elements[i * 3 + 2];
                    if (i0 < 0 || i1 < 0 || i2 < 0)
                        continue;
                    let v0 = tess.Vertices[i0];
                    let v1 = tess.Vertices[i1];
                    let v2 = tess.Vertices[i2];
                    if (v0.Data == null ||
                        v1.Data == null ||
                        v2.Data == null)
                        continue;
                    tri_faces.push(v0.Data.Num, v1.Data.Num, v2.Data.Num);
                }
                this._triFaces = tri_faces;
            }
            Tesselate(vmap) {
                if (this.Boundary.length == 3 && !this.HasHoles) {
                    this._triFaces = this.Boundary;
                }
                let points = [];
                let holes = [];
                let norm = this.Normal;
                let ux = new U1.Vector3();
                let vx = new U1.Vector3();
                U1.GeometryHelper3.GetArbitraryAxis(norm, ux, vx);
                var imap = [];
                if (vmap == null) {
                    vmap = {};
                    this.Shell.Vertices.forEach((v_, i_, vs_) => {
                        vmap[i_] = v_;
                    });
                }
                this.Boundary.forEach((v_, i_) => {
                    let v = vmap[v_];
                    let x = U1.Vector3.Dot(v, ux);
                    let y = U1.Vector3.Dot(v, vx);
                    imap[points.length / 2] = v_;
                    points.push(x, y);
                });
                if (this.HasHoles) {
                    for (var hole of this.Holes) {
                        holes.push(points.length / 2);
                        hole.forEach((v_, i_) => {
                            let v = vmap[v_];
                            let x = U1.Vector3.Dot(v, ux);
                            let y = U1.Vector3.Dot(v, vx);
                            imap[points.length / 2] = v_;
                            points.push(x, y);
                        });
                    }
                }
                let tri_faces = LibEarcus.earcut(points, holes);
                this._triFaces = tri_faces.map(o_ => vmap[imap[o_]].Num);
                return this._triFaces;
            }
            CheckIntersectRay(p, dir) {
                var plane = Face[".cir.pl"] || (Face[".cir.pl"] = new U1.Plane());
                var tv0 = Face[".cir.v0"] || (Face[".cir.v0"] = new U1.Vector3());
                plane.SetFromPointNormal(this.Shell.Vertices[this.Boundary[0]], this.Normal);
                var dist = plane.IntersectsLine(p, dir, tv0);
                if (dist === null)
                    return U1.FaceIntersectionTypeEnum.Outside;
                var res = this.CheckInside(tv0);
                if (res === U1.FaceIntersectionTypeEnum.Boundary && (dist < -0.0001 || dist > 0.0001))
                    res = U1.FaceIntersectionTypeEnum.Outside;
                return res;
            }
            ArbitrarilyInsidePoint(res) {
                res = res || new U1.Vector3();
                var tv0 = Face[".aip.v0"] || (Face[".aip.v0"] = new U1.Vector3());
                var tv1 = Face[".aip.v1"] || (Face[".aip.v1"] = new U1.Vector3());
                var shell = this.Shell;
                var vs = shell.Vertices;
                var bs = this.Boundary;
                var hs = this.Holes;
                if (this.Boundary.length == 3) {
                    var v0 = vs[bs[0]];
                    var v1 = vs[bs[1]];
                    var v2 = vs[bs[2]];
                    res.X = (v0.X + v1.X + v2.X) / 3;
                    res.Y = (v0.Y + v1.Y + v2.Y) / 3;
                    res.Z = (v0.Z + v1.Z + v2.Z) / 3;
                }
                else if (this.HasHoles) {
                    var v0 = vs[hs[0][0]];
                    res.Set(v0);
                }
                else {
                    var leftmost = -1;
                    var li = 0;
                    var cp = vs[0];
                    for (var i = 1; i < vs.length; i++) {
                        if (vs[i].X < res.X) {
                            cp = vs[i];
                            li = i;
                        }
                        else if (vs[i].X === cp.X && vs[i].Y < cp.Y) {
                            cp = vs[i];
                            li = i;
                        }
                    }
                    var pp = vs[(i - 1 + vs.length) % vs.length];
                    var np = vs[(i + 1) % vs.length];
                    tv0.SetSubtract(pp, cp).Normalize();
                    tv1.SetSubtract(np, cp).Normalize();
                    var dir = tv0.Add(tv1).Normalize();
                    var min_t = Number.MAX_VALUE;
                    for (var i = 0; i < vs.length; i++) {
                        if (i === li)
                            continue;
                        var t = U1.Vector3.Dot(tv1.SetSubtract(vs[i], cp), dir);
                        if (t < min_t)
                            min_t = t;
                    }
                    res.SetScaleAdd(cp, min_t / 2, dir);
                }
                return res;
            }
            CheckInside(p) {
                var tv1 = Face[".cip.v1"] || (Face[".cip.v1"] = new U1.Vector3());
                var tv2 = Face[".cip.v2"] || (Face[".cip.v2"] = new U1.Vector3());
                var tv3 = Face[".cip.v3"] || (Face[".cip.v3"] = new U1.Vector3());
                var tv4 = Face[".cip.v4"] || (Face[".cip.v4"] = new U1.Vector3());
                var tv5 = Face[".cip.v5"] || (Face[".cip.v5"] = new U1.Vector3());
                var tv6 = Face[".cip.v6"] || (Face[".cip.v6"] = new U1.Vector3());
                var plane = Face[".cip.pl1"] || (Face[".cip.pl1"] = new U1.Plane());
                var vs = this.Shell.Vertices;
                var udir = tv1;
                var vdir = tv2;
                U1.GeometryHelper3.GetArbitraryAxis(this.Normal, udir, vdir);
                var polygons = [this.Boundary.map(o_ => vs[o_])];
                if (this.HasHoles) {
                    for (var h of this.Holes) {
                        polygons.push(h.map(o_ => vs[o_]));
                    }
                }
                var a = 0;
                for (let i = 0; i < 100; i++, a++) {
                    tv3.SetScale(udir, Math.cos(a));
                    tv4.SetScale(vdir, Math.sin(a));
                    var f_dir = tv3.Add(tv4);
                    var pln_n = tv5.SetCross(f_dir, this.Normal);
                    plane.SetFromPointNormal(p, pln_n);
                    var fcount = 0;
                    var bcount = 0;
                    for (var ps of polygons) {
                        for (let j = 0; j < ps.length; j++) {
                            var ni = (j + 1) % ps.length;
                            var p0 = ps[j];
                            var p1 = ps[ni];
                            var d0 = plane.DotCoordinate(p0);
                            var d1 = plane.DotCoordinate(p0);
                            if (d1 < 0.0001 && d1 > -0.0001) {
                                continue;
                            }
                            if (d0 * d1 > 0) {
                                continue;
                            }
                            else {
                                var edg_dir = tv4.SetSubtract(p1, p0);
                                var amount = plane.IntersectsLine(p0, edg_dir);
                                var mp = tv6.SetScaleAdd(p0, amount, edg_dir);
                                var t = U1.Vector3.Dot(tv4.SetSubtract(mp, p), f_dir);
                                if (t < 0.0001 && t > -0.0001)
                                    return U1.FaceIntersectionTypeEnum.Boundary;
                                if (t > 0.0001)
                                    fcount++;
                                else if (t < -0.0001)
                                    bcount++;
                            }
                        }
                    }
                    if (fcount % 2 === bcount % 2) {
                        if (fcount % 2 === 0)
                            return U1.FaceIntersectionTypeEnum.Outside;
                        else
                            U1.FaceIntersectionTypeEnum.Inside;
                    }
                }
                return U1.FaceIntersectionTypeEnum.Outside;
            }
            SetBoundary(points) {
                if (points != null)
                    this.Boundary = points.slice();
                return this;
            }
            SetHoles(points) {
                if (points != null)
                    this.Holes = points.map(o_ => o_.slice()).slice();
                return this;
            }
            SetIsCap(isCap) {
                this.IsCap = isCap;
                return this;
            }
            SetIsFlat(isFlat) {
                this.IsFlat = isFlat;
                return this;
            }
        }
        BRep.Face = Face;
    })(BRep = U1.BRep || (U1.BRep = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var BRep;
    (function (BRep) {
        let FaceStates;
        (function (FaceStates) {
            FaceStates[FaceStates["None"] = 0] = "None";
            FaceStates[FaceStates["Cutted"] = 2] = "Cutted";
            FaceStates[FaceStates["Cap"] = 4] = "Cap";
            FaceStates[FaceStates["Flat"] = 8] = "Flat";
        })(FaceStates = BRep.FaceStates || (BRep.FaceStates = {}));
    })(BRep = U1.BRep || (U1.BRep = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var BRep;
    (function (BRep) {
        class ShellUtil {
            static CreateBox() {
                var shell = new BRep.Shell();
                shell.Vertices = [
                    new BRep.Vertex(-0.5, -0.5, 0), new BRep.Vertex(0.5, -0.5, 0), new BRep.Vertex(0.5, 0.5, 0), new BRep.Vertex(-0.5, 0.5, 0),
                    new BRep.Vertex(-0.5, -0.5, 1), new BRep.Vertex(0.5, -0.5, 1), new BRep.Vertex(0.5, 0.5, 1), new BRep.Vertex(-0.5, 0.5, 1),
                ];
                shell.AddFace([0, 1, 5, 4]);
                shell.AddFace([1, 2, 6, 5]);
                shell.AddFace([2, 3, 7, 6]);
                shell.AddFace([3, 0, 4, 7]);
                shell.AddFace([4, 5, 6, 7]);
                shell.AddFace([0, 3, 2, 1]);
                shell.Edges = [
                    0, 1, 1, 2, 2, 3, 3, 0,
                    4, 5, 5, 6, 6, 7, 7, 4,
                    0, 4, 1, 5, 2, 6, 3, 7,
                ];
                return shell;
            }
        }
        BRep.ShellUtil = ShellUtil;
    })(BRep = U1.BRep || (U1.BRep = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var BRep;
    (function (BRep) {
        class Vertex extends U1.Vector3 {
            constructor(x = 0, y = 0, z = 0) {
                super(x, y, z);
            }
            Clone() {
                var result = new Vertex(this.X, this.Y, this.Z);
                result.Num = this.Num;
                result.Normal = this.Normal != null ? this.Normal.Clone() : undefined;
                result.UV0 = this.UV0 != null ? this.UV0.Clone() : undefined;
                return result;
            }
            SetLerp(a, b, amount) {
                this.X = a.X + ((b.X - a.X) * amount);
                this.Y = a.Y + ((b.Y - a.Y) * amount);
                this.Z = a.Z + ((b.Z - a.Z) * amount);
                if (a instanceof Vertex && b instanceof Vertex) {
                    if (a.Normal !== undefined && b.Normal !== undefined) {
                        this.Normal = this.Normal || new U1.Vector3();
                        var an = a.Normal || new U1.Vector3();
                        var bn = b.Normal || new U1.Vector3();
                        this.Normal.SetLerp(an, bn, amount);
                    }
                    if (a.UV0 !== undefined && b.UV0 !== undefined) {
                        this.UV0 = this.UV0 || new U1.Vector2();
                        let a_uv = a.UV0 || new U1.Vector2();
                        let b_uv = b.UV0 || new U1.Vector2();
                        this.UV0.SetLerp(a_uv, b_uv, amount);
                    }
                }
                return this;
            }
            SetNormal(x, y = 0, z = 0) {
                this.Normal = this.Normal || new U1.Vector3();
                this.Normal.Set(x, y, z);
            }
            SetUV0(x, y = 0) {
                this.UV0 = this.UV0 || new U1.Vector2();
                this.UV0.Set(x, y);
            }
        }
        BRep.Vertex = Vertex;
    })(BRep = U1.BRep || (U1.BRep = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var BRep;
    (function (BRep) {
        class ShellModel {
            constructor() {
                this._transform = U1.Matrix4.Identity;
            }
            get Transform() {
                return this._transform;
            }
            set Transform(value) {
                this._transform.CopyFrom(value);
            }
            get Children() {
                return this._children;
            }
            set Children(value) {
                this._children = value;
            }
            AddChild(child) {
                this._children = this._children || [];
                this._children.push(child);
                this._bbx = undefined;
            }
            get BoundingBox() {
                this._bbx = this._bbx || new U1.BoundingBox();
                this._bbx.Min.SetMaxValue();
                this._bbx.Max.SetMinValue();
                if (this.Shell != null) {
                    this._bbx.Min.Minimize(this.Shell.Vertices);
                    this._bbx.Max.Maximize(this.Shell.Vertices);
                }
                if (this.Children != null) {
                    for (var ch of this.Children) {
                        this._bbx.Merge(ch.BoundingBox, ch.Transform);
                    }
                }
                return this._bbx;
            }
            static ReadMesh(reader, mesh, brep) {
                var id = reader.ReadInt32();
                var mat_num = reader.ReadInt32();
                var shell_num = reader.ReadInt32();
                var ch_count = reader.ReadInt16();
                var tm_num = reader.ReadInt8();
                if (tm_num == 16) {
                    ShellModel.ReadMatrix(reader, mesh._transform);
                }
                mesh.Material = brep.Materials[mat_num];
                mesh.Shell = brep.Shells[shell_num];
                if (ch_count > 0) {
                    mesh._children = [];
                    for (var i = 0; i < ch_count; i++) {
                        var ch = new ShellModel();
                        ShellModel.ReadMesh(reader, ch, brep);
                        ch._parent = mesh;
                        mesh._children[i] = ch;
                    }
                }
            }
            static ReadMatrix(reader, m) {
                m.M11 = reader.ReadFloat32();
                m.M12 = reader.ReadFloat32();
                m.M13 = reader.ReadFloat32();
                m.M14 = reader.ReadFloat32();
                m.M21 = reader.ReadFloat32();
                m.M22 = reader.ReadFloat32();
                m.M23 = reader.ReadFloat32();
                m.M24 = reader.ReadFloat32();
                m.M31 = reader.ReadFloat32();
                m.M32 = reader.ReadFloat32();
                m.M33 = reader.ReadFloat32();
                m.M34 = reader.ReadFloat32();
                m.M41 = reader.ReadFloat32();
                m.M42 = reader.ReadFloat32();
                m.M43 = reader.ReadFloat32();
                m.M44 = reader.ReadFloat32();
            }
        }
        BRep.ShellModel = ShellModel;
        class BRepFile {
            constructor() {
                this.Materials = [];
                this.Shells = [];
                this.Models = [];
            }
            Load(dataView) {
                var pos = 0;
                var head_str = "u1web";
                var reader = new U1.BinaryReader(dataView);
                for (var i = 0; i < head_str.length; i++) {
                    var c = reader.ReadUint8();
                    if (c !== head_str.charCodeAt(i)) {
                        throw "unknown file error";
                    }
                }
                var ver = reader.ReadInt32();
                if (ver === 1) {
                    this.ReadVer1(reader);
                }
            }
            ReadVer1(reader) {
                var mat_num = reader.ReadInt32();
                var shell_num = reader.ReadInt32();
                var mdl_num = reader.ReadInt32();
                this.Materials = new Array(mat_num);
                for (var i = 0; i < mat_num; i++) {
                    let mat = new U1.MeshMaterial();
                    BRepFile.ReadMaterial(reader, mat);
                    this.Materials[i] = mat;
                }
                this.Shells = new Array(shell_num);
                for (var i = 0; i < shell_num; i++) {
                    let shell = new BRep.Shell();
                    shell.Read(reader);
                    this.Shells[i] = shell;
                }
                this.Models = new Array(mdl_num);
                for (var i = 0; i < mdl_num; i++) {
                    var mdl = new ShellModel();
                    ShellModel.ReadMesh(reader, mdl, this);
                    this.Models[i] = mdl;
                }
                if (!reader.IsEOF) {
                    var jsondata = "jsondata";
                    var ci = 0;
                    while (!reader.IsEOF && ci < jsondata.length) {
                        var c = reader.ReadUint8();
                        if (jsondata.charCodeAt(ci) == c) {
                            ci++;
                        }
                    }
                    var chars = [];
                    while (!reader.IsEOF) {
                        chars.push(reader.ReadUint8());
                    }
                    try {
                        var b64_string = String.fromCharCode(...chars);
                        var data_string = U1.b64_to_utf8(b64_string);
                        this.JsonData = JSON.parse(data_string);
                    }
                    catch (ex) {
                        U1.LogService.WriteException(ex);
                    }
                }
            }
            static ReadMaterial(reader, mat) {
                var mat_type = reader.ReadUint8();
                mat.Diffuse.R = reader.ReadUint8();
                mat.Diffuse.G = reader.ReadUint8();
                mat.Diffuse.B = reader.ReadUint8();
                mat.Opacity = reader.ReadFloat32();
                if (mat_type > 1) {
                    mat.Ambient.R = reader.ReadUint8();
                    mat.Ambient.G = reader.ReadUint8();
                    mat.Ambient.B = reader.ReadUint8();
                    mat.Specular.R = reader.ReadUint8();
                    mat.Specular.G = reader.ReadUint8();
                    mat.Specular.B = reader.ReadUint8();
                    mat.Emissive.R = reader.ReadUint8();
                    mat.Emissive.G = reader.ReadUint8();
                    mat.Emissive.B = reader.ReadUint8();
                    mat.Cull = reader.ReadUint8();
                }
                if (mat_type > 2) {
                    var tex = mat.DiffuseTexture = new U1.Texture();
                    tex.Offset.X = reader.ReadFloat32();
                    tex.Offset.Y = reader.ReadFloat32();
                    tex.Scale.X = reader.ReadFloat32();
                    tex.Scale.Y = reader.ReadFloat32();
                    tex.AddressU = reader.ReadFloat32();
                    tex.AddressV = reader.ReadFloat32();
                    tex.AddressW = reader.ReadFloat32();
                }
            }
        }
        BRep.BRepFile = BRepFile;
    })(BRep = U1.BRep || (U1.BRep = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropertyBag {
        constructor() {
            this.Props = {};
        }
        GetInt(prop, def_value) {
            let val = this.Props[prop];
            if (val != null)
                return val;
            return def_value;
        }
        GetIntArr(prop, def_value) {
            let value = this.Props[prop];
            if (value != null) {
                return value;
            }
            return def_value;
        }
        GetFloat(prop, def_value) {
            let val = this.Props[prop];
            if (val != null)
                return val;
            return def_value;
        }
        GetFloatArr(prop, def_value) {
            let val = this.Props[prop];
            if (val != null)
                return val;
            return def_value;
        }
        GetBool(prop, def_value) {
            let val = this.Props[prop];
            if (val != null)
                return val;
            return def_value;
        }
        GetStr(prop, def_value) {
            let val = this.Props[prop];
            if (val !== undefined)
                return val;
            return def_value;
        }
        GetStrArr(prop, def_value) {
            let val = this.Props[prop];
            if (val !== undefined)
                return val;
            return def_value;
        }
        GetValue(type, prop, def_value) {
            let val = this.Props[prop];
            if (val !== undefined) {
                return val.Clone();
            }
            return def_value;
        }
        GetValueArr(type, prop, def_value) {
            let val = this.Props[prop];
            if (val !== undefined) {
                if (Array.isArray(val)) {
                    return val.map(o_ => {
                        if (o_ instanceof type)
                            return o_.Clone();
                        return o_;
                    });
                }
                return val;
            }
            return def_value;
        }
        GetRef(prop, def_value) {
            let val = this.Props[prop];
            if (val !== undefined)
                return val;
            return def_value;
        }
        GetRefArr(prop, def_value) {
            let val = this.Props[prop];
            if (val !== undefined)
                return val;
            return def_value;
        }
        SetInt(prop, value) {
            this.Props[prop] = value;
        }
        SetIntArr(prop, value) {
            this.Props[prop] = value;
        }
        SetFloat(prop, value) {
            this.Props[prop] = value;
        }
        SetFloatArr(prop, value) {
            this.Props[prop] = value;
        }
        SetBool(prop, value) {
            this.Props[prop] = value;
        }
        SetStr(prop, value) {
            this.Props[prop] = value;
        }
        SetStrArr(prop, value) {
            this.Props[prop] = value;
        }
        SetValue(prop, value) {
            this.Props[prop] = value;
        }
        SetValueArr(prop, value) {
            this.Props[prop] = value;
        }
        SetRef(prop, value) {
            this.Props[prop] = value;
        }
        SetRefArr(prop, value) {
            this.Props[prop] = value;
        }
    }
    U1.UPropertyBag = UPropertyBag;
    class UPropertyStrBag {
        constructor() {
            this.Props = {};
        }
        GetInt(prop, def_value) {
            let val = this.Props[prop];
            if (typeof val === "string")
                return parseInt(val);
            return def_value;
        }
        GetIntArr(prop, def_value) {
            let value = this.Props[prop];
            if (typeof value === "string") {
                let values = [];
                let items = value.split(",");
                for (var i = 0; i < items.length; i++) {
                    values.push(parseInt(items[i]));
                }
                return values;
            }
            return def_value;
        }
        GetFloat(prop, def_value) {
            let val = this.Props[prop];
            if (typeof val === "string")
                return parseFloat(val);
            return def_value;
        }
        GetFloatArr(prop, def_value) {
            let value = this.Props[prop];
            if (typeof value === "string") {
                let values = [];
                let items = value.split(",");
                for (var i = 0; i < items.length; i++) {
                    values.push(parseFloat(items[i]));
                }
                return values;
            }
            return def_value;
        }
        GetBool(prop, def_value) {
            let value = this.Props[prop];
            if (typeof value === "string") {
                value = value.toLowerCase();
                return value == "true" || value == "1";
            }
            return def_value;
        }
        GetStr(prop, def_value) {
            let value = this.Props[prop];
            if (typeof value === "string") {
                return value;
            }
            return def_value;
        }
        GetStrArr(prop, def_value) {
            let value = this.Props[prop];
            if (typeof value === "string") {
                return U1.UValueUtil.ConvertStrArrFromString(value);
            }
            return def_value;
        }
        GetValue(type, prop, def_value) {
            let value = this.Props[prop];
            if (typeof value === "string") {
                let res = new type();
                res.ConvertFromStr(value);
                return res;
            }
            return def_value;
        }
        GetValueArr(type, prop, def_value) {
            let value = this.Props[prop];
            if (typeof value === "string") {
                return U1.UValueUtil.ConvertArrFromString(type, value);
            }
            return def_value;
        }
        GetRef(prop, def_value) {
            let value = this.Props[prop];
            if (typeof value === "string") {
                if (value[0] === "#")
                    value = value.slice(1);
                let id = parseFloat(value);
                return this.Doc.GetElement(id);
            }
            return def_value;
        }
        GetRefArr(prop, def_value) {
            let value = this.Props[prop];
            if (value != null) {
                let values = [];
                if (typeof value === "string") {
                    let items = value.split(",");
                    for (var i = 0; i < items.length; i++) {
                        let item_str = items[i];
                        if (item_str != null && item_str[0] === "#") {
                            item_str = item_str.slice(1);
                            values.push(parseFloat(item_str));
                        }
                    }
                }
                return values.map(o_ => this.Doc.GetElement(o_));
            }
            return def_value;
        }
        SetInt(prop, value) {
            this.Props[prop] = "" + value;
        }
        SetIntArr(prop, value) {
            value = value || [];
            this.Props[prop] = value.join(",");
        }
        SetFloat(prop, value) {
            this.Props[prop] = "" + value;
        }
        SetFloatArr(prop, value) {
            value = value || [];
            this.Props[prop] = value.join(",");
        }
        SetBool(prop, value) {
            this.Props[prop] = "" + value;
        }
        SetStr(prop, value) {
            this.Props[prop] = value;
        }
        SetStrArr(prop, value) {
            if (value == null)
                this.Props[prop] = null;
            else
                this.Props[prop] = U1.UValueUtil.ConvertStrArrToString(...value);
        }
        SetValue(prop, value) {
            if (value == null) {
                this.Props[prop] = null;
            }
            else {
                this.Props[prop] = value.ConvertToStr();
            }
        }
        SetValueArr(prop, value) {
            if (value == null) {
                this.Props[prop] = null;
            }
            else {
                this.Props[prop] = U1.UValueUtil.ConvertArrToString(value);
            }
        }
        SetRef(prop, value) {
            if (value == null)
                this.Props[prop] = "$";
            else
                this.Props[prop] = "#" + value.ID;
        }
        SetRefArr(prop, value) {
            value = value || [];
            this.Props[prop] = value
                .map(o_ => o_ == null ? "$" : ("#" + o_.ID))
                .join(',');
        }
    }
    U1.UPropertyStrBag = UPropertyStrBag;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UUndoCmdProp {
        constructor(element, prop, field, old_value, new_value) {
            this.element = element;
            this.prop = prop;
            this.field = field;
            this.old_value = old_value;
            this.new_value = new_value;
        }
        Redo() {
            this.element[this.field] = this.new_value;
            this.element.InvokePropertyChanged(this.prop);
        }
        Undo() {
            this.element[this.field] = this.old_value;
            this.element.InvokePropertyChanged(this.prop);
        }
    }
    U1.UUndoCmdProp = UUndoCmdProp;
    class UUndoCmdRefProp {
        constructor(element, prop, field, old_value, new_value) {
            this.element = element;
            this.prop = prop;
            this.field = field;
            this.old_value = old_value;
            this.new_value = new_value;
        }
        Redo() {
            this.element[this.field] = this.new_value;
            this.element.InvokePropertyChanged(this.prop);
            this.element.UpdateInverce(this.prop, this.old_value, this.new_value);
        }
        Undo() {
            this.element[this.field] = this.old_value;
            this.element.InvokePropertyChanged(this.prop);
            this.element.UpdateInverce(this.prop, this.new_value, this.old_value);
        }
    }
    U1.UUndoCmdRefProp = UUndoCmdRefProp;
    class UUndoCmdAppend {
        constructor(document, element) {
            this.document = document;
            this.element = element;
        }
        Redo() {
            this.document.Append(this.element);
            this.element.unfreeze();
        }
        Undo() {
            this.document.Remove(this.element);
            this.element.freeze();
        }
    }
    U1.UUndoCmdAppend = UUndoCmdAppend;
    class UUndoCmdRemove {
        constructor(document, element) {
            this.document = document;
            this.element = element;
        }
        Redo() {
            this.document.Remove(this.element);
            this.element.freeze();
        }
        Undo() {
            this.document.Append(this.element);
            this.element.unfreeze();
        }
    }
    U1.UUndoCmdRemove = UUndoCmdRemove;
    class UUndoCmdGroup {
        constructor() {
            this.Commands = [];
        }
        AddCommand(cmd) {
            this.Commands.push(cmd);
        }
        Redo() {
            for (var i = 0; i < this.Commands.length; i++)
                this.Commands[i].Redo();
        }
        Undo() {
            for (var i = this.Commands.length - 1; i >= 0; --i)
                this.Commands[i].Undo();
        }
    }
    U1.UUndoCmdGroup = UUndoCmdGroup;
    class UTransactoin extends UUndoCmdGroup {
        Append(child) {
            delete this.changedProps;
            if (this.Children == null)
                this.Children = [];
            child.Parent = this;
            this.Children.push(child);
            this.AddCommand(child);
        }
        Remove(child) {
            if (child == null)
                return;
            if (this.Children && this.Children.indexOf(child) > -1)
                this.Children.splice(this.Children.indexOf(child), 1);
            if (this.Commands && this.Commands.indexOf(child) > -1)
                this.Commands.splice(this.Commands.indexOf(child), 1);
            child.Parent = null;
        }
        Cancel() {
            delete this.changedProps;
            this.Undo();
            if (this.Parent != null) {
                this.Parent.Remove(this);
            }
        }
        OnEnd() {
            delete this.changedProps;
        }
        HasCommands() {
            if (this.Commands.length > 0)
                return true;
            if (this.Children == null)
                return false;
            for (let ch of this.Children) {
                if (ch.HasCommands())
                    return true;
            }
            return false;
        }
        AddCommand(cmd) {
            if (cmd instanceof UUndoCmdProp || cmd instanceof UUndoCmdRefProp) {
                let hnd = cmd.element.HND;
                this.changedProps = this.changedProps || {};
                let elm_props = this.changedProps[hnd];
                if (elm_props == null) {
                    elm_props = this.changedProps[hnd] = {};
                }
                let old_cmd = elm_props[cmd.prop];
                if (old_cmd == null) {
                    old_cmd = elm_props[cmd.prop] = cmd;
                }
                else {
                    old_cmd.new_value = cmd.new_value;
                    return;
                }
            }
            else if (cmd instanceof UUndoCmdAppend || cmd instanceof UUndoCmdRemove) {
                if (this.changedProps != null) {
                    let hnd = cmd.element.HND;
                    delete this.changedProps[hnd];
                }
            }
            super.AddCommand(cmd);
        }
    }
    U1.UTransactoin = UTransactoin;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MFace extends U1.UNode {
            constructor() {
                super(...arguments);
                this.sg = 0;
                this.fg = 0;
                this.mg = 0;
                this._cache = {
                    ver: -1,
                    min: new U1.Vector3(),
                    max: new U1.Vector3(),
                    norm: new U1.Vector3(),
                    plane: new U1.Plane(),
                    innerpoint: undefined,
                    area: -1
                };
            }
            get Mesh() {
                if (this.Parent instanceof Meshes.MMesh)
                    return this.Parent;
                return null;
            }
            get SG() {
                return this.sg;
            }
            set SG(value) {
                this.SetProperty("SG", "smgrp", value);
            }
            get FG() {
                return this.fg;
            }
            set FG(value) {
                this.SetProperty("FG", "fg", value);
            }
            get MG() {
                return this.mg;
            }
            set MG(value) {
                this.SetRelProperty("MG", "mg", value);
            }
            get Loops() {
                return this.loops;
            }
            set Loops(value) {
                this.SetProperty("Loops", "loops", value);
            }
            get OuterVs() {
                return this.Loops[0].GetLoopVs();
            }
            get HolesVs() {
                let result = [];
                let ls = this.Loops;
                for (let i = 1; i < ls.length; i++) {
                    result.push(ls[i].GetLoopVs());
                }
                return result;
            }
            ApplyTexProj(tex_prj) {
                let s_ = MFace['.atp.'] || (MFace['.atp.'] = {});
                let fnorm = s_['n'] || (s_['n'] = new U1.Vector3());
                fnorm = this.GetNorm(fnorm);
                let u_4 = false;
                let u_1 = false;
                let loops = this.Loops;
                for (let loop of loops) {
                    for (let edg of loop.GetLoop()) {
                        let vtx = edg.V;
                        let uv = new U1.Vector2();
                        tex_prj.GetUV(vtx.P, fnorm, uv);
                        if (uv.X > 0.75) {
                            u_4 = true;
                        }
                        else if (uv.X < 0.25) {
                            u_1 = true;
                        }
                        edg.UV = uv;
                    }
                }
                if (u_4 && u_1
                    && (tex_prj.PrjKind == Meshes.MTexPrjKinds.Cylinder
                        || tex_prj.PrjKind == Meshes.MTexPrjKinds.Sphere)) {
                    for (let loop of loops) {
                        let p0 = loop.V.P;
                        if (tex_prj.PrjKind != Meshes.MTexPrjKinds.Cylinder
                            || tex_prj.IsCylinderSide(p0, fnorm)) {
                            for (let edg of loop.GetLoop()) {
                                if (edg.UV.X < 0.25) {
                                    edg.UV.X += 1;
                                }
                            }
                        }
                    }
                }
            }
            GetNorm(res) {
                var norm = res || new U1.Vector3();
                this.UpdateCache();
                norm.CopyFrom(this._cache.norm);
                return norm;
            }
            GetBBX(res) {
                res = res || new U1.BoundingBox();
                this.UpdateCache();
                res.Min.CopyFrom(this._cache.min);
                res.Max.CopyFrom(this._cache.max);
                return res;
            }
            GetPlane(res) {
                res = res || new U1.Plane();
                this.UpdateCache();
                res.CopyFrom(this._cache.plane);
                return res;
            }
            GetInnerPoint(res) {
                res = res || new U1.Vector3();
                this.UpdateCache();
                if (this._cache.innerpoint != null) {
                    res.CopyFrom(this._cache.innerpoint);
                    return this._cache.innerpoint;
                }
                let s_ = MFace[".gip."] || (MFace[".gip."] = {});
                let v1 = s_['v1'] || (s_['v1'] = new U1.Vector3());
                let v2 = s_['v2'] || (s_['v2'] = new U1.Vector3());
                let n = s_['n'] || (s_['n'] = new U1.Vector3());
                let innerp = new U1.Vector3();
                this._cache.innerpoint = innerp;
                let fn = this.GetNorm();
                let vs = this.OuterVs;
                let pi = vs.length - 1;
                let ci = 0;
                let ni = 1;
                let pp = vs[pi].P;
                let cp = vs[ci].P;
                let np = vs[ni].P;
                v1.SetSubtract(pp, cp).Normalize();
                v2.SetSubtract(np, cp).Normalize();
                n.SetCross(v2, v1);
                while (U1.Vector3.Dot(n, fn) < 0.1 && ni > 0) {
                    pi = ci;
                    ci = ni;
                    ni = (ni + 1) % vs.length;
                    pp = vs[pi].P;
                    cp = vs[ci].P;
                    np = vs[ni].P;
                    v1.SetSubtract(pp, cp).Normalize();
                    v2.SetSubtract(np, cp).Normalize();
                    n.SetCross(v2, v1);
                }
                let bisect = U1.Vector3.Add(v1, v2).Normalize();
                let min_t = Number.MAX_VALUE;
                for (let loop of this.Loops) {
                    let vs = loop.GetLoopVs();
                    for (let i = 0; i < vs.length; i++) {
                        let tp = vs[i].P;
                        if (tp == cp)
                            continue;
                        let t = U1.Vector3.Dot(bisect, v1.SetSubtract(tp, cp));
                        if (t > 0 && t < min_t) {
                            min_t = t;
                        }
                    }
                }
                innerp.SetScaleAdd(cp, min_t * 0.5, bisect);
                res.CopyFrom(innerp);
                return res;
            }
            GetArea() {
                this.UpdateCache();
                if (this._cache.area >= 0) {
                    return this._cache.area;
                }
                let norm = this.GetNorm();
                let u = U1.Vector3.Zero;
                let v = U1.Vector3.Zero;
                U1.GeometryHelper3.GetArbitraryAxis(norm, u, v);
                let area = 0;
                let loops = this.Loops;
                for (let i = 0; i < loops.length; i++) {
                    let vs = loops[i].GetLoopVs();
                    let tarea = 0;
                    if (vs.length > 0) {
                        let pgon = vs.map(o_ => {
                            return new U1.Vector2(U1.Vector3.Dot(u, o_.P), U1.Vector3.Dot(v, o_.P));
                        });
                        tarea = U1.CGAL.Polygon2.GetArea(pgon);
                    }
                    if (i === 0)
                        area = tarea;
                    else
                        area -= tarea;
                }
                this._cache.area = area;
                return area;
            }
            Init(f) {
                let es = [];
                let mesh = this.Mesh;
                let fnum = this.Num;
                let n_loops = [];
                this.MG = f.mgrp;
                this.SG = f.smgrp;
                let old_edges = {};
                if (this.Loops != null) {
                    for (let loop of this.Loops) {
                        for (let e of loop.GetLoop()) {
                            old_edges[`${e.V.ID}-${e.Next.V.ID}`] = e;
                        }
                    }
                }
                if (f.loops != null) {
                    for (let loop of f.loops) {
                        let e_start;
                        let e_cur;
                        for (var i = 0; i < loop.length; i++) {
                            let ni = i + 1;
                            if (ni >= loop.length)
                                ni = 0;
                            let v1 = loop[i];
                            let v2 = loop[ni];
                            let key = `${v1.ID}-${v2.ID}`;
                            let new_edg = old_edges[key];
                            if (new_edg != null) {
                                delete old_edges[key];
                            }
                            else {
                                new_edg = mesh.RegisterEdge(v1, v2);
                            }
                            if (e_cur != null) {
                                e_cur.Next = new_edg;
                            }
                            else {
                                e_start = new_edg;
                            }
                            e_cur = new_edg;
                        }
                        e_cur.Next = e_start;
                        n_loops.push(e_start);
                    }
                }
                this.Loops = n_loops;
                for (let key in old_edges) {
                    let e = old_edges[key];
                    if (e != null)
                        continue;
                    if (e.Opp != null)
                        e.Opp = null;
                    e.Detach();
                }
                if (f.texPrj != null) {
                    this.ApplyTexProj(f.texPrj);
                }
            }
            UpdateCache() {
                let cache = this._cache;
                if (this.Mesh == null || cache.ver == this.Mesh.CacheVer)
                    return;
                cache.ver = this.Mesh.CacheVer;
                cache.area = -1;
                let min = cache.min;
                let max = cache.max;
                let norm = cache.norm;
                let plane = cache.plane;
                cache.innerpoint = undefined;
                min.SetMaxValue();
                max.SetMinValue();
                let outerVs = this.Loops[0].GetLoopVs();
                var ps = outerVs.map(o_ => o_.P);
                U1.GeometryHelper3.PolygonNormal(ps, 0, ps.length, true, norm);
                for (let v of this.Loops[0].GetLoopVs()) {
                    min.Minimize(v.P);
                    max.Maximize(v.P);
                }
                plane.SetFromPointNormal(outerVs[0].P, norm);
            }
            Tesselate(res_verts) {
                let points = [];
                let holes = [];
                let norm = this.GetNorm();
                let ux = new U1.Vector3();
                let vx = new U1.Vector3();
                U1.GeometryHelper3.GetArbitraryAxis(norm, ux, vx);
                var imap = [];
                let loops = this.Loops;
                let pi = 0;
                for (let i = 0; i < loops.length; i++) {
                    if (i > 0)
                        holes.push(points.length / 2);
                    let loop = loops[i];
                    let edges = loop.GetLoop();
                    for (let edg of edges) {
                        let v = edg.V;
                        let p = v.P;
                        if (res_verts != null)
                            res_verts.push(v);
                        let x = U1.Vector3.Dot(ux, p);
                        let y = U1.Vector3.Dot(vx, p);
                        points.push(x, y);
                    }
                }
                let tri_faces = LibEarcus.earcut(points, holes);
                return tri_faces;
            }
            getMin() {
                this.UpdateCache();
                return this._cache.min;
            }
            getMax() {
                this.UpdateCache();
                return this._cache.max;
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.sg = props.GetInt("SG", this.SG);
                this.fg = props.GetInt("FG", this.FG);
                this.mg = props.GetInt("MG", this.MG);
                this.Loops = props.GetRefArr("Loops", this.Loops);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetInt("SG", this.SG);
                props.SetInt("FG", this.FG);
                props.SetInt("MG", this.MG);
                props.SetRefArr("Loops", this.Loops);
            }
            Clone() {
                let copy = super.Clone();
                return copy;
            }
            toString() {
                return this.Loops[0].GetLoopVs().map(o_ => o_.P.toString()).join(',');
            }
        }
        Meshes.MFace = MFace;
        U1.UDocument.Creaters["MFace"] = MFace;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MMesh extends U1.UNode {
            constructor() {
                super(...arguments);
                this.CacheVer = 0;
                this._cache = {
                    ver: -1,
                    min: new U1.Vector3(),
                    max: new U1.Vector3(),
                };
            }
            get Vertics() {
                return this.GetChildren(Meshes.MVert);
            }
            get Edges() {
                return this.GetChildren(Meshes.MEdg);
            }
            get Faces() {
                return this.GetChildren(Meshes.MFace);
            }
            NewVert(p) {
                var vtx = this.AddChild(Meshes.MVert);
                if (p)
                    vtx.P = p;
                this.CacheVer++;
                return vtx;
            }
            NewVerts(ps) {
                var vs = [];
                for (var p of ps) {
                    var vtx = this.AddChild(Meshes.MVert);
                    vtx.P = p;
                    vs.push(vtx);
                }
                this.CacheVer++;
                return vs;
            }
            NewEdge() {
                var edge = this.AddChild(Meshes.MEdg);
                this.CacheVer++;
                return edge;
            }
            NewFace(f) {
                var face = this.AddChild(Meshes.MFace);
                face.FG = face.Num;
                if (f != null) {
                    f.mgrp = f.mgrp || 0;
                    face.Init(f);
                }
                this.CacheVer++;
                return face;
            }
            RemoveUnused() {
                this.RemoveEmptyFaces();
                this.RemoveUnusedEdges();
                this.RemoveUnusedVerts();
            }
            RemoveEmptyFaces() {
                for (let f of this.Faces) {
                    if (f.Loops == null || f.Loops.length == 0) {
                        this.Remove(f);
                    }
                }
            }
            RemoveUnusedEdges() {
                let num = 0;
                for (let e of this.Edges) {
                    delete e._used_;
                }
                for (let f of this.Faces) {
                    for (let loop of f.Loops) {
                        let cur = loop;
                        do {
                            cur._used_ = true;
                            cur = cur.Next;
                        } while (cur != loop && cur != null);
                    }
                }
                for (let e of this.Edges) {
                    if (e._used_ === undefined) {
                        this.Remove(e);
                    }
                    else {
                        if (e.Opp != null &&
                            (e.Opp._used_ === undefined || e.Opp.Parent != this)) {
                            delete e.Opp;
                        }
                    }
                }
            }
            RemoveUnusedVerts() {
                for (let v of this.Vertics) {
                    delete v._used_;
                }
                for (let e of this.Edges) {
                    let v = e.V;
                    v._used_ = true;
                }
                for (var v of this.Vertics) {
                    if (v._used_ === undefined) {
                        this.Remove(v);
                    }
                    delete v._used_;
                }
            }
            GetShellsByMid() {
                var smg_map = {};
                for (var f of this.Faces) {
                    var grp_id = f.SG;
                    var smg_grp = smg_map[grp_id];
                    if (smg_grp == null) {
                        smg_grp = smg_map[grp_id] = {
                            fs: []
                        };
                    }
                    smg_grp.fs.push(f);
                }
                var result = {};
                for (var i in smg_map) {
                    var smg_grp = smg_map[i];
                    var mlds = this.CreateShellsByMid(smg_grp.fs);
                    for (let mid in mlds) {
                        let shells = result[mid];
                        if (shells == null)
                            shells = result[mid] = [];
                        shells.push(...mlds[mid]);
                    }
                }
                return result;
            }
            CreateShellsByMid(faces) {
                var r_v_ps = [];
                var r_v_ns = [];
                var r_v_uv = [];
                var b_v_ps = [];
                var b_v_ns = [];
                var b_v_uv = [];
                var fsbyMat = {};
                var vmap = {};
                var mesh = this;
                var vs = mesh.Vertics.map(o_ => o_.P);
                let hasnullprj = false;
                for (var f of faces) {
                    var mid = f.MG;
                    var norm = f.GetNorm();
                    for (let loop of f.Loops) {
                        for (let vert of loop.GetLoopVs()) {
                            let vid = vert.ID;
                            var vinfo = vmap[vid];
                            if (vinfo == null) {
                                vinfo = vmap[vid] = {
                                    idx: b_v_ps.length,
                                    fnum: 0
                                };
                                b_v_ps.push(vert.P);
                                b_v_ns.push(U1.Vector3.Zero);
                                b_v_uv.push(U1.Vector2.Zero);
                            }
                            vinfo.fnum++;
                            b_v_ns[vinfo.idx].Add(norm);
                        }
                    }
                }
                for (var vid in vmap) {
                    var vinfo = vmap[vid];
                    b_v_ns[vinfo.idx].Normalize();
                }
                for (let f of faces) {
                    let mid = f.MG;
                    let fs = fsbyMat[mid];
                    if (fs == null)
                        fs = fsbyMat[mid] = [];
                    var nf = new U1.BRep.Face();
                    fs.push(nf);
                    for (let loop of f.Loops) {
                        let last_v = r_v_ps.length;
                        let indics = [];
                        for (let edg of loop.GetLoop()) {
                            let vtx = edg.V;
                            let vi = vtx.ID;
                            var o_v = vmap[vi];
                            let o_idx = o_v.idx;
                            r_v_ps.push(vtx.P);
                            r_v_ns.push(b_v_ns[o_idx]);
                            r_v_uv.push(edg.UV);
                            indics.push(last_v++);
                        }
                        if (nf.Boundary == null)
                            nf.Boundary = indics;
                        else {
                            if (nf.Holes == null)
                                nf.Holes = [];
                            nf.Holes.push(indics);
                        }
                    }
                }
                var vertics = [];
                for (var i = 0; i < r_v_ps.length; i++) {
                    var vtx = new U1.BRep.Vertex();
                    vtx.CopyFrom(r_v_ps[i]);
                    vtx.UV0 = r_v_uv[i];
                    vtx.Normal = r_v_ns[i];
                    vtx.Num = i;
                    vertics.push(vtx);
                }
                var result = {};
                for (let mid in fsbyMat) {
                    let fs = fsbyMat[mid];
                    let m_id = parseInt(mid);
                    let shells = result[mid];
                    if (shells == null)
                        shells = result[mid] = [];
                    let shell = new U1.BRep.Shell();
                    shell.Vertices = vertics;
                    shell.Faces = fs;
                    shells.push(shell);
                }
                return result;
            }
            GetMeshBuffersByMid() {
                var smg_map = {};
                for (var f of this.Faces) {
                    var grp_id = f.SG;
                    var smg_grp = smg_map[grp_id];
                    if (smg_grp == null) {
                        smg_grp = smg_map[grp_id] = {
                            fs: []
                        };
                    }
                    smg_grp.fs.push(f);
                }
                var result = {};
                let buffers = {};
                for (var i in smg_map) {
                    var smg_grp = smg_map[i];
                    this.CreateMeshBuffersByMid(smg_grp.fs, buffers);
                }
                for (let mid in buffers) {
                    let buffer = buffers[mid];
                    let geom = new U1.MeshBufferGeometry();
                    geom.pos = new Float32Array(buffer.pos);
                    geom.normal = new Float32Array(buffer.norm);
                    geom.uv0 = new Float32Array(buffer.uv);
                    geom.indices = new Uint16Array(buffer.indices);
                    result[mid] = geom;
                }
                return result;
            }
            CreateMeshBuffersByMid(faces, result) {
                var b_v_ns = [];
                var fsbyMat = {};
                var vmap = {};
                var mesh = this;
                var vs = mesh.Vertics.map(o_ => o_.P);
                let hasnullprj = false;
                for (var f of faces) {
                    var mid = f.MG;
                    var norm = f.GetNorm();
                    for (let loop of f.Loops) {
                        for (let vert of loop.GetLoopVs()) {
                            let vid = vert.ID;
                            var vinfo = vmap[vid];
                            if (vinfo == null) {
                                vinfo = vmap[vid] = {
                                    idx: b_v_ns.length,
                                    fnum: 0
                                };
                                b_v_ns.push(U1.Vector3.Zero);
                            }
                            vinfo.fnum++;
                            b_v_ns[vinfo.idx].Add(norm);
                        }
                    }
                }
                for (var vid in vmap) {
                    var vinfo = vmap[vid];
                    b_v_ns[vinfo.idx].Normalize();
                }
                for (let f of faces) {
                    let mid = f.MG;
                    let fs = fsbyMat[mid];
                    if (fs == null)
                        fs = fsbyMat[mid] = [];
                    var nf = { ps: [], ns: [], uv: [] };
                    fs.push(nf);
                    for (let loop of f.Loops) {
                        for (let edg of loop.GetLoop()) {
                            let vtx = edg.V;
                            let vi = vtx.ID;
                            var o_v = vmap[vi];
                            let o_idx = o_v.idx;
                            nf.ps.push(vtx.P);
                            nf.ns.push(b_v_ns[o_idx]);
                            nf.uv.push(edg.UV);
                        }
                    }
                    nf.TriFaces = f.Tesselate();
                }
                for (let mid in fsbyMat) {
                    let fs = fsbyMat[mid];
                    let m_id = parseInt(mid);
                    let buffer = result[mid];
                    if (buffer == null)
                        buffer = result[mid] = { pos: [], uv: [], indices: [], norm: [] };
                    for (let f of fs) {
                        let last_i = buffer.pos.length / 3;
                        for (let i = 0; i < f.ps.length; i++) {
                            let pos = f.ps[i];
                            let nom = f.ns[i];
                            let uv = f.uv[i];
                            buffer.pos.push(pos.X, pos.Y, pos.Z);
                            buffer.norm.push(nom.X, nom.Y, nom.Z);
                            buffer.uv.push(uv.X, uv.Y);
                        }
                        let indics = f.TriFaces.map(o_ => o_ + last_i);
                        buffer.indices.push(...indics);
                    }
                }
                return result;
            }
            GetEdgeGeometry() {
                let pos = new Float32Array(this.Vertics.length * 3);
                let indics = new Uint16Array(this.Edges.length * 2);
                let vmap = {};
                let pi = -1;
                let vi = -1;
                for (let v of this.Vertics) {
                    vmap[v.ID] = ++vi;
                    let p = v.P;
                    pos[++pi] = p.X;
                    pos[++pi] = p.Y;
                    pos[++pi] = p.Z;
                }
                for (let f of this.Faces) {
                    for (let loop of f.Loops) {
                        for (let e of loop.GetLoop()) {
                            e._oid_ = f.FG;
                        }
                    }
                }
                let ii = -1;
                for (let e of this.Edges) {
                    if (e.Opp != null && e._oid_ === e.Opp._oid_)
                        continue;
                    let cv = e.V;
                    let nv = e.Next.V;
                    indics[++ii] = vmap[cv.ID];
                    indics[++ii] = vmap[nv.ID];
                }
                let res = new U1.LineBufferGeometry();
                res.pos = pos;
                res.indices = indics;
                return res;
            }
            RegisterEdge(s, e) {
                let opp_e = this.Edges.filter(o_ => o_.Next != null
                    && o_.Opp == null
                    && o_.V == e
                    && o_.Next.V == s)[0];
                let edge = this.NewEdge();
                edge.V = s;
                if (opp_e != null) {
                    opp_e.Opp = edge;
                    edge.Opp = opp_e;
                }
                return edge;
            }
            GetBoundingBox(result, matrix) {
                let s_ = MMesh['.gbb.'] || (MMesh['.gbb.'] = {});
                result = result || new U1.BoundingBox();
                this.UpdateCache();
                result.Min = this._cache.min;
                result.Max = this._cache.max;
                if (matrix != null) {
                    let min = s_.min || (s_.min = new U1.Vector3());
                    let max = s_.max || (s_.max = new U1.Vector3());
                    min.SetMaxValue();
                    max.SetMinValue();
                    let corners = s_.cs || (s_.cs = []);
                    corners = result.GetCorners(corners);
                    for (let p of corners) {
                        p.Transform(matrix);
                        min.Minimize(p);
                        max.Maximize(p);
                    }
                    result.Min.CopyFrom(min);
                    result.Max.CopyFrom(max);
                }
                return result;
            }
            Flip() {
                for (let f of this.Faces) {
                    for (let loop of f.Loops) {
                        let es = loop.GetLoop();
                        let vs = loop.GetLoopVs();
                        let pi = es.length - 1;
                        let sv = vs[0];
                        let suv = es[0].UV;
                        for (let ci = 0; ci < es.length; pi = ci, ci++) {
                            let edg = es[ci];
                            if (ci < es.length - 1) {
                                let next = edg.Next;
                                edg.V = next.V;
                                edg.UV = next.UV;
                            }
                            else {
                                edg.V = sv;
                                edg.UV = suv;
                            }
                            edg.Next = es[pi];
                        }
                    }
                }
                this.CacheVer++;
            }
            ApplyTexProj(tex_prj) {
                for (var f of this.Faces) {
                    f.ApplyTexProj(tex_prj);
                }
            }
            GetRelModels() {
                return this.GetInverse(Meshes.MModel, "Mesh");
            }
            InvokeChildPropertyChanged(source, name) {
                this.CacheVer++;
            }
            OnChildAdded(child) {
                this.CacheVer++;
            }
            UpdateCache() {
                let cache = this._cache;
                if (cache.ver == this.CacheVer)
                    return;
                cache.ver = this.CacheVer;
                let min = cache.min;
                let max = cache.max;
                min.SetMaxValue();
                max.SetMinValue();
                let vs = this.Vertics;
                for (let v of vs) {
                    min.Minimize(v.P);
                    max.Maximize(v.P);
                }
            }
            ReadProps(props) {
                super.ReadProps(props);
            }
            WriteProps(props) {
                super.WriteProps(props);
            }
            Clone(res_map) {
                res_map = res_map || {};
                let copy = super.Clone(res_map);
                for (let ch of copy.Children) {
                    if (ch instanceof Meshes.MEdg) {
                        let e = ch;
                        e.V = res_map[ch.V.HND];
                        if (e.Opp) {
                            e.Opp = res_map[ch.Opp.HND];
                        }
                        if (e.Next) {
                            e.Next = res_map[ch.Next.HND];
                        }
                    }
                    else if (ch instanceof Meshes.MFace) {
                        let f = ch;
                        let loops = f.Loops.slice();
                        for (let i = 0; i < loops.length; i++) {
                            let e = loops[i];
                            loops[i] = res_map[e.HND];
                        }
                        f.Loops = loops;
                    }
                }
                return copy;
            }
        }
        Meshes.MMesh = MMesh;
        U1.UDocument.Creaters["MMesh"] = MMesh;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MMtl extends U1.UNode {
            constructor() {
                super(...arguments);
                this.alpha = 1;
            }
            get Alpha() {
                return this.alpha;
            }
            set Alpha(value) {
                this.SetProperty("Alpha", "alpha", value);
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.Alpha = props.GetFloat("Alpha", this.Alpha);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetFloat("Alpha", this.Alpha);
            }
        }
        Meshes.MMtl = MMtl;
        class MMtlUse extends U1.UNode {
            get MGrp() {
                return this._mgrp;
            }
            set MGrp(value) {
                this.SetProperty("MGrp", "_mgrp", value);
            }
            get Mat() {
                return this._mat;
            }
            set Mat(value) {
                this.SetRelProperty("Mat", "_mat", value);
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.Mat = props.GetRef("Mat", this.Mat);
                this._mgrp = props.GetInt("MGrp", this._mgrp);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetRef("Mat", this._mat);
                props.SetInt("MGrp", this._mgrp);
            }
        }
        Meshes.MMtlUse = MMtlUse;
        class MMtlColr extends MMtl {
            constructor() {
                super(...arguments);
                this.color = U1.Colors.Gray;
            }
            get Color() {
                return this.color;
            }
            set Color(value) {
                this.SetProperty("Color", "color", value);
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.Color = props.GetValue(U1.Color, "Color", this.Color);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetValue("Color", this.Color);
            }
        }
        Meshes.MMtlColr = MMtlColr;
        class MMtlTex extends MMtl {
            constructor() {
                super(...arguments);
                this.diffuse = U1.Colors.Gray;
            }
            get Diffuse() {
                return this.diffuse;
            }
            set Diffuse(value) {
                this.SetProperty("Diffuse", "diffuse", value);
            }
            get DifTex() {
                return this.difTex;
            }
            set DifTex(value) {
                this.SetRelProperty("DifTex", "difTex", value);
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.Diffuse = props.GetValue(U1.Color, "Diffuse", this.Diffuse);
                this.DifTex = props.GetRef("DifTex", this.DifTex);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetValue("Diffuse", this.Diffuse);
                props.SetRef("DifTex", this.DifTex);
            }
        }
        Meshes.MMtlTex = MMtlTex;
        U1.UDocument.Creaters["MMtl"] = MMtl;
        U1.UDocument.Creaters["MMtlColr"] = MMtlColr;
        U1.UDocument.Creaters["MMtlTex"] = MMtlTex;
        U1.UDocument.Creaters["MMtlUse"] = MMtlUse;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        let MTexPrjKinds;
        (function (MTexPrjKinds) {
            MTexPrjKinds[MTexPrjKinds["Plane"] = 0] = "Plane";
            MTexPrjKinds[MTexPrjKinds["Box"] = 1] = "Box";
            MTexPrjKinds[MTexPrjKinds["Sphere"] = 2] = "Sphere";
            MTexPrjKinds[MTexPrjKinds["Cylinder"] = 3] = "Cylinder";
        })(MTexPrjKinds = Meshes.MTexPrjKinds || (Meshes.MTexPrjKinds = {}));
        class MTexPrj extends U1.UNode {
            constructor() {
                super(...arguments);
                this.xform = U1.Matrix4.Identity;
                this.prjkind = 0;
            }
            get XForm() {
                return this.xform;
            }
            set XForm(value) {
                this.SetProperty("XForm", "xform", value);
            }
            get PrjKind() {
                return this.prjkind;
            }
            set PrjKind(value) {
                this.SetProperty("PrjKind", "prjkind", value);
            }
            GetUV(p, n, result) {
                var s_;
                s_ = MTexPrj[".guv."] || (MTexPrj[".guv."] = s_ =
                    {
                        v0: U1.Vector3.Zero,
                        v1: U1.Vector3.Zero,
                        v2: U1.Vector3.Zero,
                        v3: U1.Vector3.Zero
                    });
                result = result || new U1.Vector2();
                result.Set(0, 0);
                var prjKind = this.PrjKind;
                var m = this.XForm;
                var axu = m.GetRight(s_.v0);
                var axv = m.GetUp(s_.v1);
                var ax = s_.v2;
                var v = U1.Vector3.Subtract(p, m.Translation, s_.v3);
                if (prjKind == MTexPrjKinds.Plane) {
                    result.X = U1.Vector3.Dot(v, axu) / U1.Vector3.Dot(axu, axu);
                    result.Y = U1.Vector3.Dot(v, axv) / U1.Vector3.Dot(axv, axv);
                    return result;
                }
                else if (prjKind == MTexPrjKinds.Box) {
                    var max_dt = 0;
                    m.GetBackward(ax);
                    let off_u = 0.5;
                    let off_v = 0.5;
                    var dt = max_dt = U1.Vector3.Dot(ax, n);
                    m.GetRight(axu);
                    m.GetDown(axv);
                    m.GetForward(ax);
                    if ((dt = U1.Vector3.Dot(ax, n)) > max_dt) {
                        max_dt = dt;
                        m.GetLeft(axu);
                        m.GetDown(axv);
                    }
                    m.GetRight(ax);
                    if ((dt = U1.Vector3.Dot(ax, n)) > max_dt) {
                        off_v = 1;
                        max_dt = dt;
                        m.GetUp(axu);
                        m.GetForward(axv);
                    }
                    m.GetLeft(ax);
                    if ((dt = U1.Vector3.Dot(ax, n)) > max_dt) {
                        off_v = 1;
                        max_dt = dt;
                        m.GetDown(axu);
                        m.GetForward(axv);
                    }
                    m.GetUp(ax);
                    if ((dt = U1.Vector3.Dot(ax, n)) > max_dt) {
                        off_v = 1;
                        max_dt = dt;
                        m.GetLeft(axu);
                        m.GetForward(axv);
                    }
                    m.GetDown(ax);
                    if ((dt = U1.Vector3.Dot(ax, n)) > max_dt) {
                        off_v = 1;
                        max_dt = dt;
                        m.GetRight(axu);
                        m.GetForward(axv);
                    }
                    result.X = U1.Vector3.Dot(v, axu) / U1.Vector3.Dot(axu, axu) + off_u;
                    result.Y = U1.Vector3.Dot(v, axv) / U1.Vector3.Dot(axv, axv) + off_v;
                    return result;
                }
                else if (prjKind == MTexPrjKinds.Cylinder) {
                    m.GetForward(axv);
                    m.GetRight(axu);
                    ax.CopyFrom(axv);
                    ax.Normalize();
                    let dt = U1.Vector3.Dot(ax, n);
                    if (Math.abs(dt) > 0.5) {
                        let off_u = 0.5;
                        let off_v = 0.5;
                        if (dt < 0) {
                            m.GetRight(axu);
                            m.GetDown(axv);
                        }
                        else {
                            m.GetLeft(axu);
                            off_u = 0.5;
                            m.GetDown(axv);
                        }
                        result.X = U1.Vector3.Dot(v, axu) / U1.Vector3.Dot(axu, axu) + off_u;
                        result.Y = U1.Vector3.Dot(v, axv) / U1.Vector3.Dot(axv, axv) + off_v;
                    }
                    else {
                        result.Y = U1.Vector3.Dot(v, axv) / U1.Vector3.Dot(axv, axv);
                        v.Subtract(ax.SetScale(axv, result.Y));
                        result.Y += 1;
                        result.X = U1.GeometryHelper3.AngleCCW(axu, axv, v) / (2 * Math.PI);
                    }
                    return result;
                }
                else if (prjKind == MTexPrjKinds.Sphere) {
                    m.GetBackward(axv);
                    m.GetRight(axu);
                    var v1 = U1.Vector3.Normalize(v, ax);
                    result.Y = Math.acos(U1.Vector3.Dot(v1, axv)) / Math.PI;
                    v.Subtract(axv.Scale(result.Y));
                    result.X = U1.GeometryHelper3.AngleCCW(axu, axv, v) / (2 * Math.PI);
                    return result;
                }
                return result;
            }
            IsCylinderSide(p, n) {
                var prjKind = this.PrjKind;
                if (prjKind != MTexPrjKinds.Cylinder)
                    return false;
                var s_;
                s_ = MTexPrj[".ics."] || (MTexPrj[".ics."] = s_ =
                    {
                        v0: U1.Vector3.Zero,
                        v1: U1.Vector3.Zero,
                        v2: U1.Vector3.Zero,
                        v3: U1.Vector3.Zero
                    });
                var m = this.XForm;
                var axu = s_.v0;
                var axv = s_.v1;
                var ax = s_.v2;
                m.GetForward(axv);
                m.GetRight(axu);
                ax.CopyFrom(axv);
                ax.Normalize();
                let dt = U1.Vector3.Dot(ax, n);
                if (Math.abs(dt) > 0.5) {
                    return false;
                }
                return true;
            }
            CopyFrom(other) {
                this.XForm = other.XForm;
                this.PrjKind = other.PrjKind;
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.XForm = props.GetValue(U1.Matrix4, "XForm", this.XForm);
                this.PrjKind = props.GetInt("PrjKind", this.PrjKind);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetValue("XForm", this.XForm);
                props.SetInt("PrjKind", this.PrjKind);
            }
        }
        Meshes.MTexPrj = MTexPrj;
        U1.UDocument.Creaters["MTexPrj"] = MTexPrj;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MTexture extends U1.UNode {
            constructor(name) {
                super();
                this.uri = "";
                this.Name = name;
            }
            get Uri() {
                return this.uri;
            }
            set Uri(value) {
                this.SetProperty("Uri", "uri", value);
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.Uri = props.GetStr("Uri", this.Uri);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetStr("Uri", this.Uri);
            }
        }
        Meshes.MTexture = MTexture;
        U1.UDocument.Creaters["MTexture"] = MTexture;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MVert extends U1.UNode {
            constructor() {
                super(...arguments);
                this.p = U1.Vector3.Zero;
            }
            get Mesh() {
                if (this.Parent instanceof Meshes.MMesh)
                    return this.Parent;
                return null;
            }
            get P() {
                return this.p;
            }
            set P(value) {
                this.SetProperty("P", "p", value);
            }
            ClassifiedByType() {
                return false;
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.P = props.GetValue(U1.Vector3, "P", this.P);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetValue("P", this.P);
            }
        }
        Meshes.MVert = MVert;
        U1.UDocument.Creaters["MVert"] = MVert;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MEdg extends U1.UNode {
            get V() {
                return this.v;
            }
            set V(value) {
                this.SetProperty("V", "v", value);
            }
            get UV() {
                return this.uv;
            }
            set UV(value) {
                this.SetProperty("UV", "uv", value);
            }
            get Next() {
                return this.n;
            }
            set Next(value) {
                this.SetProperty("Next", "n", value);
            }
            get Opp() {
                return this.o;
            }
            set Opp(value) {
                this.SetProperty("Opp", "o", value);
            }
            ClassifiedByType() {
                return false;
            }
            GetLoop() {
                let result = [];
                let cur = this;
                do {
                    result.push(cur);
                    cur = cur.Next;
                } while (cur != this && cur != null);
                return result;
            }
            GetLoopVs() {
                return this.GetLoop().map(o_ => o_.V);
            }
            ReadProps(props) {
                super.ReadProps(props);
                this.V = props.GetRef("V", this.v);
                this.UV = props.GetValue(U1.Vector2, "UV", this.UV);
                this.Next = props.GetRef("Next", this.n);
                this.Opp = props.GetRef("Opp", this.o);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetRef("V", this.V);
                props.SetValue("UV", this.UV);
                props.SetRef("Next", this.Next);
                props.SetRef("Opp", this.Opp);
            }
            toString() {
                return `${this.v.P.toString()} - ${this.Next.v.P.toString()}`;
            }
        }
        Meshes.MEdg = MEdg;
        U1.UDocument.Creaters["MEdg"] = MEdg;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Meshes;
    (function (Meshes) {
        class MCube extends Meshes.MParamModel {
            constructor() {
                super(...arguments);
                this._w = 1.0;
                this._l = 1.0;
                this._h = 1.0;
            }
            get W() {
                return this._w;
            }
            set W(value) {
                this.SetProperty("W", "_w", value);
            }
            get L() {
                return this._l;
            }
            set L(value) {
                this.SetProperty("L", "_l", value);
            }
            get H() {
                return this._h;
            }
            set H(value) {
                this.SetProperty("H", "_h", value);
            }
            UpdateMesh() {
                let _vs = MCube._vs;
                let _fs = MCube._fs;
                let w = this.W;
                let l = this.L;
                let h = this.H;
                let size = new U1.Vector3(w, l, h);
                let mesh = this.Mesh;
                if (mesh != null) {
                    if (mesh.Parent == this)
                        this.Remove(mesh);
                }
                {
                    mesh = this.AddChild(Meshes.MMesh);
                }
                let texPrj = new Meshes.MTexPrj();
                texPrj.PrjKind = Meshes.MTexPrjKinds.Box;
                texPrj.XForm = U1.Matrix4.CreateScale(size);
                let ps = mesh.Vertics;
                let vmap = {};
                for (let i = 0; i < _vs.length; i++) {
                    let p = ps[i];
                    if (p == null) {
                        p = mesh.NewVert(U1.Vector3.Zero);
                    }
                    var v3 = _vs[i].Clone();
                    v3.Multiply(size);
                    p.P = v3;
                    vmap[i] = p;
                }
                var fs = mesh.Faces;
                for (let i = 0; i < 6; i++) {
                    let f = fs[i];
                    if (f == null) {
                        f = mesh.NewFace();
                    }
                    f.Init({
                        loops: [_fs[i].map(o_ => vmap[o_])],
                        smgrp: i,
                        mgrp: i,
                        texPrj: texPrj
                    });
                }
                this.Mesh = mesh;
                super.UpdateMesh();
            }
            ReadProps(props) {
                super.ReadProps(props);
                this._w = props.GetFloat("W", this.W);
                this._l = props.GetFloat("L", this.L);
                this._h = props.GetFloat("H", this.H);
            }
            WriteProps(props) {
                super.WriteProps(props);
                props.SetFloat("W", this.W);
                props.SetFloat("L", this.L);
                props.SetFloat("H", this.H);
            }
            GetUPropsCategory() {
                return "Box";
            }
            GetUProps() {
                var this_ = this;
                let props = [
                    new U1.UPropDouble({
                        GetValueFunc: () => this_.W,
                        SetValueFunc: (p_, v_) => this_.W = v_,
                        Label: "W",
                        EndChangeFunc: () => this_.UpdateMesh()
                    }),
                    new U1.UPropDouble({
                        GetValueFunc: () => this_.H,
                        SetValueFunc: (p_, v_) => this_.H = v_,
                        Label: "H",
                        EndChangeFunc: () => this_.UpdateMesh()
                    }),
                    new U1.UPropDouble({
                        GetValueFunc: () => this_.L,
                        SetValueFunc: (p_, v_) => this_.L = v_,
                        Label: "L",
                        EndChangeFunc: () => this_.UpdateMesh()
                    }),
                ];
                return props;
            }
        }
        MCube._vs = [
            new U1.Vector3(-0.5, -0.5, 0),
            new U1.Vector3(0.5, -0.5, 0),
            new U1.Vector3(0.5, 0.5, 0),
            new U1.Vector3(-0.5, 0.5, 0),
            new U1.Vector3(-0.5, -0.5, 1),
            new U1.Vector3(0.5, -0.5, 1),
            new U1.Vector3(0.5, 0.5, 1),
            new U1.Vector3(-0.5, 0.5, 1)
        ];
        MCube._fs = [
            [0, 1, 5, 4],
            [1, 2, 6, 5],
            [2, 3, 7, 6],
            [3, 0, 4, 7],
            [4, 5, 6, 7],
            [1, 0, 3, 2]
        ];
        Meshes.MCube = MCube;
        U1.UDocument.Creaters["MCube"] = MCube;
    })(Meshes = U1.Meshes || (U1.Meshes = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class GeometryModel {
        constructor() {
            this._transform = U1.Matrix4.Identity;
            this._id = ++GeometryModel._id;
        }
        get ID() {
            return this._id;
        }
        get Transform() {
            return this._transform;
        }
        set Transform(value) {
            this._transform.CopyFrom(value);
        }
        get Children() {
            return this._children;
        }
        set Children(value) {
            this._children = value;
        }
        AddChild(child) {
            this._children = this._children || [];
            this._children.push(child);
            this._bbx = undefined;
        }
        get BoundingBox() {
            this._bbx = this._bbx || new U1.BoundingBox();
            this._bbx.Min.SetMaxValue();
            this._bbx.Max.SetMinValue();
            if (this.Geometry != null) {
                this._bbx.Min.Minimize(this.Geometry.BoundingBox.Min);
                this._bbx.Max.Maximize(this.Geometry.BoundingBox.Max);
            }
            if (this.Children != null) {
                for (var ch of this.Children) {
                    this._bbx.Merge(ch.BoundingBox, ch.Transform);
                }
            }
            return this._bbx;
        }
    }
    GeometryModel._id = 0;
    U1.GeometryModel = GeometryModel;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        let EdgeTypeEnum;
        (function (EdgeTypeEnum) {
            EdgeTypeEnum[EdgeTypeEnum["Solid"] = 0] = "Solid";
            EdgeTypeEnum[EdgeTypeEnum["Hidden"] = 1] = "Hidden";
            EdgeTypeEnum[EdgeTypeEnum["Dot"] = 2] = "Dot";
        })(EdgeTypeEnum = Geoms.EdgeTypeEnum || (Geoms.EdgeTypeEnum = {}));
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        let FontStyleEnum;
        (function (FontStyleEnum) {
            FontStyleEnum[FontStyleEnum["Normal"] = 0] = "Normal";
            FontStyleEnum[FontStyleEnum["Italic"] = 1] = "Italic";
            FontStyleEnum[FontStyleEnum["Oblique"] = 2] = "Oblique";
        })(FontStyleEnum = Geoms.FontStyleEnum || (Geoms.FontStyleEnum = {}));
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        let FontWeightEnum;
        (function (FontWeightEnum) {
            FontWeightEnum[FontWeightEnum["Normal"] = 0] = "Normal";
            FontWeightEnum[FontWeightEnum["Black"] = 1] = "Black";
            FontWeightEnum[FontWeightEnum["Bold"] = 2] = "Bold";
            FontWeightEnum[FontWeightEnum["DemiBold"] = 3] = "DemiBold";
            FontWeightEnum[FontWeightEnum["ExtraBlack"] = 4] = "ExtraBlack";
            FontWeightEnum[FontWeightEnum["ExtraBold"] = 5] = "ExtraBold";
            FontWeightEnum[FontWeightEnum["ExtraLight"] = 6] = "ExtraLight";
            FontWeightEnum[FontWeightEnum["Heavy"] = 7] = "Heavy";
            FontWeightEnum[FontWeightEnum["Light"] = 8] = "Light";
            FontWeightEnum[FontWeightEnum["Medium"] = 9] = "Medium";
            FontWeightEnum[FontWeightEnum["Regular"] = 10] = "Regular";
            FontWeightEnum[FontWeightEnum["SemiBold"] = 11] = "SemiBold";
            FontWeightEnum[FontWeightEnum["Thin"] = 12] = "Thin";
            FontWeightEnum[FontWeightEnum["UltraBlack"] = 13] = "UltraBlack";
            FontWeightEnum[FontWeightEnum["UltraBold"] = 14] = "UltraBold";
            FontWeightEnum[FontWeightEnum["UltraLight"] = 15] = "UltraLight";
        })(FontWeightEnum = Geoms.FontWeightEnum || (Geoms.FontWeightEnum = {}));
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        let TextAlignmentEnum;
        (function (TextAlignmentEnum) {
            TextAlignmentEnum[TextAlignmentEnum["Left"] = 0] = "Left";
            TextAlignmentEnum[TextAlignmentEnum["Right"] = 1] = "Right";
            TextAlignmentEnum[TextAlignmentEnum["Center"] = 2] = "Center";
            TextAlignmentEnum[TextAlignmentEnum["Justify"] = 3] = "Justify";
        })(TextAlignmentEnum = Geoms.TextAlignmentEnum || (Geoms.TextAlignmentEnum = {}));
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        let TextWrappingEnum;
        (function (TextWrappingEnum) {
            TextWrappingEnum[TextWrappingEnum["WrapWithOverflow"] = 0] = "WrapWithOverflow";
            TextWrappingEnum[TextWrappingEnum["NoWrap"] = 1] = "NoWrap";
            TextWrappingEnum[TextWrappingEnum["Wrap"] = 2] = "Wrap";
        })(TextWrappingEnum = Geoms.TextWrappingEnum || (Geoms.TextWrappingEnum = {}));
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GeEntity {
            constructor(other) {
                this.Pickable = true;
                this.Visible = true;
                this.Color = U1.Colors.Black;
                if (other !== undefined) {
                    this.Pickable = other.Pickable;
                    this.Visible = other.Visible;
                    if (other.SnapPoints != null) {
                        this.SnapPoints = other.SnapPoints.map(o_ => o_.Clone());
                    }
                    this.Color = other.Color;
                }
            }
            Min(result) {
                return result;
            }
            Max(result) {
                return result;
            }
        }
        Geoms.GeEntity = GeEntity;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GeArc extends Geoms.GeEntity {
            constructor() {
                super(...arguments);
                this.Center = new U1.Vector3();
                this.Radius = 1;
                this.StartAngle = 0;
                this.EndAngle = Math.PI;
                this.Thick = 1;
            }
            get Points() {
                if (this.tesseleted_points == null)
                    this.Tesselate();
                return this.tesseleted_points;
            }
            Tesselate(angle_step = 0.193) {
                if (this.step == angle_step && this.tesseleted_points != null) {
                    return this.tesseleted_points;
                }
                this.step = angle_step;
                var ls = new Array();
                var p = U1.Vector3.Zero;
                var sa = this.StartAngle;
                var ea = this.EndAngle;
                var Radius = this.Radius;
                if (sa > ea) {
                    ea += Math.PI * 2;
                }
                for (var a = sa; a < ea; a += angle_step) {
                    p.X = Math.cos(a) * Radius;
                    p.Y = Math.sin(a) * Radius;
                    p.Add(this.Center);
                    ls.push(p.Clone());
                }
                p.X = Math.cos(ea) * Radius;
                p.Y = Math.sin(ea) * Radius;
                p.Add(this.Center);
                ls.push(p);
                this.tesseleted_points = ls;
                this._min.SetMaxValue();
                this._min.Minimize(ls);
                this._max.SetMinValue();
                this._max.Maximize(ls);
                return this.tesseleted_points;
            }
            Min(result) {
                result = result || new U1.Vector3();
                if (this.tesseleted_points == null)
                    this.Tesselate();
                return result.CopyFrom(this._min);
            }
            Max(result) {
                result = result || new U1.Vector3();
                if (this.tesseleted_points == null)
                    this.Tesselate();
                return result.CopyFrom(this._max);
            }
        }
        Geoms.GeArc = GeArc;
        class GeArcFill extends GeArc {
            get FaceIndices() {
                if (this.m_faceIndices == null || this.m_faceIndices.length != (this.Points.length - 2) * 3) {
                    var ilist = [];
                    var last = this.Points.length;
                    for (var i = 2; i < last; i++) {
                        ilist.push(i - 2);
                        ilist.push(i - 1);
                        ilist.push(i);
                    }
                    this.m_faceIndices = ilist;
                }
                return this.m_faceIndices;
            }
        }
        Geoms.GeArcFill = GeArcFill;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GeCircle extends Geoms.GeEntity {
            constructor() {
                super(...arguments);
                this.Center = U1.Vector3.Zero;
                this.Radius = 1;
                this.Thick = 1;
            }
            get Points() {
                if (this.tesseleted_points == null)
                    this.Tesselate();
                return this.tesseleted_points;
            }
            Tesselate(angle_step = 0.193) {
                if (this.step == angle_step && this.tesseleted_points != null) {
                    return this.tesseleted_points;
                }
                this.step = angle_step;
                var ls = new Array();
                var p = U1.Vector3.Zero;
                var sa = 0.0;
                var ea = Math.PI * 2;
                var Radius = this.Radius;
                var Center = this.Center;
                if (sa > ea) {
                    ea += Math.PI * 2;
                }
                for (var a = sa; a < ea; a += angle_step) {
                    p.X = Math.cos(a) * Radius;
                    p.Y = Math.sin(a) * Radius;
                    p.Add(Center);
                    ls.push(p.Clone());
                }
                p.X = Math.cos(ea) * Radius;
                p.Y = Math.sin(ea) * Radius;
                p.Add(Center);
                ls.push(p.Clone());
                this.tesseleted_points;
                this._min.SetMaxValue().Minimize(ls);
                this._max.SetMinValue().Maximize(ls);
                return this.tesseleted_points;
            }
            Min(result) {
                result = result || new U1.Vector3();
                if (this.tesseleted_points == null)
                    this.Tesselate();
                return result.CopyFrom(this._min);
            }
            Max(result) {
                result = result || new U1.Vector3();
                if (this.tesseleted_points == null)
                    this.Tesselate();
                return result.CopyFrom(this._max);
            }
        }
        Geoms.GeCircle = GeCircle;
        class GeCircleFill extends GeCircle {
            get FaceIndices() {
                if (this.m_faceIndices == null || this.m_faceIndices.length != (this.Points.length - 2) * 3) {
                    var ilist = new Array();
                    var last = this.Points.length;
                    for (var i = 2; i < last; i++) {
                        ilist.push(i - 2);
                        ilist.push(i - 1);
                        ilist.push(i);
                    }
                    this.m_faceIndices = ilist;
                }
                return this.m_faceIndices;
            }
        }
        Geoms.GeCircleFill = GeCircleFill;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GeLine extends Geoms.GeEntity {
            constructor(other) {
                super();
                this.Start = U1.Vector3.Zero;
                this.End = U1.Vector3.Zero;
                this.Thick = 1;
                if (other instanceof GeLine) {
                    this.Start.CopyFrom(other.Start);
                    this.End.CopyFrom(other.End);
                    this.Thick = other.Thick;
                    this.LinePattern = other.LinePattern != null ? other.LinePattern.slice() : null;
                }
            }
            Min(result) {
                result = result || new U1.Vector3();
                return result.SetMin(this.Start, this.End);
            }
            Max(result) {
                return result.SetMax(this.Start, this.End);
            }
            Set(start, end, color, thick, linePattern) {
                this.Color.CopyFrom(color);
                this.Thick = thick;
                this.Start.CopyFrom(start);
                this.End.CopyFrom(end);
                this.LinePattern = linePattern != null ? linePattern.slice() : null;
            }
        }
        Geoms.GeLine = GeLine;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GeLineData extends Geoms.GeEntity {
            Min(result) {
                result = result || new U1.Vector3();
                return result.CopyFrom(this.LineData.BoundingBox.Min);
            }
            Max(result) {
                result = result || new U1.Vector3();
                return result.CopyFrom(this.LineData.BoundingBox.Max);
            }
        }
        Geoms.GeLineData = GeLineData;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GeNode {
            constructor() {
                this.Transform = U1.Matrix4.Identity;
            }
            get BoundingBox() {
                if (this._boundingBox == null) {
                    this._boundingBox = this.UpdateBoundingBox();
                }
                return this._boundingBox;
            }
            UpdateBoundingBox() {
                var min = U1.Vector3.MaxValue;
                var max = U1.Vector3.MinValue;
                var tmin = U1.Vector3.MaxValue;
                var tmax = U1.Vector3.MinValue;
                var corners = [U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero,
                    U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero, U1.Vector3.Zero];
                if (this.Entities != null) {
                    for (var ent of this.Entities) {
                        min = U1.Vector3.Min(ent.Min(tmin), min);
                        max = U1.Vector3.Max(ent.Max(tmax), max);
                    }
                }
                if (this.Children != null) {
                    for (var ch of this.Children) {
                        var bbx = ch.BoundingBox;
                        for (var p of bbx.GetCorners(corners).map(o_ => o_.Transform(ch.Transform))) {
                            min = U1.Vector3.Min(p, min);
                            max = U1.Vector3.Max(p, max);
                        }
                    }
                }
                return new U1.BoundingBox(min, max);
            }
            HasEntities() {
                if (this.Entities != null && this.Entities.length > 0)
                    return true;
                if (this.Children != null) {
                    for (var ch of this.Children) {
                        if (ch.HasEntities())
                            return true;
                    }
                }
                return false;
            }
            AddChild(child) {
                if (this.Children == null)
                    this.Children = [];
                this.Children.push(child);
                return this;
            }
            AddEntity(entity) {
                if (this.Entities == null)
                    this.Entities = [];
                this.Entities.push(entity);
            }
            AddEntities(entities) {
                if (entities == null || entities.length == 0)
                    return;
                if (this.Entities == null)
                    this.Entities = [];
                for (var ent of entities)
                    this.Entities.push(ent);
            }
            Clone() {
                var clone = new GeNode();
                clone.Element = this.Element;
                clone.Transform = this.Transform;
                clone.IsSelected = this.IsSelected;
                if (this.Children != null)
                    clone.Children = this.Children.map(o_ => o_.Clone());
                if (this.Entities != null)
                    clone.Entities = this.Entities.slice();
                return clone;
            }
            GetMeshData() {
                var meshData = new U1.MeshBufferGeometry();
                meshData.BeginAppend();
                this.AddToMesh(meshData, U1.Matrix4.Identity);
                meshData.EndAppend();
                return meshData;
            }
            AddToMesh(data, parent_xform) {
                var xform = U1.Matrix4.Multiply(this.Transform, parent_xform);
                if (this.Entities != null) {
                    for (var ent of this.Entities) {
                        if (ent instanceof Geoms.GeLine) {
                        }
                        else if (ent instanceof Geoms.GePolygonFill) {
                            var polygon = ent;
                        }
                        else if (ent instanceof Geoms.GePolylineFill) {
                            var pline = ent;
                        }
                        else if (ent instanceof Geoms.GeTriFace) {
                            if (ent.IsFilled) {
                                data.AppendFace(ent.P1, ent.P2, ent.P3, xform);
                            }
                        }
                        else if (ent instanceof Geoms.GeText) {
                            var text = ent;
                        }
                    }
                }
                if (this.Children != null) {
                    for (var ch of this.Children) {
                        ch.AddToMesh(data, xform);
                    }
                }
            }
            GetLineData() {
                var lineData = new U1.LineBufferGeometry();
                lineData.BeginAppend();
                this.AddToLineData(lineData, U1.Matrix4.Identity);
                lineData.EndAppend();
                return lineData;
            }
            AddToLineData(data, parent_xform) {
                var xform = U1.Matrix4.Multiply(this.Transform, parent_xform);
                if (this.Entities != null) {
                    for (var ent of this.Entities) {
                        if (ent instanceof Geoms.GeLine) {
                            data.AppendLine(ent.Start, ent.End, xform);
                        }
                        else if (ent instanceof Geoms.GePolygon) {
                            data.AddppendPolygon(ent.Points, xform);
                        }
                        else if (ent instanceof Geoms.GePolyline) {
                            data.AddppendPolyline(ent.Points, xform);
                        }
                        else if (ent instanceof Geoms.GeArc) {
                            data.AddppendPolyline(ent.Tesselate(), xform);
                        }
                        else if (ent instanceof Geoms.GeCircle) {
                            data.AddppendPolyline(ent.Tesselate(), xform);
                        }
                        else if (ent instanceof Geoms.GeTriFace) {
                            if (ent.E1 == Geoms.EdgeTypeEnum.Solid)
                                data.AppendLine(ent.P1, ent.P2, xform);
                            if (ent.E2 == Geoms.EdgeTypeEnum.Solid)
                                data.AppendLine(ent.P2, ent.P3, xform);
                            if (ent.E3 == Geoms.EdgeTypeEnum.Solid)
                                data.AppendLine(ent.P3, ent.P1, xform);
                        }
                    }
                }
                if (this.Children != null) {
                    for (var ch of this.Children) {
                        ch.AddToLineData(data, xform);
                    }
                }
            }
        }
        Geoms.GeNode = GeNode;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GePolygon extends Geoms.GeEntity {
            constructor(initData) {
                super();
                this.Thick = 1;
                if (initData !== undefined) {
                    this.Color.CopyFrom(initData.color);
                    this.Thick = initData.thick;
                    this.Points = initData.points != null ? initData.points.slice() : null;
                    this.LinePattern = initData.linePattern != null ? initData.linePattern.slice() : null;
                }
            }
            Min(result) {
                result = result || new U1.Vector3();
                result.SetMaxValue();
                return result.Minimize(this.Points);
            }
            Max(result) {
                result = result || new U1.Vector3();
                result.SetMinValue();
                return result.Maximize(this.Points);
            }
        }
        Geoms.GePolygon = GePolygon;
        class GePolygonFill extends GePolygon {
            constructor(initData) {
                super();
                this.FillColor = U1.Colors.Transparent;
                if (initData !== undefined) {
                    this.FillColor.CopyFrom(initData.fillColor);
                    this.Color.CopyFrom(initData.color);
                    this.Thick = initData.thick;
                    this.Points = initData.points;
                    this.LinePattern = initData.linePattern;
                }
            }
        }
        Geoms.GePolygonFill = GePolygonFill;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GePolyline extends Geoms.GeEntity {
            constructor(initData) {
                super();
                this.Thick = 1;
                if (initData !== undefined) {
                    this.Color = initData.color;
                    this.Thick = initData.thick;
                    this.Points = initData.points;
                    this.LinePattern = initData.linePattern;
                }
            }
            Min(result) {
                result = result || new U1.Vector3();
                result.SetMaxValue();
                return result.Minimize(this.Points);
            }
            Max(result) {
                result = result || new U1.Vector3();
                result.SetMinValue();
                return result.Maximize(this.Points);
            }
        }
        Geoms.GePolyline = GePolyline;
        class GePolylineFill extends GePolyline {
            constructor(initData) {
                super();
                if (initData !== undefined) {
                    this.FillColor = initData.fillColor;
                    this.Color = initData.color;
                    this.Thick = initData.thick;
                    this.Points = initData.points;
                    this.LinePattern = initData.linePattern;
                }
            }
        }
        Geoms.GePolylineFill = GePolylineFill;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GeSnapPoint {
            constructor(pos, snaptype) {
                this.SnapType = 0;
                if (pos !== undefined) {
                    this.Pos = pos;
                }
                if (snaptype !== undefined) {
                    this.SnapType = snaptype;
                }
            }
            Clone() {
                var clone = new this.constructor();
                clone.CopyFrom(this);
                return clone;
            }
            CopyFrom(other) {
                if (other.Pos != null) {
                    this.Pos = this.Pos || new U1.Vector3();
                    this.Pos.CopyFrom(other.Pos);
                }
                else {
                    this.Pos = null;
                }
                this.SnapType = other.SnapType;
                return this;
            }
        }
        Geoms.GeSnapPoint = GeSnapPoint;
        class GeSnapPointArr extends GeSnapPoint {
            constructor(points, snaptype) {
                super();
                if (points !== undefined) {
                    this.Points = points;
                }
                if (snaptype !== undefined) {
                    this.SnapType = snaptype;
                }
            }
            CopyFrom(other) {
                super.CopyFrom(other);
                if (other.Points != null) {
                    this.Points = other.Points.map(o_ => o_.Clone());
                }
                else
                    this.Points = null;
                return this;
            }
        }
        Geoms.GeSnapPointArr = GeSnapPointArr;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        let GeSnapTypeEnum;
        (function (GeSnapTypeEnum) {
            GeSnapTypeEnum[GeSnapTypeEnum["None"] = 0] = "None";
            GeSnapTypeEnum[GeSnapTypeEnum["End"] = 1] = "End";
            GeSnapTypeEnum[GeSnapTypeEnum["Middle"] = 2] = "Middle";
            GeSnapTypeEnum[GeSnapTypeEnum["Center"] = 4] = "Center";
            GeSnapTypeEnum[GeSnapTypeEnum["Vertex"] = 8] = "Vertex";
            GeSnapTypeEnum[GeSnapTypeEnum["All"] = 15] = "All";
        })(GeSnapTypeEnum = Geoms.GeSnapTypeEnum || (Geoms.GeSnapTypeEnum = {}));
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Arc3 {
        constructor() {
            this.up = U1.Vector3.UnitZ;
        }
        get Start() {
            return this.start;
        }
        set Start(value) {
            this.start = value;
        }
        get End() {
            return this.end;
        }
        set End(value) {
            this.end = value;
        }
        get Up() {
            return this.up;
        }
        set Up(value) {
            this.up = value;
        }
        get Bulge() {
            return this.bulge;
        }
        set Bulge(value) {
            this.bulge = value;
        }
        get Radius() {
            if (this.Bulge == 0)
                return 0;
            return U1.Vector3.Distance(this.Center, this.Start);
        }
        get Angle() {
            return U1.GeometryHelper3.AngleBetween(U1.Vector3.Subtract(this.Start, this.Center), U1.Vector3.Subtract(this.End, this.Center));
        }
        get Center() {
            if (this.isCenterDirty) {
                this.GetCenter();
                this.isCenterDirty = false;
            }
            return this.center;
        }
        get Direction() {
            return U1.Vector3.Normalize(U1.Vector3.Subtract(this.end, this.start));
        }
        get Right() {
            return U1.Vector3.Normalize(U1.Vector3.Cross(this.Direction, this.Up));
        }
        get Length() {
            if (this.Bulge == 0)
                return U1.Vector3.Length(U1.Vector3.Subtract(this.End, this.Start));
            var ea = U1.GeometryHelper3.AngleCCW(U1.Vector3.Subtract(this.Start, this.Center), this.Up, U1.Vector3.Subtract(this.End, this.Center));
            if (this.Bulge > 0)
                return ea * this.Radius;
            return Math.round(((Math.PI * 2) - ea) * this.Radius);
        }
        Slice(segmentCount) {
            if (this.bulge != 0) {
                var cent = this.Center;
                var baseAxis = U1.Vector3.Subtract(this.Start, this.Center);
                var ea = U1.GeometryHelper3.AngleCCW(baseAxis, this.Up, U1.Vector3.Subtract(this.End, this.Center));
                var sa = 0.0;
                if (this.Bulge < 0) {
                    ea -= U1.MathHelper.TwoPi;
                }
                var rv = U1.GeometryHelper3.SplitArc(baseAxis, this.Up, sa, ea, segmentCount);
                for (var i = 0; i < rv.length; i++)
                    rv[i] = U1.Vector3.Add(rv[i], cent);
                return rv;
            }
        }
        GetCenter() {
            if (this.start == this.end)
                return this.start;
            var p = U1.Vector3.Add(this.start, this.end);
            var mv = new U1.Vector3(p.X * 0.5, p.Y * 0.5, p.Z * 0.5);
            if (this.bulge == 0)
                return mv;
            this.center = U1.GeometryHelper3.GetArcCenter(this.start, this.end, this.up, this.bulge);
            return this.center;
        }
        ConvertFromStr(value) {
        }
        ConvertToStr() {
            return "";
        }
        CopyFrom(other) {
        }
        Equals(other) {
            return false;
        }
        Clone() {
            return this;
        }
    }
    U1.Arc3 = Arc3;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Rect {
        constructor(x = 0, y = 0, width = 0, height = 0) {
            this.X = 0;
            this.Y = 0;
            this.Width = 0;
            this.Height = 0;
            this.X = x;
            this.Y = y;
            this.Width = width;
            this.Height = height;
        }
        ConvertFrom(value) {
            if (value == null)
                return;
            var items = value.split(',')
                .map(o_ => {
                return parseFloat(o_);
            });
            var idx = -1;
            this.X = items.length > ++idx ? items[idx] : 0;
            this.Y = items.length > ++idx ? items[idx] : 0;
            this.Width = items.length > ++idx ? items[idx] : 0;
            this.Height = items.length > ++idx ? items[idx] : 0;
        }
        ConvertTo() {
            return "" + this.X + "," + this.Y + "," + this.Width + "," + this.Height;
        }
        static Equals(rect1, rect2) {
            if (rect1.IsZero) {
                return rect2.IsZero;
            }
            return rect1.X == rect2.X
                && rect1.Y == rect2.Y
                && rect1.Width == rect2.Width
                && rect1.Height == rect2.Height;
        }
        Equals(value) {
            return Rect.Equals(this, value);
        }
        toString() {
            return this.ConvertTo();
        }
        static get Zero() {
            return new Rect();
        }
        get IsZero() {
            return this.X == 0 && this.Y == 0 && this.Width == 0 && this.Height == 0;
        }
        get Location() {
            return new U1.Vector2(this.X, this.Y);
        }
        set Location(value) {
            this.X = value.X;
            this.Y = value.Y;
        }
        get Size() {
            if (this.IsZero) {
                return U1.Vector2.Zero;
            }
            return new U1.Vector2(this.Width, this.Height);
        }
        set Size(value) {
            if (value.IsZero) {
                this.X = 0;
                this.Y = 0;
                this.Width = 0;
                this.Height = 0;
            }
            else {
                this.Width = value.X;
                this.Height = value.Y;
            }
        }
        get Left() {
            return this.X;
        }
        get Top() {
            return this.Y;
        }
        get Right() {
            return (this.X + this.Width);
        }
        get Bottom() {
            return (this.Y + this.Height);
        }
        get TopLeft() {
            return new U1.Vector2(this.Left, this.Top);
        }
        get TopRight() {
            return new U1.Vector2(this.Right, this.Top);
        }
        get BottomLeft() {
            return new U1.Vector2(this.Left, this.Bottom);
        }
        get BottomRight() {
            return new U1.Vector2(this.Right, this.Bottom);
        }
        Contains2(x, y) {
            if (this.IsZero) {
                return false;
            }
            return this.ContainsInternal(x, y);
        }
        Contains3(rect) {
            if (this.IsZero || rect.IsZero) {
                return false;
            }
            return ((((this.X <= rect.X) && (this.Y <= rect.Y)) && ((this.X + this.Width) >= (rect.X + rect.Width))) && ((this.Y + this.Height) >= (rect.Y + rect.Height)));
        }
        IntersectsWith(rect) {
            if (this.IsZero || rect.IsZero) {
                return false;
            }
            return ((((rect.Left <= this.Right) && (rect.Right >= this.Left)) && (rect.Top <= this.Bottom)) && (rect.Bottom >= this.Top));
        }
        Intersect(rect) {
            if (!this.IntersectsWith(rect)) {
                this.X = 0;
                this.Y = 0;
                this.Width = 0;
                this.Height = 0;
            }
            else {
                var num = Math.max(this.Left, rect.Left);
                var num2 = Math.max(this.Top, rect.Top);
                this.Width = Math.max((Math.min(this.Right, rect.Right) - num), 0.0);
                this.Height = Math.max((Math.min(this.Bottom, rect.Bottom) - num2), 0.0);
                this.X = num;
                this.Y = num2;
            }
        }
        static Intersect2(rect1, rect2) {
            rect1 = new Rect(rect1.X, rect1.Y, rect1.Width, rect1.Height);
            rect1.Intersect(rect2);
            return rect1;
        }
        Union(rect) {
            if (this.IsZero) {
                this.X = 0;
                this.Y = 0;
                this.Width = 0;
                this.Height = 0;
            }
            else if (!rect.IsZero) {
                var num = Math.min(this.Left, rect.Left);
                var num2 = Math.min(this.Top, rect.Top);
                var num3 = Math.max(this.Right, rect.Right);
                this.Width = Math.max((num3 - num), 0.0);
                var num4 = Math.max(this.Bottom, rect.Bottom);
                this.Height = Math.max((num4 - num2), 0.0);
                this.X = num;
                this.Y = num2;
            }
        }
        static Union(rect1, rect2) {
            rect1 = new Rect(rect1.X, rect1.Y, rect1.Width, rect1.Height);
            rect1.Union(rect2);
            return rect1;
        }
        Offset(offsetVector) {
            this.X += offsetVector.X;
            this.Y += offsetVector.Y;
        }
        Offset2(offsetX, offsetY) {
            this.X += offsetX;
            this.Y += offsetY;
        }
        static Offset(rect1, offsetVector) {
            rect1 = new Rect(rect1.X, rect1.Y, rect1.Width, rect1.Height);
            rect1.Offset2(offsetVector.X, offsetVector.Y);
            return rect1;
        }
        Inflate(width, height) {
            this.X -= width;
            this.Y -= height;
            this.Width += width;
            this.Width += width;
            this.Height += height;
            this.Height += height;
            if ((this.Width < 0.0) || (this.Height < 0.0)) {
                this.X = this.Y = this.Width = this.Height = 0;
            }
        }
        Scale(scaleX, scaleY) {
            if (!this.IsZero) {
                this.X *= scaleX;
                this.Y *= scaleY;
                this.Width *= scaleX;
                this.Height *= scaleY;
                if (scaleX < 0.0) {
                    this.X += this.Width;
                    this.Width *= -1.0;
                }
                if (scaleY < 0.0) {
                    this.Y += this.Height;
                    this.Height *= -1.0;
                }
            }
        }
        ContainsInternal(x, y) {
            return ((((x >= this.X) && ((x - this.Width) <= this.X)) && (y >= this.Y)) && ((y - this.Height) <= this.Y));
        }
    }
    U1.Rect = Rect;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropertyBase {
        constructor(arg = null) {
            this._isVisible = true;
            this._childProps = new Array();
            this.PropertyChanged = new U1.PropertyChangedEvent();
            this._key = "" + UPropertyBase._key++;
            if (arg != null) {
                if (arg.Source != null)
                    this.Source = arg.Source;
                if (arg.SourceProperty != null)
                    this.SourceProperty = arg.SourceProperty;
                if (arg.Category != null)
                    this.Category = arg.Category;
                if (arg.Group != null)
                    this.Group = arg.Group;
                if (arg.Name != null)
                    this.Name = arg.Name;
                if (arg.Label != null)
                    this.Label = arg.Label;
                if (arg.ValueText != null)
                    this.ValueText = arg.ValueText;
                if (arg.IsEditable != null)
                    this.IsReadOnly = !arg.IsEditable;
                if (arg.DisposingAction != null)
                    this.DisposingAction = arg.DisposingAction;
                if (arg.IsVisible != null)
                    this.IsVisible = arg.IsVisible;
                if (arg.Tag != null)
                    this.Tag = arg.Tag;
                if (arg.Background != null)
                    this.Background = arg.Background;
                if (arg.GetIsVibible != null)
                    this.GetIsVibible = arg.GetIsVibible;
            }
        }
        get Key() {
            return this._key;
        }
        set Key(value) {
            this._key = value;
        }
        get Source() {
            return this._source;
        }
        set Source(value) {
            if (this._source === value)
                return;
            this.RemoveDocumentEventHandlers();
            this.RemoveSourceEventHandlers();
            this._source = value;
            this.AddSourceEventHandlers();
            this.AddDocumentEventHandlers();
        }
        get IsDisposed() {
            return this._isDisposed;
        }
        get SourceProperty() {
            return this._sourceProp;
        }
        set SourceProperty(value) {
            this._sourceProp = value;
        }
        get Category() {
            return this._category;
        }
        set Category(value) {
            this._category = value;
        }
        get Group() {
            return this._group;
        }
        set Group(value) {
            this._group = value;
        }
        get Name() {
            return this._name;
        }
        set Name(value) {
            this._name = value;
        }
        get Label() {
            return this._label || this._name;
        }
        set Label(value) {
            if (this._label === value)
                return;
            this._label = value;
            this.InvokePropertyChanged("Label");
        }
        get LabelColon() {
            return this.Label + ":";
        }
        get ValueText() {
            return this._valueText;
        }
        set ValueText(value) {
            this._valueText = value;
            this.InvokePropertyChanged("ValueText");
        }
        get IsReadOnly() {
            return this._isReadOnly;
        }
        set IsReadOnly(value) {
            if (this._isReadOnly === value)
                return;
            this._isReadOnly = value;
            this.InvokePropertyChanged("IsReadOnly");
        }
        get IsEditable() {
            return !this.IsReadOnly;
        }
        get IsVisible() {
            if (this.GetIsVibible != null)
                return this.GetIsVibible(this);
            return this._isVisible;
        }
        set IsVisible(value) {
            if (this._isVisible === value)
                return;
            this._isVisible = value;
            this.InvokePropertyChanged("IsVisible");
            this.InvokePropertyChanged("Visibility");
        }
        get Tag() {
            return this._tag;
        }
        set Tag(value) {
            this._tag = value;
            this.InvokePropertyChanged("Tag");
        }
        get ChildProperties() {
            return this._childProps;
        }
        get Background() {
            return this._backGround;
        }
        set Background(value) {
            this._backGround = value;
            this.InvokePropertyChanged("Background");
        }
        GetSourceAll(ctr) {
            var result = [];
            if (this.Source instanceof ctr) {
                result.push(this.Source);
            }
            for (var ch of this._childProps) {
                if (ch.Source instanceof ctr) {
                    result.push(ch.Source);
                }
            }
            return result;
        }
        AddChild(other) {
            if (other.constructor != this.constructor)
                return;
            this._childProps.push(other);
        }
        InvokeValueChanged() {
            this.InvokePropertyChanged("Value");
            this.InvokePropertyChanged("ValueText");
            this.InvokePropertyChanged("Visibility");
            this.InvokePropertyChanged("IsVisible");
        }
        InvokePropertyChanged(name = null) {
            if (name === null) {
                this.PropertyChanged.Invoke(this, "Value");
                this.PropertyChanged.Invoke(this, "ValueText");
                this.PropertyChanged.Invoke(this, "Label");
                return;
            }
            if (this.PropertyChanged != null)
                this.PropertyChanged.Invoke(this, name);
        }
        Dispose() {
            if (this._isDisposed)
                return;
            try {
                if (this.DisposingAction != null)
                    this.DisposingAction(this);
            }
            finally {
                this.DisposingAction = null;
            }
            this.RemoveDocumentEventHandlers();
            this.RemoveSourceEventHandlers();
            if (this._childProps != null) {
                for (var ch of this._childProps)
                    ch.Dispose();
            }
            try {
                this.OnDisposing();
            }
            catch (ex) {
            }
            finally {
                this._isDisposed = true;
            }
        }
        OnDisposing() {
        }
        AddSourceEventHandlers() {
            if (this._source instanceof U1.UElement) {
                this._document = this._source.Document;
                this._source.PropertyChanged.Add(this, this.OnPropertyChanged);
                this._source.Removing.Add(this, this.OnElementDisposing);
            }
            if (this._source != null && this._source.PropertyChanged != null) {
                this._source.PropertyChanged.Add(this, this.OnPropertyChanged);
            }
            if (this._source instanceof U1.UDocument)
                this._document = this._source;
        }
        OnPropertyChanged(sender, propName) {
            if (propName == this.Name ||
                propName == this.SourceProperty)
                this.InvokeValueChanged();
        }
        RemoveSourceEventHandlers() {
            if (this._source instanceof U1.UElement) {
                this._source.PropertyChanged.Remove(this, this.OnPropertyChanged);
                this._source.Removing.Remove(this, this.OnElementDisposing);
            }
            else if (this._source != null && this._source.PropertyChanged != null) {
                this._source.PropertyChanged.Remove(this, this.OnPropertyChanged);
            }
        }
        AddDocumentEventHandlers() {
            if (this._document != null) {
                this._document.AfterEndTransaction.Add(this, this.OnDocument_AfterEndTransaction);
                this._document.AfterUndoRedo.Add(this, this.OnDocument_AfterUndoRedo);
            }
        }
        RemoveDocumentEventHandlers() {
            if (this._document != null) {
                this._document.AfterEndTransaction.Remove(this, this.OnDocument_AfterEndTransaction);
                this._document.AfterUndoRedo.Remove(this, this.OnDocument_AfterUndoRedo);
            }
        }
        OnDocument_AfterUndoRedo(arg1, arg2) {
            this.InvokeValueChanged();
        }
        OnDocument_AfterEndTransaction(obj) {
            this.InvokeValueChanged();
        }
        OnElementDisposing(sender) {
            this.Dispose();
        }
    }
    UPropertyBase._key = 1;
    U1.UPropertyBase = UPropertyBase;
    class UProperty extends UPropertyBase {
        constructor(arg = null) {
            super(arg);
            if (arg != null) {
                if (arg.GetValueFunc != null)
                    this.GetValueFunc = arg.GetValueFunc;
                if (arg.SetValueFunc != null)
                    this.SetValueFunc = arg.SetValueFunc;
                if (arg.BeginChangeFunc != null)
                    this.BeginChangeFunc = arg.BeginChangeFunc;
                if (arg.EndChangeFunc != null)
                    this.EndChangeFunc = arg.EndChangeFunc;
            }
        }
        get ValueText() {
            return this._valueText;
        }
        set ValueText(value) {
            this.BeginTransaction();
            this._valueText = value;
            this.InvokePropertyChanged("ValueText");
            this.EndTransaction();
        }
        get TheValue() {
            return this.GetValueFunc != null ? this.GetValueFunc(this) : this._value;
        }
        set TheValue(value) {
            this._value = value;
            if (this.SetValueFunc != null)
                this.SetValueFunc(this, this._value);
        }
        get Value() {
            var value = this.TheValue;
            if (this._children != null)
                for (var ch of this._children) {
                    if (ch.TheValue == value)
                        return null;
                }
            return value;
        }
        set Value(value) {
            this.setValue(value);
        }
        setValue(value) {
            if (this._isDisposed || value == null)
                return;
            this.BeginTransaction();
            if (this._parent == null) {
                if (this.BeginChangeFunc != null)
                    this.BeginChangeFunc(this);
                if (this._children != null)
                    for (var ch of this._children) {
                        if (ch.BeginChangeFunc != null)
                            ch.BeginChangeFunc(this);
                    }
            }
            this.TheValue = value;
            if (this._children != null)
                for (var ch of this._children) {
                    ch.TheValue = value;
                }
            if (this._parent == null) {
                if (this.EndChangeFunc != null)
                    this.EndChangeFunc(this);
                if (this._children != null)
                    for (var ch of this._children) {
                        if (ch.EndChangeFunc != null)
                            ch.EndChangeFunc(this);
                    }
            }
            this.EndTransaction();
            this.InvokeValueChanged();
        }
        get Parent() {
            return this._parent;
        }
        get Children() {
            return this._children;
        }
        get IsReadOnly() {
            if (this.Children != null)
                for (var ch of this.Children)
                    if (this._isReadOnly != ch.IsReadOnly)
                        return true;
            return this._isReadOnly;
        }
        set IsReadOnly(value) {
            this._isReadOnly = value;
            this.InvokePropertyChanged("IsReadOnly");
        }
        AddChild(other) {
            super.AddChild(other);
            if (other.constructor != this.constructor)
                return;
            if (this._children == null)
                this._children = [];
            other._parent = this;
            this._children.push(other);
        }
        InvokeValueChanged() {
            super.InvokeValueChanged();
            if (this.Parent != null)
                this.Parent.InvokeValueChanged();
        }
        OnDisposing() {
            if (this.Parent != null && this.Parent.Children != null) {
                var idx = this.Parent._children.indexOf(this);
                this.Parent.Children.splice(idx, 1);
                this._parent = null;
            }
            if (this.Children != null) {
                var children = this._children.slice();
                for (var child of children) {
                    child.Dispose();
                }
                this._children = [];
            }
        }
        EndTransaction() {
            var document = this._document;
            if (this.Parent == null) {
                if (this.Source instanceof U1.UElement)
                    document = this.Source.Document;
                if (document == null)
                    document = this._document;
            }
            if (document != null)
                document.EndTransaction();
        }
        BeginTransaction() {
            var document = null;
            if (this.Parent == null) {
                if (this.Source instanceof U1.UElement)
                    document = this.Source.Document;
                if (document == null)
                    document = this._document;
            }
            if (document != null)
                document.BeginTransaction();
        }
    }
    U1.UProperty = UProperty;
    class UPropBool extends UProperty {
        constructor(arg = null) {
            super(arg);
        }
        get ValueText() {
            var value = this.Value;
            if (value == null)
                return "---";
            this._valueText = "" + value;
            return this._valueText;
        }
        set ValueText(value) {
            if (value == this._valueText)
                return;
            var val = value.toUpperCase() == "TRUE";
            this.Value = val;
        }
    }
    U1.UPropBool = UPropBool;
    class UPropString extends UProperty {
        constructor(arg = null) {
            super(arg);
            this._acceptsReturn = false;
        }
        get ValueText() {
            var value = this.Value;
            if (value == null)
                return "---";
            this._valueText = value;
            return this._valueText;
        }
        set ValueText(value) {
            if (this._valueText == value)
                return;
            if (value === "" || value == null) {
                this.InvokeValueChanged();
                return;
            }
            var d = value;
            this.Value = d;
        }
        get AcceptsReturn() {
            if (this.Children != null)
                for (var ch of this.Children)
                    if (this._acceptsReturn != ch.AcceptsReturn)
                        return false;
            return this._acceptsReturn;
        }
        set AcceptsReturn(value) {
            this._acceptsReturn = value;
            this.InvokePropertyChanged("AcceptsReturn");
        }
    }
    U1.UPropString = UPropString;
    class UPropDouble extends UProperty {
        constructor(arg = null) {
            super(arg);
            this.increment = 1;
            this.formatString = "0.000";
        }
        FromDisplay(str) {
            var dist = parseFloat(str);
            return dist;
        }
        ToDisplay(len) {
            if (this.formatString != null)
                return numeral(len).format(this.formatString);
            return numeral(len).format(this.formatString);
        }
        get FormatString() {
            return this.formatString;
        }
        set FormatString(value) {
            this.formatString = value;
        }
        get Increment() {
            return this.increment;
        }
        set Increment(value) {
            this.increment = value;
        }
        get Value() {
            var value = this.TheValue;
            var uivalue = this.ToDisplay(value);
            if (this._children != null)
                for (var ch of this._children) {
                    if (this.ToDisplay(ch.TheValue) != uivalue)
                        return null;
                }
            return value;
        }
        set Value(value) {
            if (isNaN(value))
                return;
            this.setValue(value);
        }
        get ValueText() {
            var value = this.Value;
            if (value == null)
                return "---";
            this._valueText = this.ToDisplay(value);
            return this._valueText;
        }
        set ValueText(value) {
            if (this._valueText == value)
                return;
            if (value === "" || value == null) {
                this.InvokeValueChanged();
                return;
            }
            var d = this.FromDisplay(value);
            this.Value = d;
        }
    }
    U1.UPropDouble = UPropDouble;
    class UPropInt extends UPropDouble {
        constructor(arg = null) {
            super(arg);
            this.formatString = "0";
        }
    }
    U1.UPropInt = UPropInt;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropAngle extends U1.UProperty {
        FromDisplay(strAngle) {
            var value = parseFloat(strAngle);
            if (isNaN(value))
                return value;
            return value;
        }
        ToDisplay(angle) {
            return `${angle.toPrecision(2)}`;
        }
        get Value() {
            var value = this.TheValue;
            var uivalue = this.ToDisplay(value);
            if (this._children != null)
                for (var ch of this._children) {
                    if (this.ToDisplay(ch.TheValue) != uivalue)
                        return null;
                }
            return value;
        }
        set Value(value) {
            super.setValue(value);
        }
        get ValueText() {
            var value = this.Value;
            if (isNaN(value) || value == null)
                return "---";
            this._valueText = this.ToDisplay(value);
            return this._valueText;
        }
        set ValueText(value) {
            if (this._valueText == value)
                return;
            var d = this.FromDisplay(value);
            if (isNaN(d))
                return;
            this.Value = d;
        }
        InvokeValueChanged() {
            super.InvokeValueChanged();
            this.InvokePropertyChanged("ValueText");
        }
    }
    U1.UPropAngle = UPropAngle;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropColor extends U1.UProperty {
        get ValueText() {
            this._valueText = `${this.RText},${this.GText},${this.BText}`;
            return this._valueText;
        }
        set ValueText(value) {
            if (this._valueText === value)
                return;
            var tkns = value.split(',');
            if (tkns.length == 3) {
                this.BeginTransaction();
                this.RText = tkns[0];
                this.GText = tkns[1];
                this.BText = tkns[2];
                this.EndTransaction();
            }
        }
        get RText() {
            return this.GetText("R");
        }
        set RText(value) {
            this.BeginTransaction();
            this.SetText("R", value);
            this.EndTransaction();
        }
        get GText() {
            return this.GetText("G");
        }
        set GText(value) {
            this.BeginTransaction();
            this.SetText("G", value);
            this.EndTransaction();
        }
        get BText() {
            return this.GetText("B");
        }
        set BText(value) {
            this.BeginTransaction();
            this.SetText("B", value);
            this.EndTransaction();
        }
        GetText(name) {
            var value;
            if (name == "R")
                value = this.R;
            else if (name == "G")
                value = this.G;
            else if (name == "B")
                value = this.B;
            else
                return null;
            return value == null ? "---" : U1.UPropertyService.DistToString(value);
        }
        SetText(name, valstr) {
            var value = U1.UPropertyService.DistFromUIString(valstr);
            if (isNaN(value))
                return;
            this.SetProperty(name, value);
        }
        GetProperty(name) {
            var result;
            if (name == "R")
                result = this.TheValue.R;
            else if (name == "G")
                result = this.TheValue.G;
            else if (name == "B")
                result = this.TheValue.B;
            else
                return null;
            if (this.Children != null) {
                for (var ch of this.Children) {
                    if (result != ch.GetProperty(name))
                        return null;
                }
            }
            return result;
        }
        SetProperty(name, value) {
            var theValue = this.TheValue.Clone();
            if (name == "R")
                theValue.R = value;
            else if (name == "G")
                theValue.G = value;
            else if (name == "B")
                theValue.B = value;
            else
                return;
            this.TheValue = theValue;
            if (this.Children != null) {
                for (var ch of this.Children) {
                    ch.SetProperty(name, value);
                }
            }
        }
        get R() {
            return this.GetProperty("R");
        }
        set R(value) {
            if (value == null)
                return;
            this.BeginTransaction();
            this.SetProperty("R", value);
            this.EndTransaction();
        }
        get G() {
            return this.GetProperty("G");
        }
        set G(value) {
            if (value == null)
                return;
            this.BeginTransaction();
            this.SetProperty("G", value);
            this.EndTransaction();
        }
        get B() {
            return this.GetProperty("B");
        }
        set B(value) {
            if (value == null)
                return;
            this.BeginTransaction();
            this.SetProperty("B", value);
            this.EndTransaction();
        }
        InvokeValueChanged() {
            super.InvokeValueChanged();
            this.InvokePropertyChanged("R");
            this.InvokePropertyChanged("G");
            this.InvokePropertyChanged("B");
            this.InvokePropertyChanged("XText");
            this.InvokePropertyChanged("YText");
            this.InvokePropertyChanged("ZText");
        }
    }
    U1.UPropColor = UPropColor;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropertyService {
        static get DistToString() {
            if (UPropertyService.distToString == null) {
                UPropertyService.distToString = (dist_) => {
                    return dist_.toPrecision(4);
                };
            }
            return UPropertyService.distToString;
        }
        set DistToString(value) {
            UPropertyService.distToString = value;
        }
        static get DistFromUIString() {
            if (UPropertyService.distFromUIString == null)
                UPropertyService.distFromUIString = UPropertyService.DefDistFromUIString;
            return UPropertyService.distFromUIString;
        }
        static DefDistFromUIString(usString) {
            var sb = "";
            for (var i = 0; i < usString.length; i++) {
                var c = usString.charAt(i);
                if (c == '.' ||
                    c == '-' ||
                    c == 'E' ||
                    c == 'e' ||
                    (c >= '0' && c <= '9')) {
                    sb += c;
                }
            }
            return parseFloat(sb);
        }
    }
    U1.UPropertyService = UPropertyService;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropVect2 extends U1.UProperty {
        constructor() {
            super();
        }
        get ValueText() {
            this._valueText = `${this.XText},${this.YText}`;
            return this._valueText;
        }
        set ValueText(value) {
            if (this._valueText == value)
                return;
            var tkns = value.split(',');
            if (tkns.length == 2) {
                this.BeginTransaction();
                this.XText = tkns[0];
                this.YText = tkns[1];
                this.EndTransaction();
            }
        }
        get XText() {
            return this.GetText("X");
        }
        set XText(value) {
            this.BeginTransaction();
            this.SetText("X", value);
            this.EndTransaction();
        }
        get YText() {
            return this.GetText("Y");
        }
        set YText(value) {
            this.BeginTransaction();
            this.SetText("Y", value);
            this.EndTransaction();
        }
        GetText(name) {
            var value;
            if (name == "X")
                value = this.X;
            else if (name == "Y")
                value = this.Y;
            else
                return null;
            return value == null ? "---" : U1.UPropertyService.DistToString(value);
        }
        SetText(name, valstr) {
            var value = U1.UPropertyService.DistFromUIString(valstr);
            if (isNaN(value))
                return;
            this.SetProperty(name, value);
        }
        GetProperty(name) {
            var result;
            if (name == "X")
                result = this.TheValue.X;
            else if (name == "Y")
                result = this.TheValue.Y;
            else
                return null;
            if (this.Children != null) {
                for (var ch of this.Children) {
                    if (result != ch.GetProperty(name))
                        return null;
                }
            }
            return result;
        }
        SetProperty(name, value) {
            var theValue = this.TheValue.Clone();
            if (name == "X")
                theValue.X = value;
            else if (name == "Y")
                theValue.Y = value;
            else
                return;
            this.TheValue = theValue;
            if (this.Children != null)
                for (var ch of this.Children) {
                    ch.SetProperty(name, value);
                }
        }
        get X() {
            return this.GetProperty("X");
        }
        set X(value) {
            if (value == null)
                return;
            this.BeginTransaction();
            this.SetProperty("X", value);
            this.EndTransaction();
        }
        get Y() {
            return this.GetProperty("Y");
        }
        set Y(value) {
            if (value == null)
                return;
            this.BeginTransaction();
            this.SetProperty("Y", value);
            this.EndTransaction();
        }
        InvokeValueChanged() {
            super.InvokeValueChanged();
            this.InvokePropertyChanged("X");
            this.InvokePropertyChanged("Y");
            this.InvokePropertyChanged("XText");
            this.InvokePropertyChanged("YText");
        }
    }
    U1.UPropVect2 = UPropVect2;
    class UPropLoc2 extends UPropVect2 {
    }
    U1.UPropLoc2 = UPropLoc2;
    class UPropScale2 extends UPropVect2 {
    }
    U1.UPropScale2 = UPropScale2;
    class UPropSize2 extends UPropVect2 {
    }
    U1.UPropSize2 = UPropSize2;
    class UPropVect2CustomUI extends UPropVect2 {
        get UIElement() {
            if (this._uiElement == null && this.CreateUI != null) {
                this._uiElement = this.CreateUI(this);
            }
            return this._uiElement;
        }
    }
    U1.UPropVect2CustomUI = UPropVect2CustomUI;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropVect3 extends U1.UProperty {
        get ValueText() {
            this._valueText = `${this.XText},${this.YText},${this.ZText}`;
            return this._valueText;
        }
        set ValueText(value) {
            if (this._valueText === value)
                return;
            var tkns = value.split(',');
            if (tkns.length == 3) {
                this.BeginTransaction();
                this.XText = tkns[0];
                this.YText = tkns[1];
                this.ZText = tkns[2];
                this.EndTransaction();
            }
        }
        get XText() {
            return this.GetText("X");
        }
        set XText(value) {
            this.BeginTransaction();
            this.SetText("X", value);
            this.EndTransaction();
        }
        get YText() {
            return this.GetText("Y");
        }
        set YText(value) {
            this.BeginTransaction();
            this.SetText("Y", value);
            this.EndTransaction();
        }
        get ZText() {
            return this.GetText("Z");
        }
        set ZText(value) {
            this.BeginTransaction();
            this.SetText("Z", value);
            this.EndTransaction();
        }
        GetText(name) {
            var value;
            if (name == "X")
                value = this.X;
            else if (name == "Y")
                value = this.Y;
            else if (name == "Z")
                value = this.Z;
            else
                return null;
            return value == null ? "---" : U1.UPropertyService.DistToString(value);
        }
        SetText(name, valstr) {
            var value = U1.UPropertyService.DistFromUIString(valstr);
            if (isNaN(value))
                return;
            this.SetProperty(name, value);
        }
        GetProperty(name) {
            var result;
            if (name == "X")
                result = this.TheValue.X;
            else if (name == "Y")
                result = this.TheValue.Y;
            else if (name == "Z")
                result = this.TheValue.Z;
            else
                return null;
            if (this.Children != null) {
                for (var ch of this.Children) {
                    if (result != ch.GetProperty(name))
                        return null;
                }
            }
            return result;
        }
        SetProperty(name, value) {
            var theValue = this.TheValue.Clone();
            if (name == "X")
                theValue.X = value;
            else if (name == "Y")
                theValue.Y = value;
            else if (name == "Z")
                theValue.Z = value;
            else
                return;
            this.TheValue = theValue;
            if (this.Children != null) {
                for (var ch of this.Children) {
                    ch.SetProperty(name, value);
                }
            }
        }
        get X() {
            return this.GetProperty("X");
        }
        set X(value) {
            if (value == null)
                return;
            this.BeginTransaction();
            this.SetProperty("X", value);
            this.EndTransaction();
        }
        get Y() {
            return this.GetProperty("Y");
        }
        set Y(value) {
            if (value == null)
                return;
            this.BeginTransaction();
            this.SetProperty("Y", value);
            this.EndTransaction();
        }
        get Z() {
            return this.GetProperty("Z");
        }
        set Z(value) {
            if (value == null)
                return;
            this.BeginTransaction();
            this.SetProperty("Z", value);
            this.EndTransaction();
        }
        InvokeValueChanged() {
            super.InvokeValueChanged();
            this.InvokePropertyChanged("X");
            this.InvokePropertyChanged("Y");
            this.InvokePropertyChanged("Z");
            this.InvokePropertyChanged("XText");
            this.InvokePropertyChanged("YText");
            this.InvokePropertyChanged("ZText");
        }
    }
    U1.UPropVect3 = UPropVect3;
    class UPropLoc3 extends UPropVect3 {
    }
    U1.UPropLoc3 = UPropLoc3;
    class UPropScale3 extends UPropVect3 {
    }
    U1.UPropScale3 = UPropScale3;
    class UPropSize3 extends UPropVect3 {
    }
    U1.UPropSize3 = UPropSize3;
    class UPropVect3CustomUI extends UPropVect3 {
        get UIElement() {
            if (this._uiElement == null && this.CreateUI != null) {
                this._uiElement = this.CreateUI(this);
            }
            return this._uiElement;
        }
    }
    U1.UPropVect3CustomUI = UPropVect3CustomUI;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GeText extends Geoms.GeEntity {
            constructor() {
                super(...arguments);
                this.FontSize = 1;
                this.FontStyle = Geoms.FontStyleEnum.Normal;
                this.FontWeight = Geoms.FontWeightEnum.Normal;
                this.FontFamily = "Arial";
                this.TextAlignment = Geoms.TextAlignmentEnum.Left;
                this.Width = 10;
                this.WidthFactor = 1;
                this.Height = 1;
                this.IsSingleLine = true;
                this.Position = U1.Vector3.Zero;
            }
            Max(result) {
                result = result || new U1.Vector3();
                return result.Set(this.Width, this.Height, 0.1).Add(this.Position);
            }
            Min(result) {
                result = result || new U1.Vector3();
                return result.Set(-this.Width, -this.Height, 0.1).Add(this.Position);
            }
        }
        Geoms.GeText = GeText;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Geoms;
    (function (Geoms) {
        class GeTriFace extends Geoms.GeEntity {
            constructor() {
                super(...arguments);
                this._points = new U1.Vector3[3];
                this.E1 = Geoms.EdgeTypeEnum.Solid;
                this.E2 = Geoms.EdgeTypeEnum.Solid;
                this.E3 = Geoms.EdgeTypeEnum.Solid;
                this.IsFilled = true;
            }
            Min(result) {
                result = result || new U1.Vector3();
                result.SetMaxValue();
                return result.Minimize(this._points);
            }
            Max(result) {
                result = result || new U1.Vector3();
                result.SetMinValue();
                return result.Maximize(this._points);
            }
            get P1() {
                return this._points[0];
            }
            set P1(value) {
                this._points[0] = value;
                this.Points = this._points;
            }
            get P2() {
                return this._points[1];
            }
            set P2(value) {
                this._points[1] = value;
                this.Points = this._points;
            }
            get P3() {
                return this._points[2];
            }
            set P3(value) {
                this._points[2] = value;
                this.Points = this._points;
            }
            get Points() {
                return this._points;
            }
            set Points(value) {
                this._points = value;
            }
            GetNormal(result) {
                result = result || new U1.Vector3();
                var v1 = U1.Vector3.Subtract(this.P2, this.P1);
                var v2 = U1.Vector3.Subtract(this.P3, this.P1);
                return result.SetCross(v1, v2).Normalize();
            }
        }
        Geoms.GeTriFace = GeTriFace;
    })(Geoms = U1.Geoms || (U1.Geoms = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    let ArcCrossStates;
    (function (ArcCrossStates) {
        ArcCrossStates[ArcCrossStates["None"] = 0] = "None";
        ArcCrossStates[ArcCrossStates["SameLine"] = 1] = "SameLine";
        ArcCrossStates[ArcCrossStates["FirstOnly"] = 2] = "FirstOnly";
        ArcCrossStates[ArcCrossStates["SecondOnly"] = 3] = "SecondOnly";
        ArcCrossStates[ArcCrossStates["Both"] = 4] = "Both";
        ArcCrossStates[ArcCrossStates["RemoveFirst"] = 5] = "RemoveFirst";
    })(ArcCrossStates = U1.ArcCrossStates || (U1.ArcCrossStates = {}));
    class Arc2 {
        constructor(start, end, bulge) {
            this._start = new U1.Vector2();
            this._end = new U1.Vector2();
            this._center = new U1.Vector2();
            this._bulge = 0;
            this._isCenterDirty = true;
            if (start instanceof Arc2) {
                this.CopyFrom(start);
            }
            else if (start instanceof U1.Vector2) {
                this._start.CopyFrom(start);
                if (end != null)
                    this._end.CopyFrom(end);
                if (bulge != null)
                    this._bulge = bulge;
                this._isCenterDirty = true;
            }
        }
        ConvertFromStr(value) {
            var items = U1.UValueUtil.ConvertNumberArrFromString(value);
            var idx = 0;
            this._start.X = items.length > idx ? items[idx++] : 0;
            this._start.Y = items.length > idx ? items[idx++] : 0;
            this._end.X = items.length > idx ? items[idx++] : 0;
            this._end.Y = items.length > idx ? items[idx++] : 0;
            this._bulge = items.length > idx ? items[idx++] : 0;
        }
        ConvertToStr() {
            return U1.UValueUtil.ConvertNumberArrToString(this._start.X, this._start.Y, this._end.X, this._end.Y, this._bulge);
        }
        CopyFrom(other) {
            this._start.CopyFrom(other.Start);
            this._end.CopyFrom(other.End);
            this._bulge = other._bulge;
            return this;
        }
        Clone() {
            var arc = new Arc2(this);
            return arc;
        }
        Equals(other) {
            return this.Start.Equals(other.Start) &&
                this.End.Equals(other.End) &&
                this.Bulge == other.Bulge;
        }
        toString() {
            return `(${this._start.X},${this._start.Y},${this._end.X},${this._end.Y},${this._bulge})`;
        }
        static get Zero() {
            return new Arc2();
        }
        get Start() { return this._start; }
        set Start(value) {
            this._isCenterDirty = true;
            this._start.CopyFrom(value);
        }
        get End() { return this._end; }
        set End(value) {
            this._isCenterDirty = true;
            this._end.CopyFrom(value);
        }
        get Bulge() {
            return this._bulge;
        }
        set Bulge(value) {
            this._isCenterDirty = true;
            this._bulge = value;
        }
        get Radius() {
            if (this.Bulge == 0)
                return 0;
            var result = U1.Vector2.Distance(this.Center, this.Start);
            return result;
        }
        get Angle() {
            var vect0 = Arc2[".ang.v0"] || (Arc2[".ang.v0"] = new U1.Vector2());
            var vect1 = Arc2[".ang.v1"] || (Arc2[".ang.v1"] = new U1.Vector2());
            var cent = this.Center;
            vect0.SetSubtract(this.Start, cent);
            vect1.SetSubtract(this.End, cent);
            return U1.GeometryHelper2.AngleBetween(vect0, vect1);
        }
        get Center() {
            return this.GetCenter();
        }
        Direction(result) {
            if (result == null)
                result = new U1.Vector2();
            return result.SetSubtract(this._end, this._start).Normalize();
        }
        Right(result) {
            if (result == null)
                result = new U1.Vector2();
            var dir = this.Direction(result);
            dir.Set(dir.Y, -dir.X);
            return dir;
        }
        get Length() {
            if (this.Bulge == 0)
                return U1.Vector2.Distance(this.End, this.Start);
            var vect0 = Arc2[".len.v0"] || (Arc2[".len.v0"] = new U1.Vector2());
            var vect1 = Arc2[".len.v1"] || (Arc2[".len.v1"] = new U1.Vector2());
            vect0.SetSubtract(this.Start, this.Center);
            vect1.SetSubtract(this.End, this.Center);
            var ea = U1.GeometryHelper2.AngleCCW(vect0, vect1);
            if (this.Bulge < 0)
                return (Math.PI * 2 - ea) * this.Radius;
            return ea * this.Radius;
        }
        static ExtendArc(arc0, arc1) {
            if (arc0.Start.Equals(arc0.End))
                return false;
            if (arc1.Start.Equals(arc1.End))
                return false;
            if (arc0.Bulge == 0) {
                if (arc1.Bulge == 0) {
                    return Arc2.ExtendArc_LineLine(arc0, arc1);
                }
                else {
                    return Arc2.ExtendArc_LineArc(arc0, arc1);
                }
            }
            else {
                if (arc1.Bulge == 0) {
                    return Arc2.ExtendArc_ArcLine(arc0, arc1);
                }
                else {
                    return Arc2.ExtendArc_ArcArc(arc0, arc1);
                }
            }
        }
        static ExtendArc_LineLine(arc0, arc1) {
            var dir0 = Arc2[".exar.v0"] || (Arc2[".exar.v0"] = new U1.Vector2());
            var dir1 = Arc2[".exar.v1"] || (Arc2[".exar.v1"] = new U1.Vector2());
            var crv = Arc2[".exar.v2"] || (Arc2[".exar.v2"] = new U1.Vector2());
            var line0 = Arc2[".exar.l0"] || (Arc2[".exar.l0"] = new U1.Line2());
            var line1 = Arc2[".exar.l1"] || (Arc2[".exar.l1"] = new U1.Line2());
            dir0.SetSubtract(arc0.End, arc0.Start);
            dir1.SetSubtract(arc1.End, arc1.Start);
            line0.Position.CopyFrom(arc0.Start);
            line0.Direction.CopyFrom(dir0);
            line1.Position.CopyFrom(arc1.Start);
            line1.Direction.CopyFrom(dir1);
            if (U1.GeometryHelper2.CrossLineLine1(line0, line1, crv) == null)
                return false;
            arc0.End = crv;
            arc1.Start = crv;
        }
        static ExtendArc_LineArc(arc0, arc1) {
            var tv1 = Arc2[".exar.v0"] || (Arc2[".exar.v0"] = new U1.Vector2());
            var tv2 = Arc2[".exar.v1"] || (Arc2[".exar.v1"] = new U1.Vector2());
            var line0 = Arc2[".exar.l0"] || (Arc2[".exar.l0"] = new U1.Line2());
            var circle0 = Arc2[".exar.c0"] || (Arc2[".exar.c0"] = new U1.Circle2());
            var c = arc1.Center;
            var r = arc1.Radius;
            circle0.Center.CopyFrom(c);
            circle0.Radius = r;
            line0.Position.CopyFrom(arc0.Start);
            line0.Direction.SetSubtract(arc0.End, arc0.Start);
            var ps = U1.GeometryHelper2.CrossLineCircle(line0, circle0);
            if (ps == null)
                return false;
            var p, p1;
            p = p1 = ps[0];
            if (ps.length > 1)
                p1 = ps[1];
            var v1 = tv1.SetSubtract(p, arc0.End);
            var v2 = tv2.SetSubtract(p1, arc0.End);
            if (v1.Length() > v2.Length())
                p = p1;
            arc0.End = p;
            arc1.Start = p;
            var b = Arc2.CalNewBulge(arc1.Start, arc1.End, c, r, arc1.Bulge);
            arc1.Bulge = b;
            return true;
        }
        static ExtendArc_ArcLine(arc0, arc1) {
            var tv0 = Arc2[".exar.v0"] || (Arc2[".exar.v0"] = new U1.Vector2());
            var tv1 = Arc2[".exar.v1"] || (Arc2[".exar.v1"] = new U1.Vector2());
            var line0 = Arc2[".exar.l0"] || (Arc2[".exar.l0"] = new U1.Line2());
            var circle0 = Arc2[".exar.c0"] || (Arc2[".exar.c0"] = new U1.Circle2());
            var c = arc0.Center;
            var r = arc0.Radius;
            circle0.Center.CopyFrom(c);
            circle0.Radius = r;
            line0.Position.CopyFrom(arc1.Start);
            line0.Direction.SetSubtract(arc1.End, arc1.Start);
            var ps = U1.GeometryHelper2.CrossLineCircle(line0, circle0);
            if (ps == null)
                return false;
            var p, p1;
            p = p1 = ps[0];
            if (ps.length > 1)
                p1 = ps[1];
            var v1 = tv0.SetSubtract(p, arc0.End);
            var v2 = tv1.SetSubtract(p1, arc0.End);
            if (v1.Length() > v2.Length())
                p = p1;
            arc0.End = p;
            arc1.Start = p;
            var b = Arc2.CalNewBulge(arc0.Start, arc0.End, c, r, arc0.Bulge);
            arc0.Bulge = b;
            return true;
        }
        static ExtendArc_ArcArc(arc0, arc1) {
            var tv1 = Arc2[".exar.v0"] || (Arc2[".exar.v0"] = new U1.Vector2());
            var tv2 = Arc2[".exar.v1"] || (Arc2[".exar.v1"] = new U1.Vector2());
            var circle0 = Arc2[".exar.c0"] || (Arc2[".exar.c0"] = new U1.Circle2());
            var circle1 = Arc2[".exar.c1"] || (Arc2[".exar.c1"] = new U1.Circle2());
            var c0 = arc0.Center;
            var r0 = arc0.Radius;
            var c1 = arc1.Center;
            var r1 = arc1.Radius;
            circle0.Center.CopyFrom(c0);
            circle0.Radius = r0;
            circle1.Center.CopyFrom(c1);
            circle1.Radius = r1;
            var ps = U1.GeometryHelper2.CrossCircleCircle(circle0, circle1);
            if (ps == null)
                return false;
            var p = ps[0];
            var p2 = ps[0];
            if (ps.length > 1)
                p2 = ps[1];
            var v1 = tv1.SetSubtract(p, arc0.End);
            var v2 = tv2.SetSubtract(p2, arc0.End);
            if (v1.Length() > v2.Length())
                p = p2;
            arc0.End = p;
            arc1.Start = p;
            var b = Arc2.CalNewBulge(arc0.Start, arc0.End, c0, r0, arc0.Bulge);
            arc0.Bulge = b;
            b = Arc2.CalNewBulge(arc1.Start, arc1.End, c1, r1, arc1.Bulge);
            arc1.Bulge = b;
            return true;
        }
        static TrimA(A, B) {
            if (A.Start == A.End)
                return false;
            if (B.Start == B.End)
                return false;
            let crosspos = null;
            if (A.Bulge == 0) {
                if (B.Bulge == 0) {
                    var dir0 = U1.Vector2.Subtract(A.End, A.Start);
                    var dir1 = U1.Vector2.Subtract(B.End, B.Start);
                    var line0 = new U1.Line2(A.Start, dir0);
                    var line1 = new U1.Line2(B.Start, dir1);
                    let crossv;
                    if (!U1.GeometryHelper2.CrossLineLine1(line0, line1, crossv))
                        return false;
                    if (!A.IsOver(crossv))
                        return false;
                    A.End = crossv;
                    return true;
                }
                else {
                    var c = B.Center;
                    var r = B.Radius;
                    var line = new U1.Line2(A.Start, U1.Vector2.Subtract(A.End, A.Start));
                    crosspos = U1.GeometryHelper2.CrossLineCircle(line, new U1.Circle2(c, r));
                    if (crosspos == null)
                        return false;
                    crosspos = crosspos.filter(o_ => A.IsOver(o_))
                        .OrderBy(o_ => U1.Vector2.Distance(o_, A.Start));
                }
            }
            else {
                if (B.Bulge == 0) {
                    var c = A.Center;
                    var r = A.Radius;
                    var line = new U1.Line2(B.Start, U1.Vector2.Subtract(B.End, B.Start));
                    crosspos = U1.GeometryHelper2.CrossLineCircle(line, new U1.Circle2(c, r));
                    if (crosspos == null)
                        return false;
                    crosspos = crosspos.filter(o_ => A.IsOver(o_))
                        .OrderBy(o_ => U1.Vector2.Distance(o_, A.Start));
                }
                else {
                    var c0 = A.Center;
                    var r0 = A.Radius;
                    var c1 = B.Center;
                    var r1 = B.Radius;
                    crosspos = U1.GeometryHelper2.CrossCircleCircle(new U1.Circle2(c0, r0), new U1.Circle2(c1, r1));
                    if (crosspos == null)
                        return false;
                    crosspos = crosspos.filter(o_ => A.IsOver(o_))
                        .OrderBy(o_ => U1.Vector2.Distance(o_, A.Start));
                }
            }
            if (crosspos == null || crosspos.length == 0)
                return false;
            if (A.Bulge != 0) {
                var c = A.Center;
                var r = A.Radius;
                var b = Arc2.CalNewBulge(A.Start, crosspos[0], c, r, A.Bulge);
                A.Bulge = b;
            }
            A.End = crosspos[0];
            return true;
        }
        static CrossArc(arc0, arc1, newArc0s, newArc1s) {
            if (arc0.Bulge == 0 && arc1.Bulge == 0) {
                return Arc2.CrossArc_LineLine(arc0, arc1, newArc0s, newArc1s);
            }
            else if (arc0.Bulge == 0) {
                return Arc2.CrossArc_LineArc(arc0, arc1, newArc0s, newArc1s);
            }
            else if (arc1.Bulge == 0) {
                var csate = Arc2.CrossArc(arc1, arc0, newArc1s, newArc0s);
                if (csate == ArcCrossStates.FirstOnly)
                    csate = ArcCrossStates.SecondOnly;
                else if (csate == ArcCrossStates.SecondOnly)
                    csate = ArcCrossStates.FirstOnly;
                return csate;
            }
            else {
                return Arc2.CrossArc_ArcArc(arc0, arc1, newArc0s, newArc1s);
            }
        }
        static CrossArc_LineLine(arc0, arc1, newArc0s, newArc1s) {
            var seg0 = Arc2[".cra.s0"] || (Arc2[".cra.s0"] = new U1.Segment2());
            var seg1 = Arc2[".cra.s1"] || (Arc2[".cra.s1"] = new U1.Segment2());
            var tv0 = Arc2[".cra.v0"] || (Arc2[".cra.v0"] = new U1.Vector2());
            var tv1 = Arc2[".cra.v1"] || (Arc2[".cra.v1"] = new U1.Vector2());
            var tv2 = Arc2[".cra.v2"] || (Arc2[".cra.v2"] = new U1.Vector2());
            var tv3 = Arc2[".cra.v3"] || (Arc2[".cra.v3"] = new U1.Vector2());
            var tv4 = Arc2[".cra.v4"] || (Arc2[".cra.v4"] = new U1.Vector2());
            var tv5 = Arc2[".cra.v5"] || (Arc2[".cra.v5"] = new U1.Vector2());
            if ((U1.GeometryHelper2.IsSame(arc0.Start, arc1.Start) && U1.GeometryHelper2.IsSame(arc0.End, arc1.End)) ||
                (U1.GeometryHelper2.IsSame(arc0.Start, arc1.End) && U1.GeometryHelper2.IsSame(arc0.End, arc1.Start))) {
                return ArcCrossStates.SameLine;
            }
            seg0.Start.CopyFrom(arc0.Start);
            seg0.End.CopyFrom(arc0.End);
            seg1.Start.CopyFrom(arc1.Start);
            seg1.End.CopyFrom(arc1.End);
            var crossVs = U1.GeometryHelper2.CrossSegmentSegment(seg0, seg1);
            if (crossVs == null)
                return ArcCrossStates.None;
            if (crossVs.length == 1) {
                var p = crossVs[0];
                if ((p == arc0.Start || p == arc0.End) && (p == arc1.Start || p == arc1.End)) {
                    return ArcCrossStates.None;
                }
                var nArc0 = new Arc2(arc0);
                var nArc1 = new Arc2(arc0);
                nArc0._end = p;
                nArc1._start = p;
                newArc0s.push(nArc0);
                newArc0s.push(nArc1);
                nArc0 = new Arc2(arc1);
                nArc1 = new Arc2(arc1);
                nArc0._end = p;
                nArc1._start = p;
                newArc1s.push(nArc0);
                newArc1s.push(nArc1);
                if (p == arc0.Start || p == arc0.End) {
                    return ArcCrossStates.SecondOnly;
                }
                if (p == arc1.Start || p == arc1.End) {
                    return ArcCrossStates.FirstOnly;
                }
                return ArcCrossStates.Both;
            }
            if (crossVs.length == 2) {
                var p0 = crossVs[0];
                var p1 = crossVs[1];
                var d0 = tv0.SetSubtract(arc0.End, arc0.Start);
                var l0 = d0.Length();
                var d1 = tv1.SetSubtract(arc1.End, arc1.Start);
                var l1 = d1.Length();
                var s0, s1;
                var sp0, sp1;
                sp0 = tv2.CopyFrom(p0);
                sp1 = tv3.CopyFrom(p1);
                s0 = U1.Vector2.Dot(d0, tv4.SetSubtract(p0, arc0.Start));
                s1 = U1.Vector2.Dot(d0, tv5.SetSubtract(p1, arc0.Start));
                if (s0 > s1) {
                    var tmp = s0;
                    s0 = s1;
                    s1 = tmp;
                    sp0 = p1;
                    sp1 = p0;
                }
                var t0, t1;
                var tp0, tp1;
                tp0 = p0;
                tp1 = p1;
                t0 = U1.Vector2.Dot(d1, tv4.SetSubtract(p0, arc1.Start));
                t1 = U1.Vector2.Dot(d1, tv5.SetSubtract(p1, arc1.Start));
                if (t0 > t1) {
                    var tmp = t0;
                    t0 = t1;
                    t1 = tmp;
                    tp0 = p1;
                    tp1 = p0;
                }
                if (s0 == 0 && s1 == 1 && t0 == 0 && t1 == 1)
                    return ArcCrossStates.SameLine;
                var Vs0 = [arc0._start, sp0, sp1, arc0._end];
                var Vs1 = [arc1._start, tp0, tp1, arc1._end];
                for (var cnt = 0; cnt < 3; cnt++) {
                    if (!Vs0[cnt].Equals(Vs0[cnt + 1])) {
                        var nArc0 = new Arc2(arc0);
                        nArc0._start = Vs0[cnt];
                        nArc0._end = Vs0[cnt + 1];
                        newArc1s.push(nArc0);
                    }
                }
                for (var cnt = 0; cnt < 3; cnt++) {
                    var sv = Vs1[cnt];
                    var ev = Vs1[cnt + 1];
                    if (sv.Equals(ev))
                        continue;
                    var goto_next = false;
                    for (var tc = 0; tc < newArc1s.length; tc++) {
                        var tsv = newArc1s[tc].Start;
                        var tev = newArc1s[tc].End;
                        if ((tsv.Equals(sv) && tev.Equals(ev)) || (tsv.Equals(ev) && tev.Equals(sv))) {
                            goto_next = true;
                            break;
                        }
                    }
                    if (!goto_next) {
                        var nArc1 = new Arc2(arc1);
                        nArc1.Start = sv;
                        nArc1.End = ev;
                        newArc1s.push(nArc1);
                    }
                }
                return ArcCrossStates.Both;
            }
            return ArcCrossStates.None;
        }
        static CrossArc_LineArc(arc0, arc1, newArc0s, newArc1s) {
            var seg0 = Arc2[".cra.s0"] || (Arc2[".cra.s0"] = new U1.Segment2());
            var seg1 = Arc2[".cra.s1"] || (Arc2[".cra.s1"] = new U1.Segment2());
            var tv0 = Arc2[".cra.v0"] || (Arc2[".cra.v0"] = new U1.Vector2());
            var tv1 = Arc2[".cra.v1"] || (Arc2[".cra.v1"] = new U1.Vector2());
            var tv2 = Arc2[".cra.v2"] || (Arc2[".cra.v2"] = new U1.Vector2());
            var tv3 = Arc2[".cra.v3"] || (Arc2[".cra.v3"] = new U1.Vector2());
            var tv4 = Arc2[".cra.v4"] || (Arc2[".cra.v4"] = new U1.Vector2());
            var tv5 = Arc2[".cra.v5"] || (Arc2[".cra.v5"] = new U1.Vector2());
            if (arc0.Start.Equals(arc1.Start) && arc0.End.Equals(arc1.End))
                return ArcCrossStates.None;
            if (arc0.End.Equals(arc1.End) && arc0.End.Equals(arc1.Start))
                return ArcCrossStates.None;
            seg0.Start.CopyFrom(arc0.Start);
            seg0.End.CopyFrom(arc0.End);
            var ps = U1.GeometryHelper2.CrossSegmentArc(seg0, arc1);
            if (ps == null)
                return ArcCrossStates.None;
            if (ps.length == 1) {
                var p0 = ps[0];
                var fs0, fe0, fs1, fe1;
                fs0 = (p0.Equals(arc0.Start));
                fe0 = (p0.Equals(arc0.End));
                fs1 = (p0.Equals(arc1.Start));
                fe1 = (p0.Equals(arc1.End));
                if ((fs0 || fe0) && (fs1 || fe1))
                    return ArcCrossStates.None;
                var csate = ArcCrossStates.Both;
                if (!fs0 && !fe0) {
                    var nArc0 = new Arc2(arc0);
                    arc0.Start = p0;
                    nArc0.End = p0;
                    newArc0s.AddRange([arc0, nArc0]);
                }
                else
                    csate = ArcCrossStates.SecondOnly;
                if (!fs1 && !fe1) {
                    var aList = Arc2.SplitWithPoints([p0], arc1);
                    newArc1s.AddRange(aList);
                }
                else {
                    if (csate == ArcCrossStates.SecondOnly)
                        csate = ArcCrossStates.None;
                    else
                        csate = ArcCrossStates.FirstOnly;
                }
                return csate;
            }
            else {
                var p0 = ps[0];
                var p1 = ps[1];
                if ((arc0.Start == p0 && arc0.End == p1) || (arc0.Start == p1 && arc0.End == p0)) {
                    if ((arc1.Start == p0 && arc1.End == p1) || (arc1.Start == p1 && arc1.End == p0))
                        return ArcCrossStates.None;
                }
                var d0 = tv0.SetSubtract(arc0.End, arc0.Start);
                var d1 = tv1.SetSubtract(arc1.End, arc1.Start);
                var arc0_0 = p0;
                var arc0_1 = p1;
                var arc1_0 = p0;
                var arc1_1 = p1;
                if (U1.Vector2.Dot(d0, tv2.SetSubtract(p0, arc0.Start)) > U1.Vector2.Dot(d0, tv2.SetSubtract(p1, arc0.Start))) {
                    arc0_0 = p1;
                    arc0_1 = p0;
                }
                if (U1.Vector2.Dot(d1, tv2.SetSubtract(p0, arc1.Start)) > U1.Vector2.Dot(d1, tv2.SetSubtract(p1, arc1.Start))) {
                    arc1_0 = p1;
                    arc1_1 = p0;
                }
                var crsState = ArcCrossStates.Both;
                if (arc0.Start == arc0_0 && arc0.End == arc0_1) {
                    crsState = ArcCrossStates.SecondOnly;
                }
                else {
                    if (arc0.Start.Equals(arc0_0)) {
                        var aList = Arc2.SplitWithPoints([arc0_1], arc0);
                        newArc0s.AddRange(aList);
                    }
                    else if (arc0.End.Equals(arc0_1)) {
                        var aList = Arc2.SplitWithPoints([arc0_0], arc0);
                        newArc0s.AddRange(aList);
                    }
                    else {
                        var aList = Arc2.SplitWithPoints([arc0_0, arc0_1], arc0);
                        newArc0s.AddRange(aList);
                    }
                }
                if (arc1.Start == arc1_0 && arc1.End == arc1_1) {
                    crsState = ArcCrossStates.FirstOnly;
                }
                else {
                    var c = arc1.Center;
                    var r = tv2.SetSubtract(arc1.Start, c).Length();
                    var b = arc1._bulge;
                    if (arc1.Start == arc1_0) {
                        var aList = Arc2.SplitWithPoints([arc1_1], arc1);
                        newArc1s.AddRange(aList);
                    }
                    else if (arc1.End == arc1_1) {
                        var aList = Arc2.SplitWithPoints([arc1_0], arc1);
                        newArc1s.AddRange(aList);
                    }
                    else {
                        var aList = Arc2.SplitWithPoints([arc1_0, arc1_1], arc1);
                        newArc1s.AddRange(aList);
                    }
                }
                return crsState;
            }
        }
        static CrossArc_ArcArc(arc0, arc1, newArc0s, newArc1s) {
            var seg0 = Arc2[".cra.s0"] || (Arc2[".cra.s0"] = new U1.Segment2());
            var seg1 = Arc2[".cra.s1"] || (Arc2[".cra.s1"] = new U1.Segment2());
            var tv0 = Arc2[".cra.v0"] || (Arc2[".cra.v0"] = new U1.Vector2());
            var tv1 = Arc2[".cra.v1"] || (Arc2[".cra.v1"] = new U1.Vector2());
            var tv2 = Arc2[".cra.v2"] || (Arc2[".cra.v2"] = new U1.Vector2());
            var tv3 = Arc2[".cra.v3"] || (Arc2[".cra.v3"] = new U1.Vector2());
            var tv4 = Arc2[".cra.v4"] || (Arc2[".cra.v4"] = new U1.Vector2());
            var tv5 = Arc2[".cra.v5"] || (Arc2[".cra.v5"] = new U1.Vector2());
            var ps = U1.GeometryHelper2.CrossArcArc(arc0, arc1);
            if (ps == null)
                return ArcCrossStates.None;
            if (ps.length == 1) {
                var p0 = ps[0];
                var fs0, fe0, fs1, fe1;
                fs0 = (p0.Equals(arc0.Start));
                fe0 = (p0.Equals(arc0.End));
                fs1 = (p0.Equals(arc1.Start));
                fe1 = (p0.Equals(arc1.End));
                if ((fs0 || fe0) && (fs1 || fe1))
                    return ArcCrossStates.None;
                var csate = ArcCrossStates.Both;
                if (!fs0 && !fe0) {
                    var aList = Arc2.SplitWithPoints([p0], arc0);
                    newArc0s.AddRange(aList);
                }
                else
                    csate = ArcCrossStates.SecondOnly;
                if (!fs1 && !fe1) {
                    var aList = Arc2.SplitWithPoints([p0], arc1);
                    newArc1s.AddRange(aList);
                }
                else
                    csate = ArcCrossStates.FirstOnly;
                return csate;
            }
            else {
                var d0 = U1.Vector2.Subtract(arc0.End, arc0.Start, tv0);
                var d1 = U1.Vector2.Subtract(arc1.End, arc1.Start, tv1);
                var p0 = ps[0];
                var p1 = ps[1];
                var arc0_0 = p0.Clone();
                var arc0_1 = p1.Clone();
                var arc1_0 = p0.Clone();
                var arc1_1 = p1.Clone();
                if (U1.Vector2.Dot(d0, U1.Vector2.Subtract(p0, arc0.Start, tv2)) > U1.Vector2.Dot(d0, U1.Vector2.Subtract(p1, arc0.Start, tv2))) {
                    arc0_0 = p1;
                    arc0_1 = p0;
                }
                if (U1.Vector2.Dot(d1, U1.Vector2.Subtract(p0, arc1.Start, tv2)) > U1.Vector2.Dot(d1, U1.Vector2.Subtract(p1, arc1.Start, tv2))) {
                    arc1_0 = p1;
                    arc1_1 = p0;
                }
                if (arc0.Start == arc0_0 && arc0.End == arc0_1 && arc1.Start == arc1_0 && arc1.End == arc1_1)
                    return ArcCrossStates.None;
                var crsState = ArcCrossStates.Both;
                if (arc0.Start == arc0_0 && arc0.End == arc0_1) {
                    crsState = ArcCrossStates.SecondOnly;
                }
                else {
                    if (arc0.Start == arc0_0) {
                        var aList = Arc2.SplitWithPoints([arc0_1], arc0);
                        newArc0s.AddRange(aList);
                    }
                    else if (arc0.End == arc0_1) {
                        var aList = Arc2.SplitWithPoints([arc0_0], arc0);
                        newArc0s.AddRange(aList);
                    }
                    else {
                        var aList = Arc2.SplitWithPoints([arc0_0, arc0_1], arc0);
                        newArc0s.AddRange(aList);
                    }
                }
                if (arc1.Start == arc1_0 && arc1.End == arc1_1) {
                    crsState = ArcCrossStates.FirstOnly;
                }
                else {
                    var c = arc1.Center;
                    var r = U1.Vector2.Subtract(arc1.Start, c, tv2).Length();
                    var b = arc1._bulge;
                    if (arc1.Start == arc1_0) {
                        var aList = Arc2.SplitWithPoints([arc1_1], arc1);
                        newArc1s.AddRange(aList);
                    }
                    else if (arc1.End == arc1_1) {
                        var aList = Arc2.SplitWithPoints([arc1_0], arc1);
                        newArc1s.AddRange(aList);
                    }
                    else {
                        var aList = Arc2.SplitWithPoints([arc1_0, arc1_1], arc1);
                        newArc1s.AddRange(aList);
                    }
                }
                return crsState;
            }
        }
        static CalNewBulge(start, end, cent, radius, orignBulge) {
            var tv0 = Arc2[".cnb.v0"] || (Arc2[".cnb.v0"] = new U1.Vector2());
            var tv1 = Arc2[".cnb.v1"] || (Arc2[".cnb.v1"] = new U1.Vector2());
            var d1 = tv0.SetSubtract(end, start);
            var d2 = tv1.SetSubtract(cent, start);
            d1.Set(d1.Y, -d1.X);
            var l3 = d1.Length() / 2.0;
            var b = Math.sqrt(radius * radius - l3 * l3);
            var isCentRight = U1.Vector2.Dot(d1, d2);
            if (isCentRight > 0) {
                if (orignBulge > 0) {
                    b = radius + b;
                }
                else {
                    b = -(radius - b);
                }
            }
            else {
                if (orignBulge > 0) {
                    b = radius - b;
                }
                else {
                    b = -(radius + b);
                }
            }
            return b;
        }
        static SplitWithPoints(ps, arc) {
            var sliceArcs = [];
            sliceArcs.push(new Arc2(arc));
            for (var i = 0; i < ps.length; i++) {
                if (ps[i] == arc.Start || ps[i] == arc.End)
                    continue;
                var prev = sliceArcs[sliceArcs.length - 1];
                var nArc = new Arc2(arc);
                prev.End = ps[i];
                sliceArcs[sliceArcs.length - 1] = prev;
                nArc.Start = ps[i];
                sliceArcs.push(nArc);
            }
            if (arc.Bulge != 0) {
                var c = arc.Center;
                var r = arc.Radius;
                var b = arc.Bulge;
                for (var i = 0; i < sliceArcs.length; i++) {
                    var tArc = sliceArcs[i];
                    tArc.Bulge = Arc2.CalNewBulge(tArc.Start, tArc.End, c, r, b);
                    sliceArcs[i] = tArc;
                }
            }
            return sliceArcs;
        }
        static SplitWithPoint(arc, p) {
            if (p == arc.Start || p == arc.End)
                return [arc];
            var arc0 = new Arc2(arc);
            var arc1 = new Arc2(arc);
            var result = [
                arc0,
                arc1
            ];
            arc0.End = p;
            arc1.Start = p;
            if (arc.Bulge != 0) {
                var c = arc.Center;
                var r = arc.Radius;
                var b = arc.Bulge;
                arc0.Bulge = Arc2.CalNewBulge(arc0.Start, arc0.End, c, r, b);
                arc1.Bulge = Arc2.CalNewBulge(arc1.Start, arc1.End, c, r, b);
            }
            return result;
        }
        static MakeArc(start, end, center, bulgeSign) {
            var tv0 = Arc2[".mka.v0"] || (Arc2[".mka.v0"] = new U1.Vector2());
            var tv1 = Arc2[".mka.v1"] || (Arc2[".mka.v1"] = new U1.Vector2());
            var tv2 = Arc2[".mka.v2"] || (Arc2[".mka.v2"] = new U1.Vector2());
            var newArc = new Arc2();
            newArc.Start = start;
            newArc.End = end;
            if (bulgeSign == 0) {
                newArc.Bulge = 0;
                return newArc;
            }
            var d1 = tv0.SetSubtract(end, start);
            var d2 = tv1.SetSubtract(center, start);
            var m_l = tv2.SetAdd(start, end).Scale(0.5).Subtract(center).Length();
            var radius = d2.Length();
            var bulge = 0;
            if (Math.abs(m_l) < U1.MathHelper.PRECISION) {
                if (bulgeSign > 0)
                    newArc.Bulge = radius;
                else
                    newArc.Bulge = -radius;
                return newArc;
            }
            var rdir = d1.Set(d1.Y, -d1.X);
            var dot2Right = U1.Vector2.Dot(rdir, d2);
            if (Math.abs(dot2Right) < U1.MathHelper.PRECISION) {
                newArc.Bulge = 0;
                return newArc;
            }
            if (dot2Right < 0) {
                if (bulgeSign > 0)
                    bulge = radius - m_l;
                else
                    bulge = -m_l - radius;
            }
            else {
                if (bulgeSign > 0)
                    bulge = radius + m_l;
                else
                    bulge = m_l - radius;
            }
            newArc.Bulge = bulge;
            return newArc;
        }
        Offset(distance) {
            var offsetArc = U1.GeometryHelper2.GetOffsetArc(this, distance);
            this.CopyFrom(offsetArc);
        }
        Slice(segmentCount) {
            if (this.Bulge != 0) {
                var cent = this.Center;
                var baseAxis = U1.Vector2.Subtract(this.Start, cent);
                var v1 = U1.Vector2.Subtract(this.End, cent);
                var radius = this.Radius;
                var angCCW = U1.GeometryHelper2.AngleCCW(baseAxis, v1);
                var startangle = 0;
                if (this.Bulge < 0) {
                    angCCW -= U1.MathHelper.TwoPi;
                }
                var vs = U1.GeometryHelper2.SplitArc(baseAxis, startangle, angCCW, segmentCount);
                for (var i = 0; i < vs.length; i++) {
                    vs[i].Add(cent);
                }
                vs[0] = this.Start.Clone();
                vs[vs.length - 1] = this.End.Clone();
                return vs;
            }
            return [this.Start.Clone(), this.End.Clone()];
        }
        GetCenter() {
            if (!this._isCenterDirty)
                return this._center;
            this._isCenterDirty = false;
            if (this.Start.Equals(this.End))
                return this.Start;
            var mv = U1.Vector2.Add(this.Start, this.End).Scale(0.5);
            if (this.Bulge == 0)
                return mv;
            var dir = U1.Vector2.Subtract(this.End, this.Start);
            var l = dir.Length() / 2.0;
            dir.Normalize();
            var rightDir = this.Right();
            rightDir.Normalize();
            var m = Math.abs(this.Bulge);
            var d = (l * l - m * m) / (2 * m);
            if (this.Bulge > 0)
                d *= -1;
            this._center.SetScaleAdd(mv, d, rightDir);
            return this._center;
        }
        StartTangent() {
            if (this._bulge == 0)
                return U1.Vector2.Subtract(this._end, this._start).Normalize();
            var d = U1.Vector2.Subtract(this.Center, this._start);
            var tangent = U1.Vector2.Normalize(new U1.Vector2(d.Y, -d.X));
            if (this._bulge < 0)
                tangent.Scale(-1);
            return tangent;
        }
        EndTangent() {
            if (this._bulge == 0)
                return U1.Vector2.Subtract(this._start, this._end).Normalize();
            var d = U1.Vector2.Subtract(this.Center, this._end);
            var tangent = U1.Vector2.Normalize(new U1.Vector2(d.Y, -d.X));
            if (this._bulge > 0)
                tangent.Scale(-1);
            return tangent;
        }
        Opposite() {
            var nArc = new Arc2();
            nArc._start.CopyFrom(this._end);
            nArc._end.CopyFrom(this._start);
            nArc._bulge = -this._bulge;
            return nArc;
        }
        GetDistance(p) {
            var vOnArc = new U1.Vector2();
            return this.GetDistance1(p, vOnArc);
        }
        GetDistance1(p, pOnArc) {
            if (p === pOnArc)
                p = p.Clone();
            var cent = this.Center;
            pOnArc.SetZero();
            var Start = this.Start;
            var End = this.End;
            var Radius = this.Radius;
            var Bulge = this.Bulge;
            if (this.Bulge == 0) {
                var d = U1.Vector2.Subtract(End, Start);
                var len = d.Length();
                d.Normalize();
                var l0 = U1.Vector2.Dot(d, U1.Vector2.Subtract(p, Start));
                pOnArc = U1.Vector2.ScaleAdd(Start, 10, d);
                if (l0 >= 0 && l0 <= len) {
                    var l1 = U1.Vector2.Distance(p, Start);
                    if (Math.abs(l0 - l1) < 0.001)
                        return 0;
                    return Math.sqrt(l1 * l1 - l0 * l0);
                }
            }
            else {
                var vect0 = U1.Vector2.Subtract(Start, cent);
                var vect1 = U1.Vector2.Subtract(End, cent);
                var radius = Radius;
                var d = U1.Vector2.Subtract(p, cent).Normalize();
                pOnArc = U1.Vector2.ScaleAdd(cent, radius, d);
                var ea = U1.GeometryHelper2.AngleCCW(vect0, vect1);
                var sa = 0.0;
                if (Bulge < 0) {
                    sa = ea;
                    ea = (Math.PI * 2);
                }
                var ang = U1.GeometryHelper2.AngleCCW(U1.Vector2.Subtract(Start, cent), U1.Vector2.Subtract(p, cent));
                if (ang >= sa && ang <= ea) {
                    return U1.Vector2.Distance(p, pOnArc);
                }
            }
            if (U1.Vector2.Distance(p, Start) < U1.Vector2.Distance(p, End)) {
                pOnArc = Start;
                return U1.Vector2.Distance(p, Start);
            }
            else {
                pOnArc = End;
                return U1.Vector2.Distance(p, End);
            }
        }
        IsOver(p) {
            var onArc = new U1.Vector2();
            return this.GetDistance1(p, onArc) < U1.MathHelper.PRECISION;
        }
        static Translate(source, offset) {
            var result = new Arc2();
            result.Start.SetAdd(source.Start, offset);
            result.End.SetAdd(source.End, offset);
            result.Bulge = source.Bulge;
            return result;
        }
        Translate(offset) {
            this.Start.Add(offset);
            this.End.Add(offset);
        }
        SetBulgePosition(bulge_point) {
            var mp = U1.Vector2.Add(this.Start, this.End).Scale(1 / 2);
            var right = U1.Vector2.Subtract(this.End, this.Start).Normalize().Right;
            this.Bulge = U1.Vector2.Dot(U1.Vector2.Subtract(bulge_point, mp), right);
        }
        GetU(p) {
            var ponArc = new U1.Vector2();
            this.GetDistance1(p, ponArc);
            p = ponArc;
            if (this.Bulge == 0) {
                var v1 = U1.Vector2.Subtract(p, this.Start);
                return U1.Vector2.Dot(v1, this.Direction()) / U1.Vector2.Distance(this.Start, this.End);
            }
            var cent = this.Center;
            var vect0 = U1.Vector2.Subtract(this.Start, cent);
            var vect1 = U1.Vector2.Subtract(this.End, cent);
            var vect2 = U1.Vector2.Subtract(p, cent);
            var ea = U1.GeometryHelper2.AngleCCW(vect0, vect1);
            var sa = 0.0;
            if (this.Bulge < 0) {
                sa = ea;
                ea = (Math.PI * 2);
            }
            var ang = U1.GeometryHelper2.AngleCCW(vect0, vect2);
            return (ang - sa) / (ea - sa);
        }
        GetPositionAtU(u, result) {
            u = (u < 0) ? 0 : ((u > 1) ? 1 : u);
            if (result === undefined)
                result = new U1.Vector2();
            if (this.Bulge == 0) {
                result.SetScale(this.Start, 1 - u).ScaleAdd(u, this.End);
                return result;
            }
            var cent = this.Center;
            var rad = this.Radius;
            var vect0 = U1.Vector2.Subtract(this.Start, cent);
            var vect1 = U1.Vector2.Subtract(this.End, cent);
            var ea = U1.GeometryHelper2.AngleCCW(vect0, vect1);
            var sa = 0.0;
            if (this.Bulge < 0) {
                sa = ea;
                ea = (Math.PI * 2);
            }
            var ang = u * (ea - sa) + sa;
            var baseAxis = U1.Vector2.Normalize(vect0);
            var left = baseAxis.Left;
            var norm = U1.Vector2.Scale(baseAxis, Math.cos(ang))
                .ScaleAdd(Math.sin(ang), left);
            return norm.Scale(rad).Add(this.Center);
        }
    }
    U1.Arc2 = Arc2;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Camera {
        constructor() {
            this.Position = new U1.Vector3();
            this.LookAt = new U1.Vector3();
            this.Up = new U1.Vector3();
            this.Viewport = new U1.Viewport();
            this._BoundingFrustum = new U1.BoundingFrustum();
        }
        get Frustum() {
            this._BoundingFrustum.SetMatrix(U1.Matrix4.Multiply(this.ViewMatrix, this.ProjMatrix));
            return this._BoundingFrustum;
        }
        get Right() {
            return U1.Vector3.Normalize(U1.Vector3.Cross(this.Direction, this.Up));
        }
        get Direction() {
            return U1.Vector3.Normalize(U1.Vector3.Subtract(this.LookAt, this.Position));
        }
        get ProjMatrix() {
            if (this.ProjectionMode == U1.ProjectionTypeEnum.Perspective)
                return U1.Matrix4.CreatePerspectiveFieldOfView(this.FOV, this.Aspect, this.Near, this.Far);
            else
                return U1.Matrix4.CreateOrthographic(this.Aspect * this.OrthoHeight, this.OrthoHeight, this.Near, this.Far);
        }
        get ViewMatrix() {
            return U1.Matrix4.CreateLookAt(this.Position, this.LookAt, this.Up);
        }
        get Aspect() {
            if (this.Viewport.Height <= 0)
                return 1;
            else
                return this.Viewport.Width / this.Viewport.Height;
        }
        static get Default() {
            var cam = new Camera();
            cam.Position = U1.Vector3.Zero;
            cam.LookAt = U1.Vector3.UnitY;
            cam.Up = U1.Vector3.UnitZ;
            cam.FOV = (Math.PI / 4);
            cam.Near = 0.1;
            cam.Far = 100000;
            cam.OrthoHeight = 100;
            cam.ProjectionMode = U1.ProjectionTypeEnum.Perspective;
            cam.Viewport.Width = 100;
            cam.Viewport.Height = 100;
            cam.Viewport.MaxDepth = 1;
            cam.Viewport.MinDepth = 0;
            return cam;
        }
        CalPickingRay(x, y, result) {
            var vm = this.ViewMatrix;
            var pm = this.ProjMatrix;
            var p0 = Camera[".cpr.p0"] || (Camera[".cpr.p0"] = new U1.Vector3());
            var p1 = Camera[".cpr.p1"] || (Camera[".cpr.p1"] = new U1.Vector3());
            var s0 = Camera[".cpr.s0"] || (Camera[".cpr.s0"] = new U1.Vector3());
            var s1 = Camera[".cpr.s1"] || (Camera[".cpr.s1"] = new U1.Vector3());
            var wm = Camera[".cpr.wm"] || (Camera[".cpr.wm"] = U1.Matrix4.Identity);
            s0.Set(x, y, 0);
            s1.Set(x, y, 1);
            p0 = this.Viewport.Unproject(s0, pm, vm, wm, p0);
            p1 = this.Viewport.Unproject(s1, pm, vm, wm, p1);
            if (result == null)
                result = new U1.Ray3();
            result.Position.CopyFrom(p0);
            result.Direction.SetSubtract(p1, p0).Normalize();
            return result;
        }
        WorldToScreen(wp, result) {
            result = this.Viewport.Project(wp, this.ProjMatrix, this.ViewMatrix, U1.Matrix4.Identity, result);
            return result;
        }
        ScreenToWorld(sp, result) {
            result = this.Viewport.Unproject(sp, this.ProjMatrix, this.ViewMatrix, U1.Matrix4.Identity, result);
            return result;
        }
        GetRotation(targetCamera) {
            var src = U1.Matrix4.Identity;
            src.Right = this.Right;
            src.Up = this.Up;
            src.Forward = this.Direction;
            var tgt = U1.Matrix4.Identity;
            tgt.Right = targetCamera.Right;
            tgt.Up = targetCamera.Up;
            tgt.Forward = targetCamera.Direction;
            return Camera.GetRotation(src, tgt);
        }
        static GetRotation(src, target) {
            var result = { axis: U1.Vector3.Zero, angle: 0, roll: 0 };
            var srcv = src.Backward;
            var tgtv = target.Backward;
            if (Math.abs(src.Backward.Z - target.Backward.Z) < 0.0001) {
                srcv.Z = tgtv.Z = 0;
                srcv.Normalize();
                tgtv.Normalize();
            }
            result.axis = U1.Vector3.Normalize(U1.Vector3.Cross(srcv, tgtv));
            var dt = U1.Vector3.Dot(srcv, tgtv);
            if (dt > 0.999 || dt < -0.999)
                result.axis = U1.Vector3.UnitZ;
            result.angle = (Math.acos(dt));
            src = U1.Matrix4.Multiply(src, U1.Matrix4.CreateFromAxisAngle(result.axis, result.angle));
            var sr = src.Right;
            var tr = target.Right;
            var n = src.Backward;
            result.roll = U1.GeometryHelper3.AngleCCW(sr, n, tr);
            if (result.roll > Math.PI)
                result.roll = -(Math.PI * 2 - result.roll);
            return result;
        }
        Roll(roll) {
            this.Rotate(this.Position, U1.Vector3.Negate(this.Direction), roll);
        }
        Rotate(position, axis, ang) {
            axis.Normalize();
            var mat = U1.Matrix4.CreateTranslation(U1.Vector3.Negate(position))
                .Multiply(U1.Matrix4.CreateFromAxisAngle(axis, ang))
                .Multiply(U1.Matrix4.CreateTranslation(position));
            this.Position.Transform(mat);
            this.Up.TransformNormal(mat);
            this.LookAt.Transform(mat);
        }
        ScreenToPlane(pt, plane) {
            var result = null;
            var ray = this.CalPickingRay(pt.X, pt.Y);
            result = plane.IntersectsLine(ray.Position, ray.Direction);
            if (result != null && result >= 0)
                return U1.Vector3.ScaleAdd(ray.Position, result, ray.Direction);
            return null;
        }
        Move(dir) {
            this.Position.Add(dir);
            this.LookAt.Add(dir);
        }
        Clone() {
            var camera = new Camera();
            camera.Position.CopyFrom(this.Position);
            camera.LookAt.CopyFrom(this.LookAt);
            camera.Up.CopyFrom(this.Up);
            camera.FOV = this.FOV;
            camera.Near = this.Near;
            camera.Far = this.Far;
            camera.OrthoHeight = this.OrthoHeight;
            camera.ProjectionMode = this.ProjectionMode;
            camera.Viewport.MaxDepth = this.Viewport.MaxDepth;
            camera.Viewport.MinDepth = this.Viewport.MinDepth;
            camera.Viewport.Width = this.Viewport.Width;
            camera.Viewport.Height = this.Viewport.Height;
            camera.Viewport.X = this.Viewport.X;
            camera.Viewport.Y = this.Viewport.Y;
            return camera;
        }
        Equals(other) {
            return this.Position.Equals(other.Position)
                && this.LookAt.Equals(other.LookAt)
                && this.Up.Equals(other.Up)
                && this.FOV == other.FOV
                && this.Near == other.Near
                && this.Far == other.Far
                && this.OrthoHeight == other.OrthoHeight
                && this.ProjectionMode == other.ProjectionMode
                && this.Viewport.Equals(other.Viewport);
        }
    }
    U1.Camera = Camera;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class MathHelper {
        static Barycentric(value1, value2, value3, amount1, amount2) {
            return ((value1 + (amount1 * (value2 - value1))) + (amount2 * (value3 - value1)));
        }
        static CatmullRom(value1, value2, value3, value4, amount) {
            var num = amount * amount;
            var num2 = amount * num;
            return (0.5 * ((((2 * value2) + ((-value1 + value3) * amount)) + (((((2 * value1) - (5 * value2)) + (4 * value3)) - value4) * num)) + ((((-value1 + (3 * value2)) - (3 * value3)) + value4) * num2)));
        }
        static Clamp(value, min, max) {
            value = (value > max) ? max : value;
            value = (value < min) ? min : value;
            return value;
        }
        static Distance(value1, value2) {
            return Math.abs((value1 - value2));
        }
        static Hermite(value1, tangent1, value2, tangent2, amount) {
            var num3 = amount;
            var num = num3 * num3;
            var num2 = num3 * num;
            var num7 = ((2 * num2) - (3 * num)) + 1;
            var num6 = (-2 * num2) + (3 * num);
            var num5 = (num2 - (2 * num)) + num3;
            var num4 = num2 - num;
            return ((((value1 * num7) + (value2 * num6)) + (tangent1 * num5)) + (tangent2 * num4));
        }
        static Lerp(value1, value2, amount) {
            return (value1 + ((value2 - value1) * amount));
        }
        static Max(value1, value2) {
            return Math.max(value1, value2);
        }
        static Min(value1, value2) {
            return Math.min(value1, value2);
        }
        static SmoothStep(value1, value2, amount) {
            var num = U1.Clamp(amount, 0, 1);
            return MathHelper.Lerp(value1, value2, (num * num) * (3 - (2 * num)));
        }
        static ToDegrees(radians) {
            return (radians * 57.29578);
        }
        static ToRadians(degrees) {
            return (degrees * 0.01745329);
        }
        static signum(x) {
            x = +x;
            if (x === 0 || isNaN(x)) {
                return x;
            }
            return x > 0 ? 1 : -1;
        }
        static IEEEremainder(f1, f2) {
            var r = Math.abs(f1 % f2);
            if (isNaN(r) || r == f2 || r <= Math.abs(f2) / 2.0) {
                return r;
            }
            else {
                return MathHelper.signum(f1) * (r - f2);
            }
        }
        static WrapAngle(angle) {
            angle = MathHelper.IEEEremainder(angle, 6.2831854820251465);
            if (angle <= -3.141593) {
                angle += 6.283185;
                return angle;
            }
            if (angle > 3.141593) {
                angle -= 6.283185;
            }
            return angle;
        }
        static Round(vector3) {
            var result = new U1.Vector3();
            result.X = Math.round(vector3.X);
            result.Y = Math.round(vector3.Y);
            result.Z = Math.round(vector3.Z);
            return result;
        }
        static MatrixToEulerZYX(m, result) {
            var thetaX;
            var thetaY;
            var thetaZ;
            thetaY = Math.asin(-m.M31);
            if (thetaY < Math.PI / 2) {
                if (thetaY > -Math.PI / 2) {
                    thetaZ = Math.atan2(m.M21, m.M11);
                    thetaX = Math.atan2(m.M32, m.M33);
                }
                else {
                    thetaZ = -Math.atan2(-m.M12, m.M13);
                    thetaX = 0;
                }
            }
            else {
                thetaZ = Math.atan2(-m.M12, m.M13);
                thetaX = 0;
            }
            if (result == null)
                result = new U1.Vector3();
            result.Set(thetaX, thetaY, thetaZ);
            return result;
        }
        static MatrixToEulerXYZ(m, result) {
            var thetaX;
            var thetaY;
            var thetaZ;
            thetaY = Math.asin(-m.M13);
            if (thetaY < Math.PI / 2) {
                if (thetaY > -Math.PI / 2) {
                    thetaX = Math.atan2(m.M23, m.M33);
                    thetaZ = Math.atan2(m.M12, m.M11);
                }
                else {
                    thetaX = -Math.atan2(-m.M21, m.M22);
                    thetaZ = 0;
                }
            }
            else {
                thetaX = Math.atan2(-m.M21, m.M22);
                thetaZ = 0;
            }
            if (result == null)
                result = new U1.Vector3();
            result.Set(thetaX, thetaY, thetaZ);
            return result;
        }
        static GetAxisAngle(xdir, ydir, result) {
            var s_ = MathHelper[".gaa"] || (MathHelper[".gaa"] =
                {
                    zero: U1.Vector3.Zero,
                    rm: U1.Matrix4.Identity,
                    qt: new U1.Quaternion()
                });
            var zero = s_.zero;
            var rotMatrix = s_.rm;
            var quat = s_.qt;
            rotMatrix.SetCreateWorldFormXY(zero, xdir, ydir);
            quat.SetCreateFromRotationMatrix(rotMatrix);
            result = result || new U1.Vector4();
            result.Set(0, 0, 1, 0);
            return quat.ToAxisAngle(result);
        }
        static MatrixToAxisAngle(mat, result) {
            var quat = MathHelper[".mta.qt"] || (MathHelper[".mta.qt"] = new U1.Quaternion());
            quat.SetCreateFromRotationMatrix(mat);
            result = result || new U1.Vector4();
            result.Set(0, 0, 1, 0);
            quat.ToAxisAngle(result);
            if (result.LengthSquareduaredXYZ() < 0.00001)
                result.Set(0, 0, 1, result.W);
            return result;
        }
        static IsNaN(v) {
            return isNaN(v.X)
                || isNaN(v.Y)
                || v["Z"] !== undefined && isNaN(v.Z)
                || v["W"] !== undefined && isNaN(v.W);
        }
    }
    MathHelper.E = 2.718282;
    MathHelper.Log10E = 0.4342945;
    MathHelper.Log2E = 1.442695;
    MathHelper.Pi = 3.141593;
    MathHelper.PiOver2 = 1.570796;
    MathHelper.PiOver4 = 0.7853982;
    MathHelper.TwoPi = 6.283185;
    MathHelper.PRECISION = 0.00001;
    U1.MathHelper = MathHelper;
})(U1 || (U1 = {}));
var collections;
(function (collections) {
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var has = function (obj, prop) {
        return _hasOwnProperty.call(obj, prop);
    };
    function defaultCompare(a, b) {
        if (a < b) {
            return -1;
        }
        else if (a === b) {
            return 0;
        }
        else {
            return 1;
        }
    }
    collections.defaultCompare = defaultCompare;
    function defaultEquals(a, b) {
        return a === b;
    }
    collections.defaultEquals = defaultEquals;
    function defaultToString(item) {
        if (item === null) {
            return 'COLLECTION_NULL';
        }
        else if (collections.isUndefined(item)) {
            return 'COLLECTION_UNDEFINED';
        }
        else if (collections.isString(item)) {
            return '$s' + item;
        }
        else {
            return '$o' + item.toString();
        }
    }
    collections.defaultToString = defaultToString;
    function makeString(item, join = ",") {
        if (item === null) {
            return 'COLLECTION_NULL';
        }
        else if (collections.isUndefined(item)) {
            return 'COLLECTION_UNDEFINED';
        }
        else if (collections.isString(item)) {
            return item.toString();
        }
        else {
            var toret = "{";
            var first = true;
            for (var prop in item) {
                if (has(item, prop)) {
                    if (first)
                        first = false;
                    else
                        toret = toret + join;
                    toret = toret + prop + ":" + item[prop];
                }
            }
            return toret + "}";
        }
    }
    collections.makeString = makeString;
    function isFunction(func) {
        return (typeof func) === 'function';
    }
    collections.isFunction = isFunction;
    function isUndefined(obj) {
        return (typeof obj) === 'undefined';
    }
    collections.isUndefined = isUndefined;
    function isString(obj) {
        return Object.prototype.toString.call(obj) === '[object String]';
    }
    collections.isString = isString;
    function reverseCompareFunction(compareFunction) {
        if (!collections.isFunction(compareFunction)) {
            return function (a, b) {
                if (a < b) {
                    return 1;
                }
                else if (a === b) {
                    return 0;
                }
                else {
                    return -1;
                }
            };
        }
        else {
            return function (d, v) {
                return compareFunction(d, v) * -1;
            };
        }
    }
    collections.reverseCompareFunction = reverseCompareFunction;
    function compareToEquals(compareFunction) {
        return function (a, b) {
            return compareFunction(a, b) === 0;
        };
    }
    collections.compareToEquals = compareToEquals;
    let arrays;
    (function (arrays) {
        function indexOf(array, item, equalsFunction) {
            var equals = equalsFunction || collections.defaultEquals;
            var length = array.length;
            for (var i = 0; i < length; i++) {
                if (equals(array[i], item)) {
                    return i;
                }
            }
            return -1;
        }
        arrays.indexOf = indexOf;
        function lastIndexOf(array, item, equalsFunction) {
            var equals = equalsFunction || collections.defaultEquals;
            var length = array.length;
            for (var i = length - 1; i >= 0; i--) {
                if (equals(array[i], item)) {
                    return i;
                }
            }
            return -1;
        }
        arrays.lastIndexOf = lastIndexOf;
        function contains(array, item, equalsFunction) {
            return arrays.indexOf(array, item, equalsFunction) >= 0;
        }
        arrays.contains = contains;
        function remove(array, item, equalsFunction) {
            var index = arrays.indexOf(array, item, equalsFunction);
            if (index < 0) {
                return false;
            }
            array.splice(index, 1);
            return true;
        }
        arrays.remove = remove;
        function frequency(array, item, equalsFunction) {
            var equals = equalsFunction || collections.defaultEquals;
            var length = array.length;
            var freq = 0;
            for (var i = 0; i < length; i++) {
                if (equals(array[i], item)) {
                    freq++;
                }
            }
            return freq;
        }
        arrays.frequency = frequency;
        function equals(array1, array2, equalsFunction) {
            var equals = equalsFunction || collections.defaultEquals;
            if (array1.length !== array2.length) {
                return false;
            }
            var length = array1.length;
            for (var i = 0; i < length; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }
            return true;
        }
        arrays.equals = equals;
        function copy(array) {
            return array.concat();
        }
        arrays.copy = copy;
        function swap(array, i, j) {
            if (i < 0 || i >= array.length || j < 0 || j >= array.length) {
                return false;
            }
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
            return true;
        }
        arrays.swap = swap;
        function toString(array) {
            return '[' + array.toString() + ']';
        }
        arrays.toString = toString;
        function forEach(array, callback) {
            var lenght = array.length;
            for (var i = 0; i < lenght; i++) {
                if (callback(array[i]) === false) {
                    return;
                }
            }
        }
        arrays.forEach = forEach;
    })(arrays = collections.arrays || (collections.arrays = {}));
    class LinkedList {
        constructor() {
            this.firstNode = null;
            this.lastNode = null;
            this.nElements = 0;
        }
        add(item, index) {
            if (collections.isUndefined(index)) {
                index = this.nElements;
            }
            if (index < 0 || index > this.nElements || collections.isUndefined(item)) {
                return false;
            }
            var newNode = this.createNode(item);
            if (this.nElements === 0) {
                this.firstNode = newNode;
                this.lastNode = newNode;
            }
            else if (index === this.nElements) {
                this.lastNode.next = newNode;
                this.lastNode = newNode;
            }
            else if (index === 0) {
                newNode.next = this.firstNode;
                this.firstNode = newNode;
            }
            else {
                var prev = this.nodeAtIndex(index - 1);
                newNode.next = prev.next;
                prev.next = newNode;
            }
            this.nElements++;
            return true;
        }
        first() {
            if (this.firstNode !== null) {
                return this.firstNode.element;
            }
            return undefined;
        }
        last() {
            if (this.lastNode !== null) {
                return this.lastNode.element;
            }
            return undefined;
        }
        elementAtIndex(index) {
            var node = this.nodeAtIndex(index);
            if (node === null) {
                return undefined;
            }
            return node.element;
        }
        indexOf(item, equalsFunction) {
            var equalsF = equalsFunction || collections.defaultEquals;
            if (collections.isUndefined(item)) {
                return -1;
            }
            var currentNode = this.firstNode;
            var index = 0;
            while (currentNode !== null) {
                if (equalsF(currentNode.element, item)) {
                    return index;
                }
                index++;
                currentNode = currentNode.next;
            }
            return -1;
        }
        contains(item, equalsFunction) {
            return (this.indexOf(item, equalsFunction) >= 0);
        }
        remove(item, equalsFunction) {
            var equalsF = equalsFunction || collections.defaultEquals;
            if (this.nElements < 1 || collections.isUndefined(item)) {
                return false;
            }
            var previous = null;
            var currentNode = this.firstNode;
            while (currentNode !== null) {
                if (equalsF(currentNode.element, item)) {
                    if (currentNode === this.firstNode) {
                        this.firstNode = this.firstNode.next;
                        if (currentNode === this.lastNode) {
                            this.lastNode = null;
                        }
                    }
                    else if (currentNode === this.lastNode) {
                        this.lastNode = previous;
                        previous.next = currentNode.next;
                        currentNode.next = null;
                    }
                    else {
                        previous.next = currentNode.next;
                        currentNode.next = null;
                    }
                    this.nElements--;
                    return true;
                }
                previous = currentNode;
                currentNode = currentNode.next;
            }
            return false;
        }
        clear() {
            this.firstNode = null;
            this.lastNode = null;
            this.nElements = 0;
        }
        equals(other, equalsFunction) {
            var eqF = equalsFunction || collections.defaultEquals;
            if (!(other instanceof collections.LinkedList)) {
                return false;
            }
            if (this.size() !== other.size()) {
                return false;
            }
            return this.equalsAux(this.firstNode, other.firstNode, eqF);
        }
        equalsAux(n1, n2, eqF) {
            while (n1 !== null) {
                if (!eqF(n1.element, n2.element)) {
                    return false;
                }
                n1 = n1.next;
                n2 = n2.next;
            }
            return true;
        }
        removeElementAtIndex(index) {
            if (index < 0 || index >= this.nElements) {
                return undefined;
            }
            var element;
            if (this.nElements === 1) {
                element = this.firstNode.element;
                this.firstNode = null;
                this.lastNode = null;
            }
            else {
                var previous = this.nodeAtIndex(index - 1);
                if (previous === null) {
                    element = this.firstNode.element;
                    this.firstNode = this.firstNode.next;
                }
                else if (previous.next === this.lastNode) {
                    element = this.lastNode.element;
                    this.lastNode = previous;
                }
                if (previous !== null) {
                    element = previous.next.element;
                    previous.next = previous.next.next;
                }
            }
            this.nElements--;
            return element;
        }
        forEach(callback) {
            var currentNode = this.firstNode;
            while (currentNode !== null) {
                if (callback(currentNode.element) === false) {
                    break;
                }
                currentNode = currentNode.next;
            }
        }
        reverse() {
            var previous = null;
            var current = this.firstNode;
            var temp = null;
            while (current !== null) {
                temp = current.next;
                current.next = previous;
                previous = current;
                current = temp;
            }
            temp = this.firstNode;
            this.firstNode = this.lastNode;
            this.lastNode = temp;
        }
        toArray() {
            var array = [];
            var currentNode = this.firstNode;
            while (currentNode !== null) {
                array.push(currentNode.element);
                currentNode = currentNode.next;
            }
            return array;
        }
        size() {
            return this.nElements;
        }
        isEmpty() {
            return this.nElements <= 0;
        }
        toString() {
            return collections.arrays.toString(this.toArray());
        }
        nodeAtIndex(index) {
            if (index < 0 || index >= this.nElements) {
                return null;
            }
            if (index === (this.nElements - 1)) {
                return this.lastNode;
            }
            var node = this.firstNode;
            for (var i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        }
        createNode(item) {
            return {
                element: item,
                next: null
            };
        }
    }
    collections.LinkedList = LinkedList;
    class Dictionary {
        constructor(toStrFunction) {
            this.table = {};
            this.nElements = 0;
            this.toStr = toStrFunction || collections.defaultToString;
        }
        getValue(key) {
            var pair = this.table['$' + this.toStr(key)];
            if (collections.isUndefined(pair)) {
                return undefined;
            }
            return pair.value;
        }
        setValue(key, value) {
            if (collections.isUndefined(key) || collections.isUndefined(value)) {
                return undefined;
            }
            var ret;
            var k = '$' + this.toStr(key);
            var previousElement = this.table[k];
            if (collections.isUndefined(previousElement)) {
                this.nElements++;
                ret = undefined;
            }
            else {
                ret = previousElement.value;
            }
            this.table[k] = {
                key: key,
                value: value
            };
            return ret;
        }
        remove(key) {
            var k = '$' + this.toStr(key);
            var previousElement = this.table[k];
            if (!collections.isUndefined(previousElement)) {
                delete this.table[k];
                this.nElements--;
                return previousElement.value;
            }
            return undefined;
        }
        keys() {
            var array = [];
            for (var name in this.table) {
                if (has(this.table, name)) {
                    var pair = this.table[name];
                    array.push(pair.key);
                }
            }
            return array;
        }
        values() {
            var array = [];
            for (var name in this.table) {
                if (has(this.table, name)) {
                    var pair = this.table[name];
                    array.push(pair.value);
                }
            }
            return array;
        }
        forEach(callback) {
            for (var name in this.table) {
                if (has(this.table, name)) {
                    var pair = this.table[name];
                    var ret = callback(pair.key, pair.value);
                    if (ret === false) {
                        return;
                    }
                }
            }
        }
        containsKey(key) {
            return !collections.isUndefined(this.getValue(key));
        }
        clear() {
            this.table = {};
            this.nElements = 0;
        }
        size() {
            return this.nElements;
        }
        isEmpty() {
            return this.nElements <= 0;
        }
        toString() {
            var toret = "{";
            this.forEach((k, v) => {
                toret = toret + "\n\t" + k.toString() + " : " + v.toString();
            });
            return toret + "\n}";
        }
    }
    collections.Dictionary = Dictionary;
    class MultiDictionary {
        constructor(toStrFunction, valuesEqualsFunction, allowDuplicateValues = false) {
            this.dict = new Dictionary(toStrFunction);
            this.equalsF = valuesEqualsFunction || collections.defaultEquals;
            this.allowDuplicate = allowDuplicateValues;
        }
        getValue(key) {
            var values = this.dict.getValue(key);
            if (collections.isUndefined(values)) {
                return [];
            }
            return collections.arrays.copy(values);
        }
        setValue(key, value) {
            if (collections.isUndefined(key) || collections.isUndefined(value)) {
                return false;
            }
            if (!this.containsKey(key)) {
                this.dict.setValue(key, [value]);
                return true;
            }
            var array = this.dict.getValue(key);
            if (!this.allowDuplicate) {
                if (collections.arrays.contains(array, value, this.equalsF)) {
                    return false;
                }
            }
            array.push(value);
            return true;
        }
        remove(key, value) {
            if (collections.isUndefined(value)) {
                var v = this.dict.remove(key);
                return !collections.isUndefined(v);
            }
            var array = this.dict.getValue(key);
            if (collections.arrays.remove(array, value, this.equalsF)) {
                if (array.length === 0) {
                    this.dict.remove(key);
                }
                return true;
            }
            return false;
        }
        keys() {
            return this.dict.keys();
        }
        values() {
            var values = this.dict.values();
            var array = [];
            for (var i = 0; i < values.length; i++) {
                var v = values[i];
                for (var j = 0; j < v.length; j++) {
                    array.push(v[j]);
                }
            }
            return array;
        }
        containsKey(key) {
            return this.dict.containsKey(key);
        }
        clear() {
            this.dict.clear();
        }
        size() {
            return this.dict.size();
        }
        isEmpty() {
            return this.dict.isEmpty();
        }
    }
    collections.MultiDictionary = MultiDictionary;
    class Heap {
        constructor(compareFunction) {
            this.data = [];
            this.compare = compareFunction || collections.defaultCompare;
        }
        leftChildIndex(nodeIndex) {
            return (2 * nodeIndex) + 1;
        }
        rightChildIndex(nodeIndex) {
            return (2 * nodeIndex) + 2;
        }
        parentIndex(nodeIndex) {
            return Math.floor((nodeIndex - 1) / 2);
        }
        minIndex(leftChild, rightChild) {
            if (rightChild >= this.data.length) {
                if (leftChild >= this.data.length) {
                    return -1;
                }
                else {
                    return leftChild;
                }
            }
            else {
                if (this.compare(this.data[leftChild], this.data[rightChild]) <= 0) {
                    return leftChild;
                }
                else {
                    return rightChild;
                }
            }
        }
        siftUp(index) {
            var parent = this.parentIndex(index);
            while (index > 0 && this.compare(this.data[parent], this.data[index]) > 0) {
                collections.arrays.swap(this.data, parent, index);
                index = parent;
                parent = this.parentIndex(index);
            }
        }
        siftDown(nodeIndex) {
            var min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));
            while (min >= 0 && this.compare(this.data[nodeIndex], this.data[min]) > 0) {
                collections.arrays.swap(this.data, min, nodeIndex);
                nodeIndex = min;
                min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));
            }
        }
        peek() {
            if (this.data.length > 0) {
                return this.data[0];
            }
            else {
                return undefined;
            }
        }
        add(element) {
            if (collections.isUndefined(element)) {
                return undefined;
            }
            this.data.push(element);
            this.siftUp(this.data.length - 1);
            return true;
        }
        removeRoot() {
            if (this.data.length > 0) {
                var obj = this.data[0];
                this.data[0] = this.data[this.data.length - 1];
                this.data.splice(this.data.length - 1, 1);
                if (this.data.length > 0) {
                    this.siftDown(0);
                }
                return obj;
            }
            return undefined;
        }
        contains(element) {
            var equF = collections.compareToEquals(this.compare);
            return collections.arrays.contains(this.data, element, equF);
        }
        size() {
            return this.data.length;
        }
        isEmpty() {
            return this.data.length <= 0;
        }
        clear() {
            this.data.length = 0;
        }
        forEach(callback) {
            collections.arrays.forEach(this.data, callback);
        }
    }
    collections.Heap = Heap;
    class Stack {
        constructor() {
            this.list = new LinkedList();
        }
        push(elem) {
            return this.list.add(elem, 0);
        }
        add(elem) {
            return this.list.add(elem, 0);
        }
        pop() {
            return this.list.removeElementAtIndex(0);
        }
        peek() {
            return this.list.first();
        }
        size() {
            return this.list.size();
        }
        contains(elem, equalsFunction) {
            return this.list.contains(elem, equalsFunction);
        }
        isEmpty() {
            return this.list.isEmpty();
        }
        clear() {
            this.list.clear();
        }
        forEach(callback) {
            this.list.forEach(callback);
        }
    }
    collections.Stack = Stack;
    class Queue {
        constructor() {
            this.list = new LinkedList();
        }
        enqueue(elem) {
            return this.list.add(elem);
        }
        add(elem) {
            return this.list.add(elem);
        }
        dequeue() {
            if (this.list.size() !== 0) {
                var el = this.list.first();
                this.list.removeElementAtIndex(0);
                return el;
            }
            return undefined;
        }
        peek() {
            if (this.list.size() !== 0) {
                return this.list.first();
            }
            return undefined;
        }
        size() {
            return this.list.size();
        }
        contains(elem, equalsFunction) {
            return this.list.contains(elem, equalsFunction);
        }
        isEmpty() {
            return this.list.size() <= 0;
        }
        clear() {
            this.list.clear();
        }
        forEach(callback) {
            this.list.forEach(callback);
        }
    }
    collections.Queue = Queue;
    class PriorityQueue {
        constructor(compareFunction) {
            this.heap = new Heap(collections.reverseCompareFunction(compareFunction));
        }
        enqueue(element) {
            return this.heap.add(element);
        }
        add(element) {
            return this.heap.add(element);
        }
        dequeue() {
            if (this.heap.size() !== 0) {
                var el = this.heap.peek();
                this.heap.removeRoot();
                return el;
            }
            return undefined;
        }
        peek() {
            return this.heap.peek();
        }
        contains(element) {
            return this.heap.contains(element);
        }
        isEmpty() {
            return this.heap.isEmpty();
        }
        size() {
            return this.heap.size();
        }
        clear() {
            this.heap.clear();
        }
        forEach(callback) {
            this.heap.forEach(callback);
        }
    }
    collections.PriorityQueue = PriorityQueue;
    class Set {
        constructor(toStringFunction) {
            this.dictionary = new Dictionary(toStringFunction);
        }
        contains(element) {
            return this.dictionary.containsKey(element);
        }
        add(element) {
            if (this.contains(element) || collections.isUndefined(element)) {
                return false;
            }
            else {
                this.dictionary.setValue(element, element);
                return true;
            }
        }
        intersection(otherSet) {
            var set = this;
            this.forEach(function (element) {
                if (!otherSet.contains(element)) {
                    set.remove(element);
                }
                return true;
            });
        }
        union(otherSet) {
            var set = this;
            otherSet.forEach(function (element) {
                set.add(element);
                return true;
            });
        }
        difference(otherSet) {
            var set = this;
            otherSet.forEach(function (element) {
                set.remove(element);
                return true;
            });
        }
        isSubsetOf(otherSet) {
            if (this.size() > otherSet.size()) {
                return false;
            }
            var isSub = true;
            this.forEach(function (element) {
                if (!otherSet.contains(element)) {
                    isSub = false;
                    return false;
                }
                return true;
            });
            return isSub;
        }
        remove(element) {
            if (!this.contains(element)) {
                return false;
            }
            else {
                this.dictionary.remove(element);
                return true;
            }
        }
        forEach(callback) {
            this.dictionary.forEach(function (k, v) {
                return callback(v);
            });
        }
        toArray() {
            return this.dictionary.values();
        }
        isEmpty() {
            return this.dictionary.isEmpty();
        }
        size() {
            return this.dictionary.size();
        }
        clear() {
            this.dictionary.clear();
        }
        toString() {
            return collections.arrays.toString(this.toArray());
        }
    }
    collections.Set = Set;
    class Bag {
        constructor(toStrFunction) {
            this.toStrF = toStrFunction || collections.defaultToString;
            this.dictionary = new Dictionary(this.toStrF);
            this.nElements = 0;
        }
        add(element, nCopies = 1) {
            if (collections.isUndefined(element) || nCopies <= 0) {
                return false;
            }
            if (!this.contains(element)) {
                var node = {
                    value: element,
                    copies: nCopies
                };
                this.dictionary.setValue(element, node);
            }
            else {
                this.dictionary.getValue(element).copies += nCopies;
            }
            this.nElements += nCopies;
            return true;
        }
        count(element) {
            if (!this.contains(element)) {
                return 0;
            }
            else {
                return this.dictionary.getValue(element).copies;
            }
        }
        contains(element) {
            return this.dictionary.containsKey(element);
        }
        remove(element, nCopies = 1) {
            if (collections.isUndefined(element) || nCopies <= 0) {
                return false;
            }
            if (!this.contains(element)) {
                return false;
            }
            else {
                var node = this.dictionary.getValue(element);
                if (nCopies > node.copies) {
                    this.nElements -= node.copies;
                }
                else {
                    this.nElements -= nCopies;
                }
                node.copies -= nCopies;
                if (node.copies <= 0) {
                    this.dictionary.remove(element);
                }
                return true;
            }
        }
        toArray() {
            var a = [];
            var values = this.dictionary.values();
            var vl = values.length;
            for (var i = 0; i < vl; i++) {
                var node = values[i];
                var element = node.value;
                var copies = node.copies;
                for (var j = 0; j < copies; j++) {
                    a.push(element);
                }
            }
            return a;
        }
        toSet() {
            var toret = new Set(this.toStrF);
            var elements = this.dictionary.values();
            var l = elements.length;
            for (var i = 0; i < l; i++) {
                var value = elements[i].value;
                toret.add(value);
            }
            return toret;
        }
        forEach(callback) {
            this.dictionary.forEach(function (k, v) {
                var value = v.value;
                var copies = v.copies;
                for (var i = 0; i < copies; i++) {
                    if (callback(value) === false) {
                        return false;
                    }
                }
                return true;
            });
        }
        size() {
            return this.nElements;
        }
        isEmpty() {
            return this.nElements === 0;
        }
        clear() {
            this.nElements = 0;
            this.dictionary.clear();
        }
    }
    collections.Bag = Bag;
    class BSTree {
        constructor(compareFunction) {
            this.root = null;
            this.compare = compareFunction || collections.defaultCompare;
            this.nElements = 0;
        }
        add(element) {
            if (collections.isUndefined(element)) {
                return false;
            }
            if (this.insertNode(this.createNode(element)) !== null) {
                this.nElements++;
                return true;
            }
            return false;
        }
        clear() {
            this.root = null;
            this.nElements = 0;
        }
        isEmpty() {
            return this.nElements === 0;
        }
        size() {
            return this.nElements;
        }
        contains(element) {
            if (collections.isUndefined(element)) {
                return false;
            }
            return this.searchNode(this.root, element) !== null;
        }
        remove(element) {
            var node = this.searchNode(this.root, element);
            if (node === null) {
                return false;
            }
            this.removeNode(node);
            this.nElements--;
            return true;
        }
        inorderTraversal(callback) {
            this.inorderTraversalAux(this.root, callback, {
                stop: false
            });
        }
        preorderTraversal(callback) {
            this.preorderTraversalAux(this.root, callback, {
                stop: false
            });
        }
        postorderTraversal(callback) {
            this.postorderTraversalAux(this.root, callback, {
                stop: false
            });
        }
        levelTraversal(callback) {
            this.levelTraversalAux(this.root, callback);
        }
        minimum() {
            if (this.isEmpty()) {
                return undefined;
            }
            return this.minimumAux(this.root).element;
        }
        maximum() {
            if (this.isEmpty()) {
                return undefined;
            }
            return this.maximumAux(this.root).element;
        }
        forEach(callback) {
            this.inorderTraversal(callback);
        }
        toArray() {
            var array = [];
            this.inorderTraversal(function (element) {
                array.push(element);
                return true;
            });
            return array;
        }
        height() {
            return this.heightAux(this.root);
        }
        searchNode(node, element) {
            var cmp = null;
            while (node !== null && cmp !== 0) {
                cmp = this.compare(element, node.element);
                if (cmp < 0) {
                    node = node.leftCh;
                }
                else if (cmp > 0) {
                    node = node.rightCh;
                }
            }
            return node;
        }
        transplant(n1, n2) {
            if (n1.parent === null) {
                this.root = n2;
            }
            else if (n1 === n1.parent.leftCh) {
                n1.parent.leftCh = n2;
            }
            else {
                n1.parent.rightCh = n2;
            }
            if (n2 !== null) {
                n2.parent = n1.parent;
            }
        }
        removeNode(node) {
            if (node.leftCh === null) {
                this.transplant(node, node.rightCh);
            }
            else if (node.rightCh === null) {
                this.transplant(node, node.leftCh);
            }
            else {
                var y = this.minimumAux(node.rightCh);
                if (y.parent !== node) {
                    this.transplant(y, y.rightCh);
                    y.rightCh = node.rightCh;
                    y.rightCh.parent = y;
                }
                this.transplant(node, y);
                y.leftCh = node.leftCh;
                y.leftCh.parent = y;
            }
        }
        inorderTraversalAux(node, callback, signal) {
            if (node === null || signal.stop) {
                return;
            }
            this.inorderTraversalAux(node.leftCh, callback, signal);
            if (signal.stop) {
                return;
            }
            signal.stop = callback(node.element) === false;
            if (signal.stop) {
                return;
            }
            this.inorderTraversalAux(node.rightCh, callback, signal);
        }
        levelTraversalAux(node, callback) {
            var queue = new Queue();
            if (node !== null) {
                queue.enqueue(node);
            }
            while (!queue.isEmpty()) {
                node = queue.dequeue();
                if (callback(node.element) === false) {
                    return;
                }
                if (node.leftCh !== null) {
                    queue.enqueue(node.leftCh);
                }
                if (node.rightCh !== null) {
                    queue.enqueue(node.rightCh);
                }
            }
        }
        preorderTraversalAux(node, callback, signal) {
            if (node === null || signal.stop) {
                return;
            }
            signal.stop = callback(node.element) === false;
            if (signal.stop) {
                return;
            }
            this.preorderTraversalAux(node.leftCh, callback, signal);
            if (signal.stop) {
                return;
            }
            this.preorderTraversalAux(node.rightCh, callback, signal);
        }
        postorderTraversalAux(node, callback, signal) {
            if (node === null || signal.stop) {
                return;
            }
            this.postorderTraversalAux(node.leftCh, callback, signal);
            if (signal.stop) {
                return;
            }
            this.postorderTraversalAux(node.rightCh, callback, signal);
            if (signal.stop) {
                return;
            }
            signal.stop = callback(node.element) === false;
        }
        minimumAux(node) {
            while (node.leftCh !== null) {
                node = node.leftCh;
            }
            return node;
        }
        maximumAux(node) {
            while (node.rightCh !== null) {
                node = node.rightCh;
            }
            return node;
        }
        heightAux(node) {
            if (node === null) {
                return -1;
            }
            return Math.max(this.heightAux(node.leftCh), this.heightAux(node.rightCh)) + 1;
        }
        insertNode(node) {
            var parent = null;
            var position = this.root;
            var cmp = null;
            while (position !== null) {
                cmp = this.compare(node.element, position.element);
                if (cmp === 0) {
                    return null;
                }
                else if (cmp < 0) {
                    parent = position;
                    position = position.leftCh;
                }
                else {
                    parent = position;
                    position = position.rightCh;
                }
            }
            node.parent = parent;
            if (parent === null) {
                this.root = node;
            }
            else if (this.compare(node.element, parent.element) < 0) {
                parent.leftCh = node;
            }
            else {
                parent.rightCh = node;
            }
            return node;
        }
        createNode(element) {
            return {
                element: element,
                leftCh: null,
                rightCh: null,
                parent: null
            };
        }
    }
    collections.BSTree = BSTree;
})(collections || (collections = {}));
var U1;
(function (U1) {
    let UDistanceUnit;
    (function (UDistanceUnit) {
        UDistanceUnit[UDistanceUnit["Meter"] = 0] = "Meter";
        UDistanceUnit[UDistanceUnit["Feet"] = 1] = "Feet";
    })(UDistanceUnit = U1.UDistanceUnit || (U1.UDistanceUnit = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropertySelection extends U1.UProperty {
        get Items() {
            return this._items;
        }
        set Items(value) {
            this._items = value;
            this.InvokePropertyChanged("Items");
        }
    }
    U1.UPropertySelection = UPropertySelection;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropContainer extends U1.UPropertyBase {
        get Items() {
            if (this._items == null)
                this._items = [];
            return this._items;
        }
        get Path() {
            return (this.ParentContainer != null ? this.ParentContainer.Path : "") + "_" + this.Label;
        }
        get IsExpanded() {
            var path = this.Path;
            if (UPropContainer.s_isExpandeds[path] == null)
                UPropContainer.s_isExpandeds[path] = true;
            return UPropContainer.s_isExpandeds[path];
        }
        set IsExpanded(value) {
            UPropContainer.s_isExpandeds[this.Path] = value;
            this.InvokePropertyChanged("IsExpanded");
        }
        InvokePropertyChanged(prop = null) {
            super.InvokePropertyChanged();
            for (var ch of this.Items) {
                if (ch instanceof U1.UPropertyBase) {
                    ch.InvokePropertyChanged();
                }
            }
        }
        AddChild(other) {
            if (other instanceof UPropContainer) {
                for (var prop of other.Items
                    .map(o_ => o_)) {
                    var parent = this.Items
                        .filter(o_ => o_.Label == prop.Label)
                        .filter(o_ => o_.constructor == prop.constructor)[0];
                    if (parent != null)
                        parent.AddChild(prop);
                    else
                        this.Items.push(prop);
                }
            }
        }
        OnDisposing() {
            if (this.Items != null) {
                var items = this.Items.slice();
                for (var item of items) {
                    if (item.Dispose != null)
                        item.Dispose();
                }
            }
            if (this.ParentContainer != null) {
                var idx = this.ParentContainer.Items.indexOf(this);
                this.ParentContainer.Items.splice(idx, 1);
            }
            super.OnDisposing();
        }
    }
    UPropContainer.s_isExpandeds = {};
    U1.UPropContainer = UPropContainer;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropCategory extends U1.UPropContainer {
        static Categorize(props) {
            var result = new Array();
            for (var prop of props) {
                var category = result
                    .filter(o_ => o_.Label == prop.Category)[0];
                if (category == null) {
                    if (prop instanceof UPropCategory)
                        category = prop;
                    else {
                        category = new UPropCategory();
                        category.Label = prop.Category;
                    }
                    result.push(category);
                }
                if (category == prop)
                    continue;
                if (prop instanceof UPropCategory) {
                    category.AddChild(prop);
                    continue;
                }
                if (!(prop instanceof U1.UPropGroup) && (prop.Group == null || prop.Group == "")) {
                    var parent = category.Items
                        .filter(o_ => o_.Label == prop.Label)
                        .filter(o_ => o_.constructor == prop.constructor)[0];
                    if (parent != null)
                        parent.AddChild(prop);
                    else
                        category.Items.push(prop);
                    continue;
                }
                var group = category.Items
                    .filter(o_ => o_ instanceof U1.UPropGroup)
                    .filter((o_) => {
                    return o_.Label == prop.Group;
                })[0];
                if (group == null) {
                    if (prop instanceof U1.UPropGroup)
                        group = prop;
                    else {
                        group = new U1.UPropGroup();
                        group.Label = prop.Group;
                    }
                    group.ParentContainer = category;
                    category.Items.push(group);
                }
                if (group == prop)
                    continue;
                if (prop instanceof U1.UPropGroup) {
                    group.AddChild(prop);
                }
                else {
                    var parent = group.Items
                        .filter(o_ => o_.Label == prop.Label)
                        .filter(o_ => o_.constructor == prop.constructor)[0];
                    if (parent != null)
                        parent.AddChild(prop);
                    else
                        group.Items.push(prop);
                }
            }
            return result;
        }
        get Path() {
            return (this.CategoryGroup != null ? this.CategoryGroup.Path : "") + "_" + this.Label;
        }
    }
    U1.UPropCategory = UPropCategory;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropCategoryGroup extends U1.UPropContainer {
        get Path() {
            if (this.Label != null && this.Label.indexOf("[") > 0)
                return this.Label.substring(0, this.Label.indexOf('['));
            return this.Label;
        }
        get Categories() {
            return this.Items
                .filter(o_ => o_ instanceof U1.UPropCategory);
        }
        set Categories(value) {
            this._items = value;
            if (this._items != null) {
                for (var cat of value) {
                    cat.CategoryGroup = this;
                }
            }
        }
        static Categorize(selection) {
            var groupnames = new Array();
            var objcounts = {};
            var groups = {};
            var hasMany = selection.length > UPropCategoryGroup.MaxCount;
            for (var obj of selection) {
                var grpname = obj.GetUPropsCategory();
                if (grpname == null)
                    continue;
                var props = null;
                if (!hasMany)
                    props = obj.GetUProps();
                if (props != null) {
                    for (var i = 0; i < props.length; i++) {
                        if (props[i].Source == null)
                            props[i].Source = obj;
                    }
                }
                if (groups[grpname] == null) {
                    groupnames.push(grpname);
                    groups[grpname] = [];
                    objcounts[grpname] = 0;
                }
                objcounts[grpname] += 1;
                if (props != null)
                    groups[grpname] = groups[grpname].concat(props);
            }
            var result = new Array();
            for (var key of groupnames) {
                var props = groups[key];
                var count = objcounts[key];
                var group = new UPropCategoryGroup();
                group.Label = key + ((objcounts[key] == 1) ? "" : "[" + count + "]");
                if (props != null && props.length > 0)
                    group.Categories = U1.UPropCategory.Categorize(props);
                result.push(group);
            }
            return result;
        }
    }
    UPropCategoryGroup.MaxCount = 25;
    U1.UPropCategoryGroup = UPropCategoryGroup;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class UPropGroup extends U1.UPropContainer {
    }
    U1.UPropGroup = UPropGroup;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    let CullModeEnum;
    (function (CullModeEnum) {
        CullModeEnum[CullModeEnum["NONE"] = 0] = "NONE";
        CullModeEnum[CullModeEnum["CW"] = 1] = "CW";
        CullModeEnum[CullModeEnum["CCW"] = 2] = "CCW";
    })(CullModeEnum = U1.CullModeEnum || (U1.CullModeEnum = {}));
    let TextureAddressModeEnum;
    (function (TextureAddressModeEnum) {
        TextureAddressModeEnum[TextureAddressModeEnum["Wrap"] = 0] = "Wrap";
        TextureAddressModeEnum[TextureAddressModeEnum["Clamp"] = 1] = "Clamp";
        TextureAddressModeEnum[TextureAddressModeEnum["Mirror"] = 2] = "Mirror";
    })(TextureAddressModeEnum = U1.TextureAddressModeEnum || (U1.TextureAddressModeEnum = {}));
    let SnapTypeEnum;
    (function (SnapTypeEnum) {
        SnapTypeEnum[SnapTypeEnum["None"] = 0] = "None";
        SnapTypeEnum[SnapTypeEnum["Point"] = 1] = "Point";
        SnapTypeEnum[SnapTypeEnum["Edge"] = 2] = "Edge";
        SnapTypeEnum[SnapTypeEnum["MidEdge"] = 4] = "MidEdge";
        SnapTypeEnum[SnapTypeEnum["Face"] = 8] = "Face";
        SnapTypeEnum[SnapTypeEnum["Grid"] = 16] = "Grid";
        SnapTypeEnum[SnapTypeEnum["Angle"] = 32] = "Angle";
    })(SnapTypeEnum = U1.SnapTypeEnum || (U1.SnapTypeEnum = {}));
    let SnapTargetEnum;
    (function (SnapTargetEnum) {
        SnapTargetEnum[SnapTargetEnum["None"] = 0] = "None";
        SnapTargetEnum[SnapTargetEnum["Curve"] = 1] = "Curve";
        SnapTargetEnum[SnapTargetEnum["Surface"] = 2] = "Surface";
        SnapTargetEnum[SnapTargetEnum["Grid"] = 4] = "Grid";
    })(SnapTargetEnum = U1.SnapTargetEnum || (U1.SnapTargetEnum = {}));
    let VerticalAlignment;
    (function (VerticalAlignment) {
        VerticalAlignment[VerticalAlignment["Top"] = 0] = "Top";
        VerticalAlignment[VerticalAlignment["Center"] = 1] = "Center";
        VerticalAlignment[VerticalAlignment["Bottom"] = 2] = "Bottom";
        VerticalAlignment[VerticalAlignment["Stretch"] = 3] = "Stretch";
    })(VerticalAlignment = U1.VerticalAlignment || (U1.VerticalAlignment = {}));
    let MappingTypeEnum;
    (function (MappingTypeEnum) {
        MappingTypeEnum[MappingTypeEnum["RealWorldSize"] = 0] = "RealWorldSize";
        MappingTypeEnum[MappingTypeEnum["SurfaceSize"] = 1] = "SurfaceSize";
    })(MappingTypeEnum = U1.MappingTypeEnum || (U1.MappingTypeEnum = {}));
    ;
    class ISectInfo {
        constructor() {
            this.IsectPosition = new U1.Vector3();
            this.IsectNormal = new U1.Vector3();
            this.UV = new U1.Vector2();
        }
        Clone() {
            var clone = new ISectInfo();
            clone.Source = this.Source;
            clone.Geometry = this.Geometry;
            clone.Distance = this.Distance;
            if (this.IsectPosition != null)
                clone.IsectPosition.CopyFrom(this.IsectPosition);
            if (this.IsectNormal != null)
                clone.IsectNormal.CopyFrom(this.IsectNormal);
            clone.Snap = this.Snap;
            clone.FaceID = this.FaceID;
            clone.Attr = this.Attr;
            clone.Tag = this.Tag;
            if (this.Pos != null) {
                clone.Pos = new Array(this.Pos.length);
                this.Pos.forEach((e_, i_) => {
                    clone.Pos[i_] = e_.Clone();
                });
            }
            if (this.UV0 != null) {
                clone.UV0 = new Array(this.UV0.length);
                this.UV0.forEach((e_, i_) => {
                    clone.UV0[i_] = e_.Clone();
                });
            }
            return clone;
        }
        CompareTo(other) {
            if (this.Distance == other.Distance)
                return 0;
            if (this.Distance < other.Distance)
                return -1;
            return 1;
        }
        Reset() {
            this.Source = undefined;
            this.Geometry = undefined;
            this.Distance = undefined;
            this.IsectPosition.Set(0, 0, 0);
            this.IsectNormal.Set(0, 0, 0);
            this.Snap = undefined;
            this.FaceID = undefined;
            this.Attr = undefined;
            this.Pos = undefined;
            this.UV0 = undefined;
            this.S = undefined;
            this.T = undefined;
            this.Tag = undefined;
        }
    }
    U1.ISectInfo = ISectInfo;
    class SnapConfig {
        static AddListener(listener) {
            if (SnapConfig.s_listeners.indexOf(listener) < 0)
                SnapConfig.AddListener(listener);
        }
        static RemoveListener(listener) {
            var idx = SnapConfig.s_listeners.indexOf(listener);
            if (idx >= 0)
                SnapConfig.s_listeners.splice(idx, 1);
        }
        static UseSnapChanged() {
            SnapConfig.s_listeners.forEach((e_) => {
                if (e_.OnUseSnapChanged != null)
                    e_.OnUseSnapChanged();
            });
        }
        static SnapChanged() {
            SnapConfig.s_listeners.forEach((e_) => {
                if (e_.OnSnapChanged != null)
                    e_.OnSnapChanged();
            });
        }
        static AngleSnapChanged() {
            SnapConfig.s_listeners.forEach((e_) => {
                if (e_.OnAngleSnapChanged != null)
                    e_.OnAngleSnapChanged();
            });
        }
        static GridSnapChanged() {
            SnapConfig.s_listeners.forEach((e_) => {
                if (e_.OnGridSnapChanged != null)
                    e_.OnGridSnapChanged();
            });
        }
        static DistSnapChanged() {
            SnapConfig.s_listeners.forEach((e_) => {
                if (e_.OnDistSnapChanged != null)
                    e_.OnDistSnapChanged();
            });
        }
        static SnapTargetChanged() {
            SnapConfig.s_listeners.forEach((e_) => {
                if (e_.OnSnapTargetChanged != null)
                    e_.OnSnapTargetChanged();
            });
        }
        static get UseSnap() {
            return SnapConfig.m_useSnap;
        }
        static set UseSnap(value) {
            if (SnapConfig.m_useSnap == value)
                return;
            SnapConfig.m_useSnap = value;
            SnapConfig.UseSnapChanged();
        }
        static get Snap() {
            return SnapConfig.m_snap;
        }
        static set Snap(value) {
            if (SnapConfig.m_snap == value)
                return;
            SnapConfig.m_snap = value;
            SnapConfig.SnapChanged();
        }
        static get SnapTarget() {
            return SnapConfig.m_snapTarget;
        }
        static set SnapTarget(value) {
            if (SnapConfig.m_snapTarget == value)
                return;
            SnapConfig.m_snapTarget = value;
            SnapConfig.SnapTargetChanged();
        }
        static GetSnap(snap) {
            return SnapConfig.UseSnap && (SnapConfig.Snap & snap) == snap;
        }
        static GetSnapTarget(target) {
            return (SnapConfig.m_snapTarget & target) == target;
        }
        static SetSnap(snap, state) {
            if (state)
                SnapConfig.Snap = SnapConfig.Snap | snap;
            else
                SnapConfig.Snap = SnapConfig.Snap & (~snap);
        }
        static SetSnapTarget(target, state) {
            if (state)
                SnapConfig.SnapTarget = SnapConfig.SnapTarget | target;
            else
                SnapConfig.SnapTarget = SnapConfig.SnapTarget & (~target);
        }
        static get AngelSnap() {
            return SnapConfig.m_angleSnap;
        }
        static set AngelSnap(value) {
            if (SnapConfig.m_angleSnap == value)
                return;
            SnapConfig.m_angleSnap = value;
            SnapConfig.AngleSnapChanged();
        }
        static get GridSnap() {
            return SnapConfig.m_gridSnap;
        }
        static set GridSnap(value) {
            if (SnapConfig.m_gridSnap == value)
                return;
            SnapConfig.m_gridSnap = value;
            SnapConfig.GridSnapChanged();
        }
        static get SnapPixel() {
            return SnapConfig.m_snapPixel;
        }
        static set SnapPixel(value) {
            SnapConfig.m_snapPixel = value;
        }
        static get DistSnap() {
            return SnapConfig.m_distSnap;
        }
        static set DistSnap(value) {
            if (SnapConfig.m_distSnap == value)
                return;
            SnapConfig.m_distSnap = value;
            SnapConfig.DistSnapChanged();
        }
        static WithinSnapPixel(mouse, px, py) {
            var num2 = mouse.X - px;
            var num = mouse.Y - py;
            return ((num2 * num2) + (num * num)) <= SnapConfig.SnapPixel * SnapConfig.SnapPixel;
        }
        static GetSnapedDist(dist) {
            if (!SnapConfig.UseSnap || !SnapConfig.GetSnap(SnapTypeEnum.Grid))
                return;
            dist = Math.round(dist / SnapConfig.DistSnap) * SnapConfig.DistSnap;
        }
        static GetGridSnapedPoint(plane, point) {
            if (!SnapConfig.UseSnap || !SnapConfig.GetSnap(SnapTypeEnum.Grid))
                return;
            var orign = plane.Normal.Clone().Scale(-plane.D);
            var xdir = U1.Vector3.Zero, ydir = U1.Vector3.Zero;
            U1.GeometryHelper3.GetArbitraryAxis(plane.Normal, xdir, ydir);
            SnapConfig.GetGridSnapedPointGrid(orign, xdir, ydir, point);
        }
        static GetGridSnapedPointGrid(grdOrign, grdX, grdY, point) {
            if (!SnapConfig.UseSnap || !SnapConfig.GetSnap(SnapTypeEnum.Grid))
                return;
            var v = U1.Vector3.Subtract(point, grdOrign);
            var x = U1.Vector3.Dot(v, grdX);
            var y = U1.Vector3.Dot(v, grdY);
            x = Math.round(x / SnapConfig.GridSnap) * SnapConfig.GridSnap;
            y = Math.round(y / SnapConfig.GridSnap) * SnapConfig.GridSnap;
            point.CopyFrom(grdOrign)
                .Add(U1.Vector3.Scale(grdX, x))
                .Add(U1.Vector3.Scale(grdY, y));
        }
    }
    SnapConfig.s_listeners = new Array();
    SnapConfig.m_snap = SnapTypeEnum.Grid | SnapTypeEnum.Point | SnapTypeEnum.Angle;
    SnapConfig.m_snapTarget = SnapTargetEnum.Grid | SnapTargetEnum.Curve | SnapTargetEnum.Surface;
    SnapConfig.m_useSnap = true;
    SnapConfig.m_angleSnap = 5;
    SnapConfig.m_gridSnap = 0.1;
    SnapConfig.m_distSnap = 0.01;
    SnapConfig.m_snapPixel = 10;
    U1.SnapConfig = SnapConfig;
    class MeshMaterial {
        constructor() {
            this._id = MeshMaterial._id++;
            this.Ambient = new U1.Color(50, 50, 50);
            this.Diffuse = U1.Colors.LightGray;
            this.Specular = U1.Colors.LightGray;
            this.Emissive = U1.Colors.Black;
            this.SpecularPower = 200;
            this.DiffuseTexture = new Texture();
            this.Cull = CullModeEnum.CW;
            this.Opacity = 1;
            this.Pickable = true;
        }
        get ID() {
            return this._id;
        }
        get Pickable() {
            return (this.Flag & 1) != 1;
        }
        set Pickable(value) {
            if (value)
                this.Flag = this.Flag & ~1;
            else
                this.Flag = this.Flag | 1;
        }
        get AlwaysZWrite() {
            return (this.Flag & 2) == 2;
        }
        set AlwaysZWrite(value) {
            if (value)
                this.Flag = this.Flag & ~2;
            else
                this.Flag = this.Flag | 2;
        }
        Clone() {
            var result = new MeshMaterial();
            result.Diffuse.CopyFrom(this.Diffuse);
            result.Ambient.CopyFrom(this.Ambient);
            result.Emissive.CopyFrom(this.Emissive);
            result.Specular.CopyFrom(this.Specular);
            result.SpecularPower = this.SpecularPower;
            result.DiffuseTexture = this.DiffuseTexture;
            result.Cull = this.Cull;
            result.Flag = this.Flag;
            result.Tag = this.Tag;
            result.Opacity = this.Opacity;
            if (this.DiffuseTexture != null) {
                result.DiffuseTexture = this.DiffuseTexture.Clone();
            }
            return result;
        }
    }
    MeshMaterial._id = 0;
    U1.MeshMaterial = MeshMaterial;
    class Material extends U1.UNode {
        constructor() {
            super(...arguments);
            this.ambient = U1.Colors.LightGray;
            this.diffuse = U1.Colors.LightGray;
            this.specular = U1.Colors.White;
            this.emissive = U1.Colors.Black;
            this.shininess = 300;
            this.texOffset = U1.Vector2.Zero;
            this.texScale = U1.Vector2.One;
            this.texRotate = 0;
            this.opacity = 1;
        }
        get Ambient() {
            return this.ambient;
        }
        set Ambient(value) {
            this.SetProperty("Ambient", "ambient", value);
        }
        get Diffuse() {
            return this.diffuse;
        }
        set Diffuse(value) {
            this.SetProperty("Diffuse", "diffuse", value);
        }
        get Specular() {
            return this.specular;
        }
        set Specular(value) {
            this.SetProperty("Specular", "specular", value);
        }
        get Emissive() {
            return this.emissive;
        }
        set Emissive(value) {
            this.SetProperty("Emissive", "emissive", value);
        }
        get Shininess() {
            return this.shininess;
        }
        set Shininess(value) {
            this.SetProperty("Shininess", "shininess", value);
        }
        get TexOffset() {
            return this.texOffset;
        }
        set TexOffset(value) {
            this.SetProperty("TexOffset", "texOffset", value);
        }
        get TexScale() {
            return this.texScale;
        }
        set TexScale(value) {
            this.SetProperty("TexScale", "texScale", value);
        }
        get TexRotate() {
            return this.texRotate;
        }
        set TexRotate(value) {
            this.SetProperty("TexRotate", "texRotate", value);
        }
        get TexMirrU() {
            return this.texMirrU;
        }
        set TexMirrU(value) {
            this.SetProperty("TexMirrU", "texMirrU", value);
        }
        get TexMirrV() {
            return this.texMirrV;
        }
        set TexMirrV(value) {
            this.SetProperty("TexMirrV", "texMirrV", value);
        }
        get Opacity() {
            return this.opacity;
        }
        set Opacity(value) {
            this.SetProperty("Opacity", "opacity", value);
        }
        get DiffuseTexture() {
            return this.diffuseTexture;
        }
        set DiffuseTexture(value) {
            this.SetProperty("DiffuseTexture", "diffuseTexture", value);
        }
        get RefElement() {
            return this.GetInverse(U1.UElement, "Material");
        }
        get RefCount() {
            return this.GetInverse(U1.UElement, "Material").length;
        }
        Read(meshMaterial) {
            this.Ambient = meshMaterial.Ambient;
            this.Diffuse = meshMaterial.Diffuse;
            this.Specular = meshMaterial.Specular;
            this.Emissive = meshMaterial.Emissive;
            this.Shininess = meshMaterial.SpecularPower;
            this.TexOffset = meshMaterial.DiffuseTexture.Offset;
            this.TexScale = meshMaterial.DiffuseTexture.Scale;
            this.TexRotate = meshMaterial.DiffuseTexture.Rotate;
            this.Opacity = meshMaterial.Opacity;
            this.DiffuseTexture = meshMaterial.DiffuseTexture.Url;
        }
        GetMeshMaterial() {
            var result = new MeshMaterial();
            result.Ambient = this.Ambient;
            result.Diffuse = this.Diffuse;
            result.Specular = this.Specular;
            result.Emissive = this.Emissive;
            result.SpecularPower = this.Shininess;
            result.Opacity = this.Opacity;
            var texture = new Texture();
            texture.Offset = this.TexOffset;
            texture.Scale = this.TexScale;
            texture.Rotate = this.TexRotate;
            texture.Url = this.DiffuseTexture;
            result.DiffuseTexture = texture;
            return result;
        }
    }
    U1.Material = Material;
    class MaterialSet extends U1.UItemSet {
    }
    U1.MaterialSet = MaterialSet;
    class Texture {
        constructor() {
            this.Offset = U1.Vector2.Zero;
            this.Scale = U1.Vector2.One;
            this.Rotate = 0;
            this.AddressU = TextureAddressModeEnum.Wrap;
            this.AddressV = TextureAddressModeEnum.Wrap;
            this.AddressW = TextureAddressModeEnum.Wrap;
        }
        Clone() {
            var result = new Texture();
            result.Offset.CopyFrom(this.Offset);
            result.Scale.CopyFrom(this.Scale);
            result.Rotate = this.Rotate;
            result.AddressU = this.AddressU;
            result.AddressV = this.AddressV;
            result.AddressW = this.AddressW;
            return result;
        }
    }
    U1.Texture = Texture;
    class MTexture extends U1.UNode {
    }
    U1.MTexture = MTexture;
    class TextureSet extends U1.UItemSet {
    }
    U1.TextureSet = TextureSet;
    class Geometry {
        constructor() {
            this._isBoundingInvalid = true;
            this._boundingBox = new U1.BoundingBox();
            this._boundingSphere = new U1.BoundingSphere();
            this._id = ++Geometry._id;
        }
        get ID() {
            return this._id;
        }
        get BoundingBox() {
            if (this._isBoundingInvalid) {
                this.UpdateBounding(this._boundingBox, this._boundingSphere);
                this._isBoundingInvalid = false;
            }
            return this._boundingBox;
        }
        get BoundingSphere() {
            if (this._isBoundingInvalid) {
                this.UpdateBounding(this._boundingBox, this._boundingSphere);
                this._isBoundingInvalid = false;
            }
            return this._boundingSphere;
        }
        UpdateBounding(boundingBox, boundingSphere) {
        }
        MarkChanged() {
            this._isBoundingInvalid = true;
        }
        GetSnapedPoint(mouse, transform, camera) {
            return null;
        }
        IsInside(planes, checkCross) {
            return false;
        }
        IntersectW(ray, worldM) {
            return null;
        }
        Intersect(ray) {
            return null;
        }
        BeginAppend() {
        }
        EndAppend() {
        }
    }
    Geometry._id = 0;
    U1.Geometry = Geometry;
    class ISectContext {
        constructor(view, ray, maxDistance) {
            this.PickDist = 8;
            this.ScreenWithinSq = 36;
            this.View = view;
            this.Ray = ray;
            this.MaxDistance = this._maxDistance = maxDistance;
        }
        WorldToScreen(world) {
            if (this.WorldToScreenFunc == null)
                return null;
            return this.WorldToScreenFunc(world);
        }
        CanPickable(p, transform = null) {
            var wp = p;
            if (transform != null)
                wp = wp.Clone().Transform(transform);
            var sp = this.WorldToScreen(p);
            if (sp == null) {
                var v1 = U1.Vector3.Subtract(wp, this.Ray.Position);
                var dt = U1.Vector3.Dot(v1, this.Ray.Direction);
                var mp = U1.Vector3.ScaleAdd(this.Ray.Position, dt, this.Ray.Direction, v1);
                if (U1.Vector3.Distance(mp, p) < 0.1)
                    return true;
            }
            else {
                if (U1.Vector2.Distance(sp.XY(), this.View) <= this.PickDist)
                    return true;
            }
            return false;
        }
        IsLineIsect(pOnRay, pOnObject, lineWidth) {
            lineWidth /= 2;
            var dist = U1.Vector3.DistanceSquared(pOnRay, pOnObject);
            if (dist >= this.ScreenWithinSq + (lineWidth * lineWidth))
                return false;
            if (this.WorldToScreenFunc != null) {
                var p1 = new U1.Vector3();
                var p2 = new U1.Vector3();
                p1 = this.WorldToScreenFunc(pOnRay);
                p2 = this.WorldToScreenFunc(pOnObject);
                dist = U1.Vector3.DistanceSquared(p1, p2);
                if (dist >= (lineWidth * lineWidth))
                    return false;
            }
            else {
                dist = U1.Vector3.DistanceSquared(pOnRay, pOnObject);
                if (dist >= (lineWidth * lineWidth))
                    return false;
            }
            return true;
        }
        AddIntersect(isect) {
            if (this.Result == null || isect.Distance < this.MaxDistance) {
                this.MaxDistance = isect.Distance;
                this.Result = isect;
            }
        }
        ClearResults() {
            this.MaxDistance = this._maxDistance;
            this.Result = null;
        }
    }
    U1.ISectContext = ISectContext;
    class ContainContext {
        get SelectionPlanes() {
            if (this._selectionPlanes == null) {
                var planes = [
                    U1.Plane.FromTriangle(this.SelectionBoxConers[0], this.SelectionBoxConers[6], this.SelectionBoxConers[1]),
                    U1.Plane.FromTriangle(this.SelectionBoxConers[0], this.SelectionBoxConers[1], this.SelectionBoxConers[2]),
                    U1.Plane.FromTriangle(this.SelectionBoxConers[2], this.SelectionBoxConers[3], this.SelectionBoxConers[4]),
                    U1.Plane.FromTriangle(this.SelectionBoxConers[4], this.SelectionBoxConers[7], this.SelectionBoxConers[6]),
                ];
                this._selectionPlanes = planes;
            }
            return this._selectionPlanes;
        }
    }
    U1.ContainContext = ContainContext;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class LineBufferGeometry extends U1.Geometry {
        get pos() {
            return this._pos;
        }
        set pos(value) {
            this._pos = value;
            this.MarkChanged();
        }
        get indices() {
            return this._indices;
        }
        set indices(value) {
            this._indices = value;
            this.MarkChanged();
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
            this.MarkChanged();
        }
        get hasColor() {
            return this.color != undefined && this.color.length > 0;
        }
        get PointCount() {
            return this._pos == null ? 0 : this._pos.length / 3;
        }
        get IndexCount() {
            if (this._indices == null)
                return 0;
            return this._indices.length;
        }
        UpdateBounding(boundingBox, boundingSphere) {
            if (this._pos == null || this._pos.length == 0)
                return;
            var min = LineBufferGeometry[".ub.min"] || (LineBufferGeometry[".ub.min"] = new U1.Vector3());
            var max = LineBufferGeometry[".ub.max"] || (LineBufferGeometry[".ub.max"] = new U1.Vector3());
            min.SetMaxValue();
            max.SetMinValue();
            var bf_pos = this._pos;
            var num_pos = bf_pos.length;
            for (var i = 0; i < num_pos; i += 3) {
                var x = bf_pos[i];
                var y = bf_pos[i + 1];
                var z = bf_pos[i + 2];
                if (x < min.X)
                    min.X = x;
                if (y < min.Y)
                    min.Y = y;
                if (z < min.Z)
                    min.Z = z;
                if (x > max.X)
                    max.X = x;
                if (y > max.Y)
                    max.Y = y;
                if (z > max.Z)
                    max.Z = z;
            }
            boundingBox.Min.CopyFrom(min);
            boundingBox.Max.CopyFrom(max);
            boundingSphere.Center.SetAdd(min, max).Scale(0.5);
            boundingSphere.Radius = U1.Vector3.Distance(min, max) / 2;
        }
        IsInside(planes, fCross) {
            var c_In = 0;
            if (this.PointCount == 0 || this.IndexCount == 0)
                return false;
            var bsphere = this.BoundingSphere;
            for (var i = 0; i < planes.length; i++) {
                var len = planes[i].DotCoordinate(bsphere.Center);
                if (len <= -bsphere.Radius)
                    ++c_In;
                else if (len > bsphere.Radius)
                    return false;
            }
            if (c_In == planes.length)
                return true;
            var bf_pos = this._pos;
            var bf_indices = this._indices;
            var num_pos = bf_pos.length;
            var num_indices = bf_indices.length;
            var vp = LineBufferGeometry[".iis.vp"] || (LineBufferGeometry[".iis.vp"] = new U1.Vector3());
            var p0 = LineBufferGeometry[".iis.p0"] || (LineBufferGeometry[".iis.p0"] = new U1.Vector3());
            var p1 = LineBufferGeometry[".iis.p1"] || (LineBufferGeometry[".iis.p1"] = new U1.Vector3());
            for (var vi = 0; vi < num_pos; vi++) {
                c_In = 0;
                vp.Set(bf_pos[vi], bf_pos[vi + 1], bf_pos[vi + 2]);
                for (var pi = 0; pi < planes.length; pi++) {
                    var len = planes[pi].DotCoordinate(vp);
                    if (len <= 0)
                        c_In++;
                }
                if (fCross && c_In == planes.length)
                    return true;
                if (!fCross && c_In < planes.length)
                    return false;
            }
            if (fCross) {
                for (var i = 0; i < num_indices; i += 2) {
                    var i0 = bf_indices[i];
                    var i1 = bf_indices[i + 1];
                    p0.Set(bf_pos[i0 * 2], bf_pos[i0 * 2 + 1], bf_pos[i0 * 2 + 2]);
                    p1.Set(bf_pos[i1 * 2], bf_pos[i1 * 2 + 1], bf_pos[i1 * 2 + 2]);
                    if (U1.MeshUtil.CheckEdgeCross(planes, p0, p1))
                        return true;
                }
                return false;
            }
            return true;
        }
        GetSnapedPoint(mouse, transform, camera) {
            var ray = LineBufferGeometry[".gsp.ray"] || (LineBufferGeometry[".gsp.ray"] = new U1.Ray3());
            var wray = LineBufferGeometry[".gsp.wray"] || (LineBufferGeometry[".gsp.wray"] = new U1.Ray3());
            var invm = LineBufferGeometry[".gsp.invm"] || (LineBufferGeometry[".gsp.invm"] = new U1.Matrix4());
            var bbx = LineBufferGeometry[".gsp.bbx"] || (LineBufferGeometry[".gsp.bbx"] = new U1.BoundingBox());
            var size = LineBufferGeometry[".gsp.size"] || (LineBufferGeometry[".gsp.size"] = new U1.Vector3());
            var p0 = LineBufferGeometry[".gsp.p0"] || (LineBufferGeometry[".gsp.p0"] = new U1.Vector3());
            var p1 = LineBufferGeometry[".gsp.p1"] || (LineBufferGeometry[".gsp.p1"] = new U1.Vector3());
            var p2 = LineBufferGeometry[".gsp.p2"] || (LineBufferGeometry[".gsp.p2"] = new U1.Vector3());
            var indices = this._indices;
            ray = camera.CalPickingRay(mouse.X, mouse.Y, ray);
            wray.CopyFrom(ray);
            ray.Transform(U1.Matrix4.Invert(transform, invm));
            ray.Direction.Normalize();
            bbx.CopyFrom(this.BoundingBox);
            size = size.SetSubtract(bbx.Max, bbx.Min);
            size.Scale(0.1);
            bbx.Max.Add(size);
            bbx.Min.Subtract(size);
            if (bbx.IntersectsRay(ray) == null)
                return null;
            var isectP = U1.Vector3.Zero;
            var minDist = U1.SnapConfig.SnapPixel * U1.SnapConfig.SnapPixel;
            var minDepth = Number.MAX_VALUE;
            var tE = 0.0;
            var fid = 0;
            var v0 = 0, v1 = 0;
            var s, t;
            var dir = U1.Vector3.Zero;
            var res = { s: 0, t: 0 };
            var wp = U1.Vector3.Zero;
            var num_pos = this._pos.length;
            var pos_bf = this._pos;
            var num_indices = this._indices.length;
            var indices = this._indices;
            for (var i = 0; i < num_indices - 1; i += 2) {
                var i0 = indices[i] * 3;
                var i1 = indices[i + 1] * 3;
                p0.Set(pos_bf[i0], pos_bf[i0 + 1], pos_bf[i0 + 2]);
                p1.Set(pos_bf[i1], pos_bf[i1 + 1], pos_bf[i1 + 2]);
                dir.SetSubtract(p1, p0);
                U1.Line3.SquardDistance1(ray.Position, ray.Direction, p0, dir, res);
                if (s < minDepth && t >= -0.001 && t <= 1.001) {
                    wp.SetScaleAdd(p0, t, dir);
                    wp.Transform(transform);
                    var scn = camera.WorldToScreen(wp);
                    var dist = U1.Vector2.DistanceSquared(scn.XY(), mouse);
                    if (dist <= minDist) {
                        minDepth = s;
                        minDist = dist;
                        isectP = wp;
                        fid = (i / 2);
                        v0 = indices[i];
                        v1 = indices[i + 1];
                        tE = t;
                    }
                }
            }
            if (v0 != v1) {
                var isect = new U1.ISectInfo();
                isect.Distance = U1.Vector3.Distance(isectP, wray.Position);
                isect.Snap = U1.SnapTypeEnum.Edge;
                isect.IsectNormal.SetUnitZ();
                isect.IsectPosition.CopyFrom(isectP);
                isect.FaceID = (fid);
                p0.Set(pos_bf[v0 * 3], pos_bf[v0 * 3 + 1], pos_bf[v0 * 3 + 2]);
                p1.Set(pos_bf[v1 * 3], pos_bf[v1 * 3 + 1], pos_bf[v1 * 3 + 2]);
                if (U1.SnapConfig.GetSnap(U1.SnapTypeEnum.MidEdge)) {
                    var cp = U1.Vector3.Add(p0, p1, p2).Scale(1 / 2);
                    wp = U1.Vector3.Transform(cp, transform);
                    cp = camera.WorldToScreen(wp);
                    if (U1.SnapConfig.WithinSnapPixel(mouse, cp.X, cp.Y)) {
                        isect.IsectPosition = wp;
                        isect.Snap = U1.SnapTypeEnum.MidEdge;
                    }
                }
                if (U1.SnapConfig.GetSnap(U1.SnapTypeEnum.Point)) {
                    for (var p of [p0, p1]) {
                        var wp = U1.Vector3.Transform(p, transform);
                        var sp = camera.WorldToScreen(wp, p2);
                        if (U1.SnapConfig.WithinSnapPixel(mouse, sp.X, sp.Y)) {
                            isect.IsectPosition = wp;
                            isect.Snap = U1.SnapTypeEnum.Point;
                        }
                    }
                }
                if (isect.Snap == U1.SnapTypeEnum.Edge && (tE < 0 || tE > 1))
                    return null;
                isect.Distance = U1.Vector3.Distance(camera.Position, isect.IsectPosition);
                return isect;
            }
            return null;
        }
        Transform(matrix) {
            var p = LineBufferGeometry[".trs.p"] || (LineBufferGeometry[".trs.p"] = new U1.Vector3());
            var bf_pos = this._pos;
            var num_pos = bf_pos.length;
            for (var i = 0; i < num_pos; i += 3) {
                p.X = bf_pos[i];
                p.Y = bf_pos[i + 1];
                p.Z = bf_pos[i + 2];
                p.Transform(matrix);
                bf_pos[i] = p.X;
                bf_pos[i + 1] = p.Y;
                bf_pos[i + 2] = p.Z;
            }
            return this;
        }
        BeginAppend() {
            this.tmp_pos = [];
            this.tmp_col = [];
            this.tmp_idx = [];
        }
        EndAppend() {
            var vlast = this.PointCount;
            if (this.pos != null) {
                let vals = new Array(this.pos.length + this.tmp_pos.length);
                var vi = 0;
                for (var i = 0; i < this.pos.length; i++, vi++)
                    vals[vi] = this.pos[i];
                for (var i = 0; i < this.tmp_pos.length; i++, vi++)
                    vals[vi] = this.tmp_pos[i];
                this.tmp_pos = vals;
            }
            if (this.indices != null) {
                let vals = new Array(this.indices.length + this.tmp_idx.length);
                var vi = 0;
                for (var i = 0; i < this.indices.length; i++, vi++)
                    vals[vi] = this.indices[i];
                for (var i = 0; i < this.tmp_idx.length; i++, vi++)
                    vals[vi] = this.tmp_idx[i] + vlast;
                this.tmp_idx = vals;
            }
            if (this.color != null) {
                let vals = new Array(this.color.length + this.tmp_idx.length);
                var vi = 0;
                for (var i = 0; i < this.color.length; i++, vi++)
                    vals[vi] = this.color[i];
                for (var i = 0; i < this.tmp_col.length; i++, vi++)
                    vals[vi] = this.tmp_col[i];
                this.tmp_col = vals;
            }
            if (this.tmp_pos.length > 0)
                this.pos = new Float32Array(this.tmp_pos);
            else
                this.pos = null;
            if (this.tmp_col.length > 0)
                this.color = new Float32Array(this.tmp_col);
            else
                this.color = null;
            if (this.tmp_idx.length > 0)
                this.indices = new Uint16Array(this.tmp_idx);
            else
                this.indices = null;
            this.tmp_pos = undefined;
            this.tmp_col = undefined;
            this.tmp_idx = undefined;
        }
        AppendLine(p0, p1, xform) {
            var tv0 = LineBufferGeometry[".apl.v0"] || (LineBufferGeometry[".apl.v0"] = new U1.Vector3());
            var pos = this.tmp_pos;
            var idx = this.tmp_idx;
            var si = pos.length / 3;
            if (xform !== undefined) {
                p0 = tv0.CopyFrom(p0).Transform(xform);
                pos.push(p0.X);
                pos.push(p0.Y);
                pos.push(p0.Z);
                p1 = tv0.CopyFrom(p1).Transform(xform);
                pos.push(p1.X);
                pos.push(p1.Y);
                pos.push(p1.Z);
            }
            else {
                pos.push(p0.X);
                pos.push(p0.Y);
                pos.push(p0.Z);
                pos.push(p1.X);
                pos.push(p1.Y);
                pos.push(p1.Z);
            }
            idx.push(si);
            idx.push(si + 1);
        }
        AddppendPolygon(points, xform) {
            var tv0 = LineBufferGeometry[".app.v0"] || (LineBufferGeometry[".app.v0"] = new U1.Vector3());
            var pos = this.tmp_pos;
            var idx = this.tmp_idx;
            var si = pos.length / 3;
            var ei = si;
            var ci = si;
            for (var i = 0; i < points.length; i++, ci++) {
                var p0 = points[i];
                if (xform !== undefined) {
                    p0 = tv0.CopyFrom(p0).Transform(xform);
                }
                pos.push(p0.X);
                pos.push(p0.Y);
                pos.push(p0.Z);
                if (i > 0) {
                    idx.push(ci - 1);
                    idx.push(ci);
                    ei = ci;
                }
            }
            idx.push(ei);
            idx.push(si);
        }
        AddppendPolyline(points, xform) {
            var tv0 = LineBufferGeometry[".appl.v0"] || (LineBufferGeometry[".appl.v0"] = new U1.Vector3());
            var pos = this.tmp_pos;
            var idx = this.tmp_idx;
            var si = pos.length / 3;
            var ci = si;
            for (var i = 0; i < points.length; i++, ci++) {
                var p0 = points[i];
                if (xform !== undefined) {
                    p0 = tv0.CopyFrom(p0).Transform(xform);
                }
                pos.push(p0.X);
                pos.push(p0.Y);
                pos.push(p0.Z);
                if (i > 0) {
                    idx.push(ci - 1);
                    idx.push(ci);
                }
            }
        }
        CopyFrom(other) {
            this.pos = other.pos != null ? new Float32Array(other.pos) : null;
            this.color = other.color != null ? new Float32Array(other.color) : null;
            this.indices = other.indices != null ? new Uint16Array(other.indices) : null;
            return this;
        }
        Clone() {
            var result = new LineBufferGeometry();
            result.CopyFrom(this);
            return result;
        }
        static Merges(lines) {
            var pos = [];
            var color = [];
            var indices = [];
            var fcolor = lines.filter(o_ => o_.hasColor).length > 0;
            var attr = 0;
            for (var i = 0; i < lines.length; i++, attr++) {
                var geom = lines[i];
                var vstart = pos.length / 2;
                var fstart = indices.length / 2;
                pos.AddRange(geom.pos);
                if (fcolor) {
                    if (geom.color != null) {
                        color.AddRange(geom.color);
                    }
                    else {
                        for (var j = 0; j < geom.pos.length; j++) {
                            color.push(0);
                        }
                    }
                }
                if (geom.indices != null)
                    indices.AddRange(geom.indices);
                var fend = indices.length / 2;
            }
            var result = new LineBufferGeometry();
            result.pos = new Float32Array(pos);
            if (fcolor)
                result.color = new Float32Array(color);
            result.indices = new Uint16Array(indices);
            return result;
        }
        Merge(other, m) {
            if (m !== undefined) {
                other = other.Clone().Transform(m);
            }
            var result = LineBufferGeometry.Merges([this, other]);
            this.CopyFrom(result);
            return this;
        }
    }
    U1.LineBufferGeometry = LineBufferGeometry;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class LineGeometry extends U1.Geometry {
        get PointCount() {
            return this.Points == null ? 0 : this.Points.length;
        }
        get IndexCount() {
            if (this.Indexes == null)
                return 0;
            return this.Indexes.length;
        }
        SetColor(color) {
            if (this.Points == null)
                return;
            for (var i = 0; i < this.Points.length; i++) {
                this.Points[i].Color.CopyFrom(color);
            }
        }
        UpdateBounding(boundingBox, boundingSphere) {
            if (this.Points == null || this.Points.length == 0)
                return;
            var min = U1.Vector3.MaxValue;
            var max = U1.Vector3.MinValue;
            this.Points.forEach((v_, i_, arr_) => {
                min.Minimize(v_.Position);
                max.Maximize(v_.Position);
            });
            boundingBox.Min = min;
            boundingBox.Max = max;
            boundingSphere.Center = U1.Vector3.Add(min, max).Scale(0.5);
            boundingSphere.Radius = U1.Vector3.Distance(min, max) / 2;
        }
        IsInside(planes, fCross) {
            var c_In = 0;
            if (this.PointCount == 0 || this.IndexCount == 0)
                return false;
            var bsphere = this.BoundingSphere;
            for (var i = 0; i < planes.length; i++) {
                var len = planes[i].DotCoordinate(bsphere.Center);
                if (len <= -bsphere.Radius)
                    ++c_In;
                else if (len > bsphere.Radius)
                    return false;
            }
            if (c_In == planes.length)
                return true;
            for (var j = 0; j < this.Points.length; j++) {
                c_In = 0;
                for (var pi = 0; pi < planes.length; pi++) {
                    var len = planes[pi].DotCoordinate(this.Points[j].Position);
                    if (len <= 0)
                        c_In++;
                }
                if (fCross && c_In == planes.length)
                    return true;
                if (!fCross && c_In < planes.length)
                    return false;
            }
            if (fCross) {
                for (var i = 0; i < this.Indexes.length; i += 2) {
                    var v0 = this.Indexes[i];
                    var v1 = this.Indexes[i + 1];
                    if (U1.MeshUtil.CheckEdgeCross(planes, this.Points[v0].Position, this.Points[v1].Position))
                        return true;
                }
                return false;
            }
            return true;
        }
        GetSnapedPoint(mouse, transform, camera) {
            var ray = camera.CalPickingRay(mouse.X, mouse.Y);
            var wray = ray.Clone();
            ray.Transform(U1.Matrix4.Invert(transform));
            ray.Direction.Normalize();
            var bbx = this.BoundingBox.Clone();
            var size = U1.Vector3.Subtract(bbx.Max, bbx.Min);
            bbx.Max.Add(U1.Vector3.Scale(size, 0.1));
            bbx.Min.Subtract(U1.Vector3.Scale(size, 0.1));
            if (bbx.IntersectsRay(ray) == null)
                return null;
            var isectP = U1.Vector3.Zero;
            var minDist = U1.SnapConfig.SnapPixel * U1.SnapConfig.SnapPixel;
            var minDepth = Number.MAX_VALUE;
            var tE = 0.0;
            var fid = 0;
            var v0 = 0, v1 = 0;
            var s, t;
            var dir = U1.Vector3.Zero;
            var res = { s: 0, t: 0 };
            var wp = U1.Vector3.Zero;
            for (var i = 0; i < this.Indexes.length - 1; i += 2) {
                var pos = this.Points[this.Indexes[i]].Position;
                dir.SetSubtract(this.Points[this.Indexes[i + 1]].Position, pos);
                U1.Line3.SquardDistance1(ray.Position, ray.Direction, pos, dir, res);
                if (s < minDepth && t >= -0.001 && t <= 1.001) {
                    wp.SetScaleAdd(pos, t, dir);
                    wp.Transform(transform);
                    var scn = camera.WorldToScreen(wp);
                    var dist = U1.Vector2.DistanceSquared(scn.XY(), mouse);
                    if (dist <= minDist) {
                        minDepth = s;
                        minDist = dist;
                        isectP = wp;
                        fid = (i / 2);
                        v0 = this.Indexes[i];
                        v1 = this.Indexes[i + 1];
                        tE = t;
                    }
                }
            }
            if (v0 != v1) {
                var isect = new U1.ISectInfo();
                isect.Distance = U1.Vector3.Distance(isectP, wray.Position);
                isect.Snap = U1.SnapTypeEnum.Edge;
                isect.IsectNormal.SetUnitZ();
                isect.IsectPosition.CopyFrom(isectP);
                isect.FaceID = (fid);
                if (U1.SnapConfig.GetSnap(U1.SnapTypeEnum.MidEdge)) {
                    var cp = U1.Vector3.Add(this.Points[v0].Position, this.Points[v1].Position).Scale(1 / 2);
                    wp = U1.Vector3.Transform(cp, transform);
                    cp = camera.WorldToScreen(wp);
                    if (U1.SnapConfig.WithinSnapPixel(mouse, cp.X, cp.Y)) {
                        isect.IsectPosition = wp;
                        isect.Snap = U1.SnapTypeEnum.MidEdge;
                    }
                }
                if (U1.SnapConfig.GetSnap(U1.SnapTypeEnum.Point)) {
                    for (var p of [this.Points[v0].Position, this.Points[v1].Position]) {
                        var wp = U1.Vector3.Transform(p, transform);
                        var sp = camera.WorldToScreen(wp);
                        if (U1.SnapConfig.WithinSnapPixel(mouse, sp.X, sp.Y)) {
                            isect.IsectPosition = wp;
                            isect.Snap = U1.SnapTypeEnum.Point;
                        }
                    }
                }
                if (isect.Snap == U1.SnapTypeEnum.Edge && (tE < 0 || tE > 1))
                    return null;
                isect.Distance = U1.Vector3.Distance(camera.Position, isect.IsectPosition);
                return isect;
            }
            return null;
        }
        static IsInside(planes, path, fCross) {
            var c_In = 0;
            var bsphere = U1.BoundingSphere.CreateFromPoints(path);
            for (var i = 0; i < planes.length; i++) {
                var len = planes[i].DotCoordinate(bsphere.Center);
                if (len < -bsphere.Radius)
                    ++c_In;
                else if (len > bsphere.Radius)
                    return false;
            }
            if (c_In == planes.length)
                return true;
            for (var j = 0; j < path.length; j++) {
                c_In = 0;
                for (var pi = 0; pi < planes.length; pi++) {
                    var len = planes[pi].DotCoordinate(path[j]);
                    if (len <= 0)
                        c_In++;
                }
                if (fCross && c_In == planes.length)
                    return true;
                if (!fCross && c_In < planes.length)
                    return false;
            }
            if (fCross) {
                for (var i = 0; i < path.length - 1; i++) {
                    if (U1.MeshUtil.CheckEdgeCross(planes, path[i], path[i + 1]))
                        return true;
                }
                return false;
            }
            return true;
        }
        static IsInside1(planes, bsphere, path, fCross) {
            var c_In = 0;
            for (var i = 0; i < planes.length; i++) {
                var len = planes[i].DotCoordinate(bsphere.Center);
                if (len < -bsphere.Radius)
                    ++c_In;
                else if (len > bsphere.Radius)
                    return false;
            }
            if (c_In == planes.length)
                return true;
            for (var j = 0; j < path.length; j++) {
                c_In = 0;
                for (var pi = 0; pi < planes.length; pi++) {
                    var len = planes[pi].DotCoordinate(path[j]);
                    if (len <= 0)
                        c_In++;
                }
                if (fCross && c_In == planes.length)
                    return true;
                if (!fCross && c_In < planes.length)
                    return false;
            }
            if (fCross) {
                for (var i = 0; i < path.length - 1; i++) {
                    if (U1.MeshUtil.CheckEdgeCross(planes, path[i], path[i + 1]))
                        return true;
                }
                return false;
            }
            return true;
        }
    }
    U1.LineGeometry = LineGeometry;
    class LineVertex {
        constructor(pos = null, color = null) {
            this.Position = U1.Vector3.Zero;
            this.Color = U1.Colors.Black;
            if (pos != null)
                this.Position = pos;
            if (color != null)
                this.Color = color;
        }
        Transform(matrix) {
            this.Position.Transform(matrix);
        }
        Clone() {
            var clone = new LineVertex();
            clone.Position.CopyFrom(this.Position);
            clone.Color.CopyFrom(this.Color);
            return clone;
        }
    }
    U1.LineVertex = LineVertex;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class MeshBufferGeometry extends U1.Geometry {
        get pos() {
            return this._pos;
        }
        set pos(value) {
            this._pos = value;
            this.MarkChanged();
        }
        get normal() {
            return this._norm;
        }
        set normal(value) {
            this._norm = value;
        }
        get hasNormal() {
            return this.normal != undefined && this.normal.length > 0;
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
        }
        get hasColor() {
            return this.color != undefined && this.color.length > 0;
        }
        get uv0() {
            return this._uv0;
        }
        set uv0(value) {
            this._uv0 = value;
        }
        get hasUv0() {
            return this.uv0 != undefined && this.uv0.length > 0;
        }
        get uv1() {
            return this._uv1;
        }
        set uv1(value) {
            this._uv1 = value;
        }
        get hasUv1() {
            return this.uv1 != undefined && this.uv1.length > 0;
        }
        get indices() {
            return this._indices;
        }
        set indices(value) {
            this._indices = value;
        }
        get edgeindices() {
            return this._edgeIndices;
        }
        set edgeindices(value) {
            this._edgeIndices = value;
        }
        UpdateBounding(boundingBox, boundingSphere) {
            var min = MeshBufferGeometry[".ub.min"] || (MeshBufferGeometry[".ub.min"] = new U1.Vector3());
            var max = MeshBufferGeometry[".ub.max"] || (MeshBufferGeometry[".ub.max"] = new U1.Vector3());
            min.SetMaxValue();
            max.SetMinValue();
            var bf_pos = this._pos;
            var num_pos = bf_pos.length;
            for (var i = 0; i < num_pos; i += 3) {
                var x = bf_pos[i];
                var y = bf_pos[i + 1];
                var z = bf_pos[i + 2];
                if (x < min.X)
                    min.X = x;
                if (y < min.Y)
                    min.Y = y;
                if (z < min.Z)
                    min.Z = z;
                if (x > max.X)
                    max.X = x;
                if (y > max.Y)
                    max.Y = y;
                if (z > max.Z)
                    max.Z = z;
            }
            boundingBox.Min.CopyFrom(min);
            boundingBox.Max.CopyFrom(max);
            boundingSphere.Center.SetAdd(min, max).Scale(0.5);
            boundingSphere.Radius = U1.Vector3.Distance(min, max) / 2;
        }
        get VertexCount() {
            return this.pos != null ? this.pos.length / 3 : 0;
        }
        get IndexCount() {
            return this.indices != null ? this.indices.length : 0;
        }
        get FaceCount() {
            return this.IndexCount / 3;
        }
        Copy() {
            var result = new MeshBufferGeometry();
            if (this._pos)
                result._pos = new Float32Array(this._pos);
            if (this._norm)
                result._norm = new Float32Array(this._norm);
            if (this._color)
                result._color = new Float32Array(this._color);
            if (this._uv0)
                result._uv0 = new Float32Array(this._uv0);
            if (this._uv1)
                result._uv1 = new Float32Array(this._uv1);
            if (this._indices)
                result._indices = new Uint16Array(this._indices);
            return result;
        }
        Transform(matrix) {
            var p = MeshBufferGeometry[".trs.p"] || (MeshBufferGeometry[".trs.p"] = new U1.Vector3());
            var n = MeshBufferGeometry[".trs.n"] || (MeshBufferGeometry[".trs.n"] = new U1.Vector3());
            var bf_pos = this._pos;
            var num_pos = bf_pos.length;
            for (var i = 0; i < num_pos; i += 3) {
                p.X = bf_pos[i];
                p.Y = bf_pos[i + 1];
                p.Z = bf_pos[i + 2];
                p.Transform(matrix);
                bf_pos[i] = p.X;
                bf_pos[i + 1] = p.Y;
                bf_pos[i + 2] = p.Z;
            }
            if (this._norm != null) {
                var bf_pos = this._norm;
                var num_pos = bf_pos.length;
                for (var i = 0; i < num_pos; i += 3) {
                    p.X = bf_pos[i];
                    p.Y = bf_pos[i + 1];
                    p.Z = bf_pos[i + 2];
                    p.TransformNormal(matrix).Normalize();
                    bf_pos[i] = p.X;
                    bf_pos[i + 1] = p.Y;
                    bf_pos[i + 2] = p.Z;
                }
            }
            return this;
        }
        IntersectTriangle(ray, v0, v1, v2, dirCheck = true) {
            var res = { r: 0, u: 0, v: 0 };
            var p0 = MeshBufferGeometry[".itr.p0"] || (MeshBufferGeometry[".itr.p0"] = new U1.Vector3());
            var p1 = MeshBufferGeometry[".itr.p1"] || (MeshBufferGeometry[".itr.p1"] = new U1.Vector3());
            var p2 = MeshBufferGeometry[".itr.p2"] || (MeshBufferGeometry[".itr.p2"] = new U1.Vector3());
            p0.Set(this.pos[v0 * 3], this.pos[v0 * 3 + 1], this.pos[v0 * 3 + 2]);
            p1.Set(this.pos[v1 * 3], this.pos[v1 * 3 + 1], this.pos[v1 * 3 + 2]);
            p2.Set(this.pos[v2 * 3], this.pos[v2 * 3 + 1], this.pos[v2 * 3 + 2]);
            var isectp = U1.MeshUtil.Intersect_RayTriangle(ray, p0, p1, p2, dirCheck, res);
            if (isectp == null)
                return null;
            var d0 = MeshBufferGeometry[".itr.d0"] || (MeshBufferGeometry[".itr.d0"] = new U1.Vector3());
            var d1 = MeshBufferGeometry[".itr.d1"] || (MeshBufferGeometry[".itr.d1"] = new U1.Vector3());
            var isectNormal = MeshBufferGeometry[".itr.d2"] || (MeshBufferGeometry[".itr.d2"] = new U1.Vector3());
            d0.SetSubtract(p1, p0);
            d1.SetSubtract(p2, p0);
            isectNormal = U1.Vector3.Cross(d0, d1, isectNormal).Normalize();
            var isect = new U1.ISectInfo();
            isect.S = res.u;
            isect.T = res.v;
            isect.Indices = [v0, v1, v2];
            isect.IsectPosition.CopyFrom(isectp);
            isect.Distance = U1.Vector3.Distance(ray.Position, isectp);
            isect.IsectNormal.CopyFrom(isectNormal);
            isect.Pos = [p0, p1, p2];
            if (this.uv0 != null) {
                var uv0 = new U1.Vector2();
                var uv1 = new U1.Vector2();
                var uv2 = new U1.Vector2();
                uv0.Set(this.uv0[v0 * 2], this.uv0[v0 * 2 + 1]);
                uv1.Set(this.uv0[v1 * 2], this.uv0[v1 * 2 + 1]);
                uv2.Set(this.uv0[v2 * 2], this.uv0[v2 * 2 + 1]);
                isect.UV0 = [uv0, uv1, uv2];
            }
            return isect;
        }
        Intersect(ray) {
            if (this.BoundingSphere == null || ray.IntersectsBoundingSphere(this.BoundingSphere) == null)
                return null;
            var result = null;
            var indices = this.indices;
            var num_indices = indices == null ? this.VertexCount : indices.length;
            for (var i = 0, f = 0; i < num_indices; i += 3, f++) {
                var v0 = i;
                var v1 = i + 1;
                var v2 = i + 2;
                if (indices != null) {
                    v0 = indices[i];
                    v1 = indices[i + 1];
                    v2 = indices[i + 2];
                }
                var isect = this.IntersectTriangle(ray, v0, v1, v2);
                if (isect == null)
                    continue;
                if (result == null || isect.Distance < result.Distance) {
                    isect.FaceID = f;
                    isect.Attr = 0;
                    isect.Geometry = this;
                    result = isect;
                }
            }
            return result;
        }
        IntersectCount(ray, result) {
            result.front = 0;
            result.back = 0;
            result.surface = 0;
            if (this.BoundingSphere == null || ray.IntersectsBoundingSphere(this.BoundingSphere) == null)
                return;
            var res = { r: 0, u: 0, v: 0 };
            var indices = this._indices;
            var num_indices = indices.length;
            var pos = this._pos;
            var p0 = MeshBufferGeometry[".isc.p0"] || (MeshBufferGeometry[".isc.p0"] = new U1.Vector3());
            var p1 = MeshBufferGeometry[".isc.p1"] || (MeshBufferGeometry[".isc.p1"] = new U1.Vector3());
            var p2 = MeshBufferGeometry[".isc.p2"] || (MeshBufferGeometry[".isc.p2"] = new U1.Vector3());
            for (var i = 0, f = 0; i < num_indices; i += 3, f++) {
                var v0 = indices[i];
                var v1 = indices[i + 1];
                var v2 = indices[i + 2];
                p0.Set(pos[v0], pos[v0 + 1], pos[v0 + 2]);
                p1.Set(pos[v1], pos[v1 + 1], pos[v1 + 2]);
                p2.Set(pos[v2], pos[v2 + 1], pos[v2 + 2]);
                var isectp = U1.MeshUtil.Intersect_RayTriangle(ray, p0, p1, p2, false, res);
                if (isectp == null)
                    continue;
                if (Math.abs(res.r) < U1.Epsilon) {
                    result.surface++;
                }
                else {
                    if (res.r < 0)
                        result.back++;
                    if (res.r > 0)
                        result.front++;
                }
            }
        }
        IntersectW(wray, worldM) {
            var s_;
            s_ = MeshBufferGeometry[".isw."] || (MeshBufferGeometry[".isw."] = {});
            var ray = s_.ray || (s_.ray = new U1.Ray3());
            var invm = s_.invm || (s_.invm = new U1.Matrix4());
            ray = ray.CopyFrom(wray).Transform(U1.Matrix4.Invert(worldM, invm));
            ray.Direction.Normalize();
            var bbx = this.BoundingBox;
            if (bbx.IntersectsRay(ray) == null)
                return null;
            var result = this.Intersect(ray);
            if (result != null) {
                result.Snap = U1.SnapTypeEnum.Face;
                result.IsectPosition.Transform(worldM);
                result.IsectNormal.TransformNormal(worldM);
                result.Distance = U1.Vector3.Distance(result.IsectPosition, wray.Position);
                return result;
            }
            return null;
        }
        GetSnapedPoint(mouse, worldM, camera) {
            var ray = camera.CalPickingRay(mouse.X, mouse.Y);
            var wray = ray;
            ray.Transform(U1.Matrix4.Invert(worldM));
            ray.Direction.Normalize();
            var bbx = this.BoundingBox;
            if (bbx.IntersectsRay(ray) == null)
                return null;
            var result = this.Intersect(ray);
            if (result != null) {
                var isect = result;
                var fid = isect.FaceID;
                isect.Snap = U1.SnapTypeEnum.Face;
                isect.IsectPosition.SetTransform(isect.IsectPosition, worldM);
                isect.IsectNormal.SetTransformNormal(isect.IsectNormal, worldM);
                for (var i = 0; i < isect.Pos.length; i++) {
                    isect.Pos[i].Transform(worldM);
                }
                var indices = this._indices;
                var pos = this._pos;
                var norm = this._norm;
                var vpos = MeshBufferGeometry[".gsp.vp"] || (MeshBufferGeometry[".gsp.vp"] = new U1.Vector3());
                var vnorm = MeshBufferGeometry[".gsp.vn"] || (MeshBufferGeometry[".gsp.vn"] = new U1.Vector3());
                var wp = MeshBufferGeometry[".gsp.wp"] || (MeshBufferGeometry[".gsp.wp"] = new U1.Vector3());
                var sp = MeshBufferGeometry[".gsp.sp"] || (MeshBufferGeometry[".gsp.sp"] = new U1.Vector3());
                var xy = MeshBufferGeometry[".gsp.xy"] || (MeshBufferGeometry[".gsp.xy"] = new U1.Vector2());
                if (U1.SnapConfig.GetSnap(U1.SnapTypeEnum.Point)) {
                    var vs = [indices[fid * 3], indices[fid * 3 + 1], indices[fid * 3 + 2]];
                    var minLen = Number.MAX_VALUE;
                    for (var i = 0; i < 3; i++) {
                        var i0 = vs[i] * 3;
                        var i1 = i0 + 1;
                        var i2 = i0 + 2;
                        vpos.Set(pos[i0], pos[i1], pos[i2]);
                        if (norm != null) {
                            vnorm.Set(norm[i0], norm[i1], norm[i2]);
                        }
                        wp = U1.Vector3.Transform(vpos, worldM, wp);
                        sp = camera.ScreenToWorld(wp, sp);
                        var len = U1.Vector2.DistanceSquared(sp.XY(xy), mouse);
                        if (len < minLen) {
                            minLen = len;
                            if (U1.SnapConfig.WithinSnapPixel(mouse, sp.X, sp.Y)) {
                                isect.Snap = U1.SnapTypeEnum.Point;
                                isect.IsectPosition.CopyFrom(wp);
                                isect.IsectNormal.SetTransformNormal(vnorm, worldM).Normalize();
                            }
                        }
                    }
                }
                isect.Distance = U1.Vector3.Distance(camera.Position, isect.IsectPosition);
                return isect;
            }
            return null;
        }
        IsInside(planes, checkCross) {
            var bsphere = this.BoundingSphere;
            var c_In = 0;
            for (var i = 0; i < planes.length; i++) {
                var len = planes[i].DotCoordinate(bsphere.Center);
                if (len < -bsphere.Radius)
                    ++c_In;
                else if (len > bsphere.Radius)
                    return false;
            }
            if (c_In == planes.length)
                return true;
            if (this._pos == null || this._indices == null)
                return false;
            var bf_pos = this._pos;
            var bf_indices = this._indices;
            var num_pos = bf_pos.length;
            var num_indices = bf_indices.length;
            var s_;
            s_ = MeshBufferGeometry[".iis."] || (MeshBufferGeometry[".iis."] = {});
            var vp = s_.vp || (s_.vp = new U1.Vector3());
            var p0 = s_.p0 || (s_.p0 = new U1.Vector3());
            var p1 = s_.p1 || (s_.p1 = new U1.Vector3());
            var p2 = s_.p2 || (s_.p2 = new U1.Vector3());
            try {
                for (var vi = 0; vi < num_pos; vi += 3) {
                    c_In = 0;
                    vp.Set(bf_pos[vi], bf_pos[vi + 1], bf_pos[vi + 2]);
                    for (var i = 0; i < planes.length; i++) {
                        var len = planes[i].DotCoordinate(vp);
                        if (len <= 0)
                            c_In++;
                    }
                    if (checkCross && c_In == planes.length)
                        return true;
                    if (!checkCross && c_In < planes.length)
                        return false;
                }
                if (checkCross) {
                    try {
                        for (var i = 0; i < num_indices; i += 3) {
                            var f0 = bf_indices[i];
                            var f1 = bf_indices[i + 1];
                            var f2 = bf_indices[i + 2];
                            p0.Set(bf_pos[f0 * 3], bf_pos[f0 * 3 + 1], bf_pos[f0 * 3 + 2]);
                            p1.Set(bf_pos[f1 * 3], bf_pos[f1 * 3 + 1], bf_pos[f1 * 3 + 2]);
                            p2.Set(bf_pos[f2 * 3], bf_pos[f2 * 3 + 1], bf_pos[f2 * 3 + 2]);
                            if (U1.MeshUtil.CheckEdgeCross(planes, p0, p1) ||
                                U1.MeshUtil.CheckEdgeCross(planes, p1, p2) ||
                                U1.MeshUtil.CheckEdgeCross(planes, p2, p0)) {
                                return true;
                            }
                        }
                    }
                    catch (ex) {
                    }
                    return false;
                }
            }
            catch (ex) {
            }
            return true;
        }
        SmoothNormal() {
            var pos = this._pos;
            var indices = this._indices;
            var num_pos = this._pos.length;
            var vcount = this.VertexCount;
            var norms = this._norm;
            if (norms == null)
                norms = this._norm = new Float32Array(num_pos);
            var normals = new Array(vcount * 3);
            var f_count = new Array(vcount);
            for (var i = 0; i < num_pos; i++) {
                normals[i] = 0;
                if (i < vcount)
                    f_count[i] = 0;
            }
            var p0 = MeshBufferGeometry[".snm.p0"] || (MeshBufferGeometry[".snm.p0"] = new U1.Vector3());
            var p1 = MeshBufferGeometry[".snm.p1"] || (MeshBufferGeometry[".snm.p1"] = new U1.Vector3());
            var p2 = MeshBufferGeometry[".snm.p2"] || (MeshBufferGeometry[".snm.p2"] = new U1.Vector3());
            var dir0 = MeshBufferGeometry[".snm.d0"] || (MeshBufferGeometry[".snm.d0"] = new U1.Vector3());
            var dir1 = MeshBufferGeometry[".snm.d1"] || (MeshBufferGeometry[".snm.d1"] = new U1.Vector3());
            var norm = MeshBufferGeometry[".snm.nm"] || (MeshBufferGeometry[".snm.nm"] = new U1.Vector3());
            var fcount = this.FaceCount;
            var set_normal = (i0_, i1_, i2_) => {
                p0.Set(pos[i0_ * 3], pos[i0_ * 3 + 1], pos[i0_ * 3 + 2]);
                p1.Set(pos[i1_ * 3], pos[i1_ * 3 + 1], pos[i1_ * 3 + 2]);
                p2.Set(pos[i2_ * 3], pos[i2_ * 3 + 1], pos[i2_ * 3 + 2]);
                dir0.SetSubtract(p1, p0).Normalize();
                dir1.SetSubtract(p2, p0).Normalize();
                norm.SetCross(dir0, dir1).Normalize();
                if (i0_ == 0) {
                    i0_ = 0;
                }
                var a = U1.Vector3.Dot(dir0, dir1);
                a = Math.acos(a);
                norm.Scale(a);
                normals[i0_ * 3] += norm.X;
                normals[i0_ * 3 + 1] += norm.Y;
                normals[i0_ * 3 + 2] += norm.Z;
                f_count[i0_] += 1;
            };
            for (var i = 0; i < fcount; i++) {
                var i0 = indices[i * 3];
                var i1 = indices[i * 3 + 1];
                var i2 = indices[i * 3 + 2];
                set_normal(i0, i1, i2);
                set_normal(i1, i2, i0);
                set_normal(i2, i0, i1);
            }
            for (var vi = 0; vi < num_pos; vi += 3) {
                norm.Set(normals[vi], normals[vi + 1], normals[vi + 2]);
                norm.Normalize();
                norms[vi] = norm.X;
                norms[vi + 1] = norm.Y;
                norms[vi + 2] = norm.Z;
            }
        }
        CopyFromMeshGeomerty(mesh) {
            this._pos = new Float32Array(mesh.VertexCount * 3);
            this._norm = new Float32Array(mesh.VertexCount * 3);
            this._uv0 = new Float32Array(mesh.VertexCount * 2);
            this._indices = new Uint16Array(mesh.Indexes);
            this._color = undefined;
            this._uv1 = undefined;
            var vc = mesh.VertexCount;
            for (var vi = 0; vi < vc; vi++) {
                var vtx = mesh.Vertices[vi];
                this._pos[vi * 3] = vtx.Position.X;
                this._pos[vi * 3 + 1] = vtx.Position.Y;
                this._pos[vi * 3 + 2] = vtx.Position.Z;
                this._norm[vi * 3] = vtx.Normal.X;
                this._norm[vi * 3 + 1] = vtx.Normal.Y;
                this._norm[vi * 3 + 2] = vtx.Normal.Z;
                this._uv0[vi * 2] = vtx.UV0.X;
                this._uv0[vi * 2 + 1] = vtx.UV0.Y;
            }
            return this;
        }
        CopyFromShell(shell) {
            var vs = shell.Vertices;
            var v = shell.Vertices[0];
            var hasVertexNormal = v.Normal !== undefined;
            var posList = new Array();
            var normList = new Array();
            var uvList = new Array();
            var indices = new Array();
            let vmap = {};
            shell.Vertices.forEach((v_, i_, vs_) => {
                vmap[i_] = v_;
            });
            for (var vi = 0; vi < vs.length; vi++) {
                let v = vs[vi];
                posList.push(v.X, v.Y, v.Z);
                if (v.Normal !== undefined)
                    normList.push(v.Normal.X, v.Normal.Y, v.Normal.Z);
                else
                    normList.push(0, 0, 0);
                if (v.UV0 !== undefined)
                    uvList.push(v.UV0.X, v.UV0.Y);
                else
                    uvList.push(0, 0);
            }
            for (var face of shell.Faces) {
                var useFaceNormal = !hasVertexNormal || face.IsCap || face.IsFlat;
                var tri_faces = face.Tesselate(vmap);
                if (useFaceNormal) {
                    var vamp = {};
                    var fnormal = face.Normal;
                    for (var i of tri_faces) {
                        if (vamp[i] == null) {
                            var ni = posList.length / 3;
                            vamp[i] = ni;
                            indices.push(ni);
                            let v = shell.Vertices[i];
                            posList.push(v.X, v.Y, v.Z);
                            normList.push(fnormal.X, fnormal.Y, fnormal.Z);
                            if (v.UV0 !== undefined)
                                uvList.push(v.UV0.X, v.UV0.Y);
                            else
                                uvList.push(0, 0);
                        }
                        else {
                            indices.push(vamp[i]);
                        }
                    }
                }
                else {
                    indices.push(...tri_faces);
                }
            }
            this.pos = new Float32Array(posList);
            this.normal = new Float32Array(normList);
            this.uv0 = new Float32Array(uvList);
            this.indices = new Uint16Array(indices);
            this.color = undefined;
            return this;
        }
        CopyFrom(other) {
            this.pos = other.pos != null ? new Float32Array(other.pos) : null;
            this.normal = other.normal != null ? new Float32Array(other.normal) : null;
            this.uv0 = other.uv0 != null ? new Float32Array(other.uv0) : null;
            this.uv1 = other.uv1 != null ? new Float32Array(other.uv1) : null;
            this.color = other.color != null ? new Float32Array(other.color) : null;
            this.indices = other.indices != null ? new Uint16Array(other.indices) : null;
            return this;
        }
        Clone() {
            var result = new MeshBufferGeometry();
            result.CopyFrom(this);
            return result;
        }
        ApplyTransform(transform) {
            if (this.pos != null) {
                var p = new U1.Vector3();
                for (var i = 0; i < this.pos.length; i += 3) {
                    p.Set(this.pos[i], this.pos[i + 1], this.pos[i + 2]);
                    p.Transform(transform);
                    this.pos[i] = p.X;
                    this.pos[i + 1] = p.Y;
                    this.pos[i + 2] = p.Z;
                }
            }
            if (this.normal != null) {
                let n = new U1.Vector3();
                for (var i = 0; i < this.normal.length; i += 3) {
                    n.Set(this.normal[i], this.normal[i + 1], this.normal[i + 2]);
                    n.TransformNormal(transform);
                    this.normal[i] = n.X;
                    this.normal[i + 1] = n.Y;
                    this.normal[i + 2] = n.Z;
                }
            }
        }
        BeginAppend() {
            this.tmp_pos = [];
            this.tmp_nom = [];
            this.tmp_col = [];
            this.tmp_uv0 = [];
            this.tmp_idx = [];
        }
        EndAppend() {
            var vlast = this.VertexCount;
            if (this.pos != null) {
                let vals = new Array(this.pos.length + this.tmp_pos.length);
                var vi = 0;
                for (var i = 0; i < this.pos.length; i++, vi++)
                    vals[vi] = this.pos[i];
                for (var i = 0; i < this.tmp_pos.length; i++, vi++)
                    vals[vi] = this.tmp_pos[i];
                this.tmp_pos = vals;
            }
            if (this.uv0 != null) {
                let vals = new Array(this.uv0.length + this.tmp_pos.length);
                var vi = 0;
                for (var i = 0; i < this.uv0.length; i++, vi++)
                    vals[vi] = this.uv0[i];
                for (var i = 0; i < this.tmp_uv0.length; i++, vi++)
                    vals[vi] = this.tmp_uv0[i];
                this.tmp_uv0 = vals;
            }
            if (this.normal != null) {
                let tvals = new Array(this.normal.length + this.tmp_nom.length);
                var vi = 0;
                for (var i = 0; i < this.normal.length; i++, vi++)
                    tvals[vi] = this.normal[i];
                for (var i = 0; i < this.tmp_nom.length; i++, vi++)
                    tvals[vi] = this.tmp_nom[i];
                this.tmp_nom = tvals;
            }
            if (this.indices != null) {
                let vals = new Array(this.indices.length + this.tmp_idx.length);
                var vi = 0;
                for (var i = 0; i < this.indices.length; i++, vi++)
                    vals[vi] = this.indices[i];
                for (var i = 0; i < this.tmp_idx.length; i++, vi++)
                    vals[vi] = this.tmp_idx[i] + vlast;
                this.tmp_idx = vals;
            }
            if (this.color != null) {
                let vals = new Array(this.color.length + this.tmp_idx.length);
                var vi = 0;
                for (var i = 0; i < this.color.length; i++, vi++)
                    vals[vi] = this.color[i];
                for (var i = 0; i < this.tmp_col.length; i++, vi++)
                    vals[vi] = this.tmp_col[i];
                this.tmp_col = vals;
            }
            if (this.tmp_pos.length > 0)
                this.pos = new Float32Array(this.tmp_pos);
            else
                this.pos = null;
            if (this.tmp_nom.length > 0)
                this.normal = new Float32Array(this.tmp_nom);
            else
                this.normal = null;
            if (this.tmp_uv0.length > 0)
                this.uv0 = new Float32Array(this.tmp_uv0);
            else
                this.uv0 = null;
            if (this.tmp_col.length > 0)
                this.color = new Float32Array(this.tmp_col);
            else
                this.color = null;
            if (this.tmp_idx.length > 0)
                this.indices = new Uint16Array(this.tmp_idx);
            else
                this.indices = null;
            this.tmp_pos = undefined;
            this.tmp_nom = undefined;
            this.tmp_col = undefined;
            this.tmp_uv0 = undefined;
            this.tmp_idx = undefined;
        }
        AppendFace(p0, p1, p2, xform) {
            var tv0 = MeshBufferGeometry[".af.v0"] || (MeshBufferGeometry[".af.v0"] = new U1.Vector3());
            var tv1 = MeshBufferGeometry[".af.v1"] || (MeshBufferGeometry[".af.v1"] = new U1.Vector3());
            var tv2 = MeshBufferGeometry[".af.v2"] || (MeshBufferGeometry[".af.v2"] = new U1.Vector3());
            var tv3 = MeshBufferGeometry[".af.v3"] || (MeshBufferGeometry[".af.v3"] = new U1.Vector3());
            if (xform !== undefined) {
                p0 = tv0.CopyFrom(p0).Transform(xform);
                p1 = tv1.CopyFrom(p1).Transform(xform);
                p2 = tv2.CopyFrom(p2).Transform(xform);
            }
            var nm = tv3.SetCross(tv0.SetSubtract(p1, p0), tv1.SetSubtract(p2, p0)).Normalize();
            var si = this.tmp_pos.length / 3;
            var pos = this.tmp_pos;
            var nom = this.tmp_nom;
            var idx = this.tmp_idx;
            pos.push(p0.X);
            pos.push(p0.Y);
            pos.push(p0.Z);
            pos.push(p1.X);
            pos.push(p1.Y);
            pos.push(p1.Z);
            pos.push(p2.X);
            pos.push(p2.Y);
            pos.push(p2.Z);
            nom.push(nm.X);
            nom.push(nm.Y);
            nom.push(nm.Z);
            nom.push(nm.X);
            nom.push(nm.Y);
            nom.push(nm.Z);
            nom.push(nm.X);
            nom.push(nm.Y);
            nom.push(nm.Z);
            idx.push(si);
            idx.push(si + 1);
            idx.push(si + 2);
        }
        AppendFace1(p0, p1, p2, uv0, uv1, uv2, xform) {
            this.AppendFace(p0, p1, p2, xform);
            var uv = this.tmp_uv0;
            uv.push(uv0.X);
            uv.push(uv0.Y);
            uv.push(uv1.X);
            uv.push(uv1.Y);
            uv.push(uv2.X);
            uv.push(uv2.Y);
        }
        AppendFace2(p0, p1, p2, color, xform) {
            this.AppendFace(p0, p1, p2, xform);
            var col = this.tmp_col;
            var r = color.R / 255;
            var g = color.G / 255;
            var b = color.B / 255;
            col.push(r);
            col.push(r);
            col.push(r);
            col.push(g);
            col.push(g);
            col.push(g);
            col.push(b);
            col.push(b);
            col.push(b);
        }
        static Merges(meshes) {
            var pos = [];
            var normal = [];
            var color = [];
            var uv0 = [];
            var uv1 = [];
            var indices = [];
            var attrs = [];
            var materials = meshes.filter(o_ => o_.Materials != null).length > 0 ? [] : null;
            var fnormal = meshes.filter(o_ => o_.hasNormal).length > 0;
            var fcolor = meshes.filter(o_ => o_.hasColor).length > 0;
            var fuv0 = meshes.filter(o_ => o_.hasUv0).length > 0;
            var fuv1 = meshes.filter(o_ => o_.hasUv1).length > 0;
            var attr = 0;
            for (var i = 0; i < meshes.length; i++, attr++) {
                var mesh = meshes[i];
                var vstart = pos.length / 3;
                var fstart = indices.length / 3;
                pos.AddRange(mesh.pos);
                if (fnormal) {
                    if (mesh.normal != null) {
                        normal.AddRange(mesh.normal);
                    }
                    else {
                        for (var j = 0; j < mesh.pos.length; j++) {
                            normal.push(0);
                        }
                    }
                }
                if (fcolor) {
                    if (mesh.color != null) {
                        color.AddRange(mesh.color);
                    }
                    else {
                        for (var j = 0; j < mesh.pos.length; j++) {
                            color.push(0);
                        }
                    }
                }
                if (fuv0) {
                    if (mesh.uv0 != null) {
                        uv0.AddRange(mesh.uv0);
                    }
                    else
                        for (var vi = 0; vi < mesh.pos.length; vi += 3) {
                            uv0.push(0, 0);
                        }
                }
                if (fuv1) {
                    if (mesh.uv1 != null) {
                        uv1.AddRange(mesh.uv1);
                    }
                    else
                        for (var vi = 0; vi < mesh.pos.length; vi += 3) {
                            uv1.push(0, 0);
                        }
                }
                if (mesh.indices != null) {
                    for (var fi = 0; fi < mesh.indices.length; fi++) {
                        indices.push(mesh.indices[fi] + vstart);
                    }
                    var face_num = mesh.indices.length / 3;
                    for (var fi = 0; fi < face_num; fi++) {
                        attrs.push(attr);
                    }
                }
                if (materials != null) {
                    if (mesh.Materials != null)
                        materials.push(mesh.Materials[0]);
                    else
                        materials.push(new U1.MeshMaterial());
                }
            }
            var result = new MeshBufferGeometry();
            result.pos = new Float32Array(pos);
            if (fnormal)
                result.normal = new Float32Array(normal);
            if (fcolor)
                result.color = new Float32Array(color);
            if (fuv0)
                result.uv0 = new Float32Array(uv0);
            if (fuv1)
                result.uv1 = new Float32Array(uv1);
            result.indices = new Uint16Array(indices);
            result.Attributes = attrs;
            return result;
        }
        Merge(other, m) {
            if (m !== undefined) {
                other = other.Clone();
                other.Transform(m);
            }
            var result = MeshBufferGeometry.Merges([this, other]);
            this.CopyFrom(result);
            return this;
        }
        static CreateFromTriangles(triangles) {
            var geom = new MeshBufferGeometry();
            geom.pos = new Float32Array(triangles.length * 3);
            var vi = 0;
            for (var i = 0; i < triangles.length; i++) {
                geom.pos[vi++] = triangles[i].X;
                geom.pos[vi++] = triangles[i].Y;
                geom.pos[vi++] = triangles[i].Z;
            }
            return geom;
        }
    }
    U1.MeshBufferGeometry = MeshBufferGeometry;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class MeshGeometry extends U1.Geometry {
        UpdateBounding(boundingBox, boundingSphere) {
            var min = U1.Vector3.MaxValue;
            var max = U1.Vector3.MinValue;
            this.Vertices.forEach((v_, i_, arr_) => {
                min.Minimize(v_.Position);
                max.Maximize(v_.Position);
            });
            boundingBox.Min = min;
            boundingBox.Max = max;
            boundingSphere.Center = U1.Vector3.Add(min, max).Scale(0.5);
            boundingSphere.Radius = U1.Vector3.Distance(min, max) / 2;
        }
        get VertexCount() {
            return this.Vertices != null ? this.Vertices.length : 0;
        }
        get IndexCount() {
            return this.Indexes != null ? this.Indexes.length : 0;
        }
        get FaceCount() {
            return this.Indexes == null ? 0 : this.Indexes.length / 3;
        }
        get ObjectCount() {
            return this.Obj == null ? 0 : this.Obj.length;
        }
        Clone() {
            if (this.Vertices == null || this.Indexes == null)
                return new MeshGeometry();
            var result = new MeshGeometry();
            result.Vertices = new Array(this.VertexCount);
            result.Indexes = new Array(this.IndexCount);
            result.Attributes = this.Attributes != null ? new Array(this.Attributes.length) : null;
            result.Materials = this.Materials != null ? new Array(this.Materials.length) : null;
            this.Vertices.forEach((v_, i_, arr_) => {
                result.Vertices[i_] = v_.Clone();
            });
            this.Indexes.forEach((fi, i_, arr_) => {
                result.Indexes[i_] = fi;
            });
            if (result.Attributes != null) {
                this.Attributes.forEach((fi, i_, arr_) => {
                    result.Attributes[i_] = fi;
                });
            }
            if (result.Materials != null) {
                this.Materials.forEach((fi, i_, arr_) => {
                    result.Materials[i_] = fi.Clone();
                });
            }
            return result;
        }
        Transform(matrix) {
            this.Vertices.forEach((v_, i_, arr_) => {
                v_.Transform(matrix);
            });
        }
        static IntersectTriangle(ray, v0, v1, v2, dirCheck = true) {
            var res = { r: 0, u: 0, v: 0 };
            var isectp = U1.MeshUtil.Intersect_RayTriangle(ray, v0.Position, v1.Position, v2.Position, dirCheck, res);
            if (isectp == null)
                return null;
            var d0 = MeshGeometry.tmp_v3_0;
            var d1 = MeshGeometry.tmp_v3_1;
            var isectNormal = MeshGeometry.tmp_v3_2;
            var uv0 = MeshGeometry.tmp_v2_0;
            var uv1 = MeshGeometry.tmp_v2_1;
            var uv2 = MeshGeometry.tmp_v2_2;
            d0.SetSubtract(v1.Position, v0.Position);
            d1.SetSubtract(v2.Position, v0.Position);
            var isectNormal = U1.Vector3.Cross(d0, d1).Normalize();
            uv0.SetScale(v0.UV0, (1 - res.u - res.v));
            uv1.SetSubtract(v1.UV0, v0.UV0).Scale(res.u);
            uv2.SetSubtract(v2.UV0, v0.UV0).Scale(res.v);
            var isect = new U1.ISectInfo();
            isect.IsectPosition.CopyFrom(isectp);
            isect.Distance = U1.Vector3.Distance(ray.Position, isectp),
                isect.IsectNormal.CopyFrom(isectNormal);
            isect.UV0 = new Array(v0.UV0, v1.UV0, v2.UV0);
            isect.Pos = new Array(v0.Position, v1.Position, v2.Position);
            return isect;
        }
        Intersect(ray) {
            if (this.BoundingSphere == null || ray.IntersectsBoundingSphere(this.BoundingSphere) == null)
                return null;
            var result = null;
            for (var i = 0, f = 0; i < this.Indexes.length; i += 3, f++) {
                var v0 = this.Indexes[i];
                var v1 = this.Indexes[i + 1];
                var v2 = this.Indexes[i + 2];
                var isect = MeshGeometry.IntersectTriangle(ray, this.Vertices[v0], this.Vertices[v1], this.Vertices[v2]);
                if (isect == null)
                    continue;
                if (result == null || isect.Distance < result.Distance) {
                    isect.FaceID = f;
                    isect.Attr = this.Attributes != null ? this.Attributes[f] : 0;
                    result = isect;
                }
            }
            result = result != null ? result.Clone() : null;
            return result;
        }
        IntersectCount(ray, result) {
            result.front = 0;
            result.back = 0;
            result.surface = 0;
            if (this.BoundingSphere == null || ray.IntersectsBoundingSphere(this.BoundingSphere) == null)
                return;
            var res = { r: 0, u: 0, v: 0 };
            for (var i = 0, f = 0; i < this.Indexes.length; i += 3, f++) {
                var v0 = this.Indexes[i];
                var v1 = this.Indexes[i + 1];
                var v2 = this.Indexes[i + 2];
                var p0 = this.Vertices[v0].Position;
                var p1 = this.Vertices[v1].Position;
                var p2 = this.Vertices[v2].Position;
                var isectp = U1.MeshUtil.Intersect_RayTriangle(ray, p0, p1, p2, false, res);
                if (isectp == null)
                    continue;
                if (Math.abs(res.r) < U1.Epsilon) {
                    result.surface++;
                }
                else {
                    if (res.r < 0)
                        result.back++;
                    if (res.r > 0)
                        result.front++;
                }
            }
        }
        IntersectW(wray, worldM) {
            var ray = wray.Clone().Transform(U1.Matrix4.Invert(worldM));
            ray.Direction.Normalize();
            var bbx = this.BoundingBox;
            if (bbx.IntersectsRay(ray) == null)
                return null;
            var result = this.Intersect(ray);
            if (result != null) {
                result.Snap = U1.SnapTypeEnum.Face;
                result.IsectPosition.Transform(worldM);
                result.IsectNormal.TransformNormal(worldM);
                result.Distance = U1.Vector3.Distance(result.IsectPosition, wray.Position);
                return result;
            }
            return null;
        }
        GetSnapedPoint(mouse, worldM, camera) {
            var ray = camera.CalPickingRay(mouse.X, mouse.Y);
            var wray = ray;
            ray.Transform(U1.Matrix4.Invert(worldM));
            ray.Direction.Normalize();
            var bbx = this.BoundingBox;
            if (bbx.IntersectsRay(ray) == null)
                return null;
            var result = this.Intersect(ray);
            if (result != null) {
                var isect = result;
                var fid = isect.FaceID;
                isect.Snap = U1.SnapTypeEnum.Face;
                isect.IsectPosition.SetTransform(isect.IsectPosition, worldM);
                isect.IsectNormal.SetTransformNormal(isect.IsectNormal, worldM);
                for (var i = 0; i < isect.Pos.length; i++) {
                    isect.Pos[i].Transform(worldM);
                }
                if (U1.SnapConfig.GetSnap(U1.SnapTypeEnum.Point)) {
                    var vs = [this.Indexes[fid * 3], this.Indexes[fid * 3 + 1], this.Indexes[fid * 3 + 2]];
                    var minLen = Number.MAX_VALUE;
                    for (var i = 0; i < 3; i++) {
                        var vtx = this.Vertices[vs[i]];
                        var wp = U1.Vector3.Transform(vtx.Position, worldM);
                        var sp = camera.ScreenToWorld(wp);
                        var len = U1.Vector2.DistanceSquared(sp.XY(), mouse);
                        if (len < minLen) {
                            minLen = len;
                            if (U1.SnapConfig.WithinSnapPixel(mouse, sp.X, sp.Y)) {
                                isect.Snap = U1.SnapTypeEnum.Point;
                                isect.IsectPosition.CopyFrom(wp);
                                isect.IsectNormal.SetTransformNormal(vtx.Normal, worldM).Normalize();
                            }
                        }
                    }
                }
                isect.Distance = U1.Vector3.Distance(camera.Position, isect.IsectPosition);
                return isect;
            }
            return null;
        }
        IsInside(planes, checkCross) {
            var bsphere = this.BoundingSphere;
            var c_In = 0;
            for (var i = 0; i < planes.length; i++) {
                var len = planes[i].DotCoordinate(bsphere.Center);
                if (len < -bsphere.Radius)
                    ++c_In;
                else if (len > bsphere.Radius)
                    return false;
            }
            if (c_In == planes.length)
                return true;
            try {
                for (var vi = 0; vi < this.Vertices.length; vi++) {
                    c_In = 0;
                    for (var i = 0; i < planes.length; i++) {
                        var len = planes[i].DotCoordinate(this.Vertices[vi].Position);
                        if (len <= 0)
                            c_In++;
                    }
                    if (checkCross && c_In == planes.length)
                        return true;
                    if (!checkCross && c_In < planes.length)
                        return false;
                }
                if (checkCross) {
                    try {
                        for (var i = 0; i < this.Indexes.length; i += 3) {
                            var f0 = this.Indexes[i];
                            var f1 = this.Indexes[i + 1];
                            var f2 = this.Indexes[i + 2];
                            if (U1.MeshUtil.CheckEdgeCross(planes, this.Vertices[f0].Position, this.Vertices[f1].Position) ||
                                U1.MeshUtil.CheckEdgeCross(planes, this.Vertices[f1].Position, this.Vertices[f2].Position) ||
                                U1.MeshUtil.CheckEdgeCross(planes, this.Vertices[f2].Position, this.Vertices[f0].Position)) {
                                return true;
                            }
                        }
                    }
                    catch (ex) {
                    }
                    return false;
                }
            }
            catch (ex) {
            }
            return true;
        }
        SmoothNormal() {
            var normals = new Array(this.Vertices.length);
            var f_count = new Array(this.Vertices.length);
            this.Vertices.forEach((e_, i_) => {
                normals[i_] = U1.Vector3.Zero;
                f_count[i_] = 0;
            });
            var fcount = this.FaceCount;
            var dir0 = U1.Vector3.Zero;
            var dir1 = U1.Vector3.Zero;
            var norm = U1.Vector3.Zero;
            var set_normal = (i0_, i1_, i2_) => {
                var v0 = this.Vertices[i0_];
                var v1 = this.Vertices[i1_];
                var v2 = this.Vertices[i2_];
                dir0.SetSubtract(v1.Position, v0.Position).Normalize();
                dir1.SetSubtract(v2.Position, v0.Position).Normalize();
                norm.SetCross(dir0, dir1).Normalize();
                if (i0_ == 0) {
                    i0_ = 0;
                }
                var a = U1.Vector3.Dot(dir0, dir1);
                a = Math.acos(a);
                norm.Scale(a);
                normals[i0_].Add(norm);
                f_count[i0_]++;
            };
            for (var i = 0; i < fcount; i++) {
                var i0 = this.Indexes[i * 3];
                var i1 = this.Indexes[i * 3 + 1];
                var i2 = this.Indexes[i * 3 + 2];
                set_normal(i0, i1, i2);
                set_normal(i1, i2, i0);
                set_normal(i2, i0, i1);
            }
            for (var vi = 0; vi < this.Vertices.length; vi++) {
                normals[vi].Normalize();
                this.Vertices[vi].Normal.CopyFrom(normals[vi]);
            }
        }
        MakeFlatFaceMesh() {
            var vList = new Array();
            var iList = new Array();
            var num_face = this.FaceCount;
            var dir0 = U1.Vector3.Zero;
            var dir1 = U1.Vector3.Zero;
            var norm = U1.Vector3.Zero;
            for (var i = 0; i < num_face; i++) {
                var i0 = this.Indexes[i * 3];
                var i1 = this.Indexes[i0 + 1];
                var i2 = this.Indexes[i1 + 1];
                var v0 = this.Vertices[i0].Clone();
                var v1 = this.Vertices[i1].Clone();
                var v2 = this.Vertices[i2].Clone();
                dir0.SetSubtract(v1.Position, v0.Position).Normalize();
                dir1.SetSubtract(v2.Position, v0.Position).Normalize();
                norm.SetCross(dir0, dir1).Normalize();
                v0.Normal.CopyFrom(norm);
                v1.Normal.CopyFrom(norm);
                v2.Normal.CopyFrom(norm);
                var fi = vList.length;
                iList.push(fi);
                iList.push(fi + 1);
                iList.push(fi + 2);
                vList.push(v0);
                vList.push(v1);
                vList.push(v2);
            }
            var mesh = new MeshGeometry();
            mesh.Vertices = vList;
            mesh.Indexes = iList;
            return mesh;
        }
        static CreateRectangle(points) {
            var normal = U1.Vector3.Cross(U1.Vector3.Subtract(points[1], points[0]), U1.Vector3.Subtract(points[2], points[0]))
                .Normalize();
            var result = new MeshGeometry();
            result.Vertices = new Array(4);
            result.Indexes = new Array(0, 1, 2, 0, 2, 3);
            points.forEach((v_, i_, arr_) => {
                result.Vertices[i_] = new MeshVertex(v_, normal);
            });
            result.Vertices[0].UV0 = new U1.Vector2(0, 1);
            result.Vertices[1].UV0 = new U1.Vector2(1, 1);
            result.Vertices[2].UV0 = new U1.Vector2(1, 0);
            result.Vertices[3].UV0 = new U1.Vector2(0, 0);
            return result;
        }
        static CreateBox() {
            if (MeshGeometry.s_box == null) {
                var ps = [
                    new U1.Vector3(0, 0, 0),
                    new U1.Vector3(1, 0, 0),
                    new U1.Vector3(1, 1, 0),
                    new U1.Vector3(0, 1, 0),
                    new U1.Vector3(0, 0, 1),
                    new U1.Vector3(1, 0, 1),
                    new U1.Vector3(1, 1, 1),
                    new U1.Vector3(0, 1, 1)
                ];
                var front = MeshGeometry.CreateRectangle([ps[0], ps[1], ps[5], ps[4]]);
                var right = MeshGeometry.CreateRectangle([ps[1], ps[2], ps[6], ps[5]]);
                var back = MeshGeometry.CreateRectangle([ps[2], ps[3], ps[7], ps[6]]);
                var left = MeshGeometry.CreateRectangle([ps[3], ps[0], ps[4], ps[7]]);
                var top = MeshGeometry.CreateRectangle([ps[4], ps[5], ps[6], ps[7]]);
                var bottom = MeshGeometry.CreateRectangle([ps[2], ps[1], ps[0], ps[3]]);
                var trans = U1.Matrix4.CreateTranslation(new U1.Vector3(-0.5, -0.5, -0.5));
                MeshGeometry.s_box = new MeshGeometry();
                MeshGeometry.s_box.Merge(front, trans);
                MeshGeometry.s_box.Merge(right, trans);
                MeshGeometry.s_box.Merge(back, trans);
                MeshGeometry.s_box.Merge(left, trans);
                MeshGeometry.s_box.Merge(top, trans);
                MeshGeometry.s_box.Merge(bottom, trans);
            }
            return MeshGeometry.s_box.Clone();
        }
        static Merges(meshes) {
            var vlist = [];
            var ilist = [];
            var alist = [];
            var materials = meshes.filter(o_ => o_.Materials != null).length > 0 ? [] : null;
            var attr = 0;
            for (var i = 0; i < meshes.length; i++, attr++) {
                var mesh = meshes[i];
                var vstart = vlist.length;
                var fstart = ilist.length / 3;
                vlist.push(...mesh.Vertices);
                ilist.push(...mesh.Indexes.map(o_ => o_ + vstart));
                var fnum = mesh.Indexes.length / 3;
                for (var f = 0; f < fnum; f++) {
                    alist.push(attr);
                }
                if (materials != null) {
                    if (mesh.Materials != null)
                        materials.push(mesh.Materials[0]);
                    else
                        materials.push(new U1.MeshMaterial());
                }
            }
            var result = new MeshGeometry();
            result.Vertices = vlist;
            result.Indexes = ilist;
            result.Attributes = alist;
            result.Materials = materials;
            return result;
        }
        Merge(mesh, transform = null) {
            var vlist = this.Vertices == null ? new Array() : this.Vertices;
            var ilist = this.Indexes == null ? new Array() : this.Indexes;
            var alist = this.Attributes == null ? new Array() : this.Attributes;
            var last_i = vlist.length;
            var last_a = 0;
            if (this.Attributes != null) {
                last_a = (this.Attributes
                    .OrderBy(o_ => o_)
                    .reverse()[0]) + 1;
            }
            if (transform != null) {
                mesh.Vertices.forEach((v_, i_, arr_) => {
                    var nv = v_.Clone();
                    nv.Transform(transform);
                    vlist.push(nv);
                });
            }
            else {
                mesh.Vertices.forEach((v_, i_, arr_) => {
                    var nv = v_.Clone();
                    vlist.push(nv);
                });
            }
            mesh.Indexes.forEach((v_, i_, arr_) => {
                ilist.push(v_ + last_i);
            });
            mesh.Attributes.forEach((v_, i_, arr_) => {
                alist.push(v_ + last_i);
            });
            this.Vertices = vlist;
            this.Indexes = ilist;
            this.Attributes = alist;
        }
    }
    MeshGeometry.tmp_v2_0 = U1.Vector2.Zero;
    MeshGeometry.tmp_v2_1 = U1.Vector2.Zero;
    MeshGeometry.tmp_v2_2 = U1.Vector2.Zero;
    MeshGeometry.tmp_v2_3 = U1.Vector2.Zero;
    MeshGeometry.tmp_v3_0 = U1.Vector3.Zero;
    MeshGeometry.tmp_v3_1 = U1.Vector3.Zero;
    MeshGeometry.tmp_v3_2 = U1.Vector3.Zero;
    MeshGeometry.tmp_v3_3 = U1.Vector3.Zero;
    U1.MeshGeometry = MeshGeometry;
    class MeshVertex {
        constructor(pos = null, normal = null, uv = null) {
            this.Position = U1.Vector3.Zero;
            this.Normal = U1.Vector3.Zero;
            this.UV0 = U1.Vector2.Zero;
            if (pos != null)
                this.Position.CopyFrom(pos);
            if (normal != null)
                this.Normal.CopyFrom(normal);
            if (uv != null)
                this.UV0.CopyFrom(uv);
        }
        Clone() {
            var clone = new MeshVertex();
            clone.Position.CopyFrom(this.Position);
            clone.Normal.CopyFrom(this.Normal);
            clone.UV0.CopyFrom(this.UV0);
            return clone;
        }
        Transform(matrix) {
            this.Position.Transform(matrix);
            this.Normal.TransformNormal(matrix);
        }
    }
    U1.MeshVertex = MeshVertex;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class MeshUtil {
        static FillPolygon(polygon) {
            if (polygon[0] == polygon[polygon.length - 1])
                polygon = polygon.slice(0, polygon.length - 1);
            var normal = U1.Vector3.UnitZ;
            normal = U1.GeomUtils.GetNormal(polygon);
            var holes = null;
            var basepos = polygon[0];
            var mappingType = U1.MappingTypeEnum.RealWorldSize;
            var uvScale = 1;
            return this.FillPolygonWithHoles(polygon, holes, basepos, normal, mappingType, uvScale, new U1.CGAL.PolygonSet2());
        }
        static FillPolygonWithHoles(polygon, holes, basepos, normal, mappingType, uvScale, pgonset2) {
            var hasHoles = holes != null && holes.length > 0;
            let u = U1.Vector3.Zero;
            let v = U1.Vector3.Zero;
            pgonset2 = null;
            if (polygon.length < 3)
                return null;
            if (polygon[0] == polygon[polygon.length - 1])
                polygon = polygon.slice(0, polygon.length - 1);
            var v2List = U1.GeomUtils.Project2DList(polygon, basepos, normal, u, v);
            if (U1.Vector2.Distance(v2List[0], v2List[v2List.length - 1]) < 0.00001)
                v2List.slice(0, v2List.length - 1);
            var lt = U1.Vector2.LeftTop(v2List);
            var rb = U1.Vector2.RightBottom(v2List);
            var surfSize = new U1.Vector2();
            surfSize.X = Math.abs(lt.X - rb.X);
            surfSize.Y = Math.abs(lt.Y - rb.Y);
            var w = U1.Vector3.Normalize(U1.Vector3.Cross(u, v));
            var poly = new U1.CGAL.Polygon2();
            poly.Points = v2List;
            var isBoundaryCCW = poly.IsCCW();
            if (!isBoundaryCCW) {
                poly.Reverse();
            }
            var vList = new Array();
            var iList = new Array();
            var aList = new Array();
            var result = null;
            if (!hasHoles && poly.IsConvex()) {
                pgonset2 = new U1.CGAL.PolygonSet2(poly);
                result = this.FillConvexPolygon(polygon, basepos, normal, u, v);
                this.SetMappingType(mappingType, surfSize, result);
                return result;
            }
            var pset2 = new U1.CGAL.PolygonSet2(poly);
            if (hasHoles) {
                for (var hole of holes) {
                    var tv2List = U1.GeomUtils.Project2D(hole, basepos, u, v);
                    if (tv2List[0] == tv2List[tv2List.length - 1])
                        tv2List.slice(0, tv2List.length - 1);
                    var holePoly = new U1.CGAL.Polygon2();
                    holePoly.Points = tv2List;
                    if (holePoly.IsSimple()) {
                        if (!holePoly.IsCCW())
                            holePoly.Reverse();
                        try {
                            pset2.Difference(holePoly);
                        }
                        catch (_a) {
                        }
                    }
                }
            }
            for (var pwh2 of pset2.PolygonsWithHoles) {
                var lastV = vList.length;
                var trangulation = new U1.Triangulations.PolygonTriangulation2();
                trangulation.FillPWH(pwh2);
                var mesh2 = trangulation.GetMesh();
                for (var i = 0; i < mesh2.VList.length; i++) {
                    var v2 = mesh2.VList[i];
                    var uv = U1.Vector2.Subtract(v2, lt);
                    uv.Y *= -1;
                    var d3v = new U1.MeshVertex();
                    d3v.Position = U1.Vector3.Add(U1.Vector3.Add(new U1.Vector3(v2.X * u.X, v2.X * u.Y, v2.X * u.Z), new U1.Vector3(v2.Y * u.X, v2.Y * u.Y, v2.Y * u.Z)), basepos);
                    d3v.Normal = normal;
                    d3v.UV0 = uv;
                    vList.push(d3v);
                }
                for (var i = 0; i < mesh2.FList.length; i++) {
                    var face = mesh2.FList[i];
                    var i0 = (lastV + face.V0);
                    var i1 = (lastV + face.V1);
                    var i2 = (lastV + face.V2);
                    if (isBoundaryCCW) {
                        iList.push(i0);
                        iList.push(i1);
                        iList.push(i2);
                    }
                    else {
                        iList.push(i0);
                        iList.push(i2);
                        iList.push(i1);
                    }
                    aList.push(0);
                }
            }
            pgonset2 = pset2;
            var result = new U1.MeshGeometry();
            result.Vertices = vList;
            result.Indexes = iList;
            result.Attributes = aList;
            result.Materials = [];
            this.SetMappingType(mappingType, surfSize, result);
            return result;
        }
        static SetMappingType(mappingType, surfSize, result) {
            if (mappingType == U1.MappingTypeEnum.SurfaceSize) {
                for (var i = 0; i < result.Vertices.length; i++) {
                    result.Vertices[i].UV0.X = result.Vertices[i].UV0.X / surfSize.X;
                    result.Vertices[i].UV0.Y = result.Vertices[i].UV0.X / surfSize.Y;
                }
            }
            return result;
        }
        static FillConvexPolygon(polygon, basepos, normal, u, v) {
            var lt = new U1.Vector2(Number.MAX_VALUE, Number.MIN_VALUE);
            for (var p of polygon) {
                var p1 = new U1.Vector2();
                p1.X = U1.Vector3.Dot(u, U1.Vector3.Subtract(p, basepos));
                p1.Y = U1.Vector3.Dot(v, U1.Vector3.Subtract(p, basepos));
                if (p1.X < lt.X)
                    lt.X = p1.X;
                if (p1.Y > lt.Y)
                    lt.Y = p1.Y;
            }
            basepos = U1.Vector3.Add(U1.Vector3.Add(new U1.Vector3(u.X * lt.X, u.Y * lt.X, u.Z * lt.X), new U1.Vector3(v.X * lt.Y, v.Y * lt.Y, v.Z * lt.Y)), basepos);
            var varray = Array();
            polygon.forEach(o_ => {
                var meshVertex = new U1.MeshVertex();
                meshVertex.Position = o_;
                meshVertex.Normal = normal;
                var uv = new U1.Vector2();
                uv.X = U1.Vector3.Dot(U1.Vector3.Subtract(o_, basepos), u);
                uv.Y = U1.Vector3.Dot(U1.Vector3.Subtract(o_, basepos), new U1.Vector3(-v.X, -v.Y, -v.Z));
                meshVertex.UV0 = uv;
                varray.push(meshVertex);
            });
            var iarray = new Array((polygon.length - 2) * 3);
            var aarray = new Array(polygon.length - 2);
            var fc = 0;
            for (var i = 2; i < polygon.length; ++i, ++fc) {
                iarray[fc * 3] = 0;
                iarray[fc * 3 + 1] = i - 1;
                iarray[fc * 3 + 2] = i;
            }
            for (var i = 0; i < aarray.length; i++)
                aarray[i] = 0;
            var meshData = new U1.MeshGeometry();
            meshData.Vertices = varray;
            meshData.Indexes = iarray;
            meshData.Attributes = aarray;
            meshData.Materials = [];
            return meshData;
        }
        static Intersect_RayTriangle(ray, v0, v1, v2, dirCheck, res) {
            var s_ = MeshUtil[".s."] || (MeshUtil[".s."] = {});
            var u = s_.u || (s_.u = new U1.Vector3());
            var v = s_.v || (s_.v = new U1.Vector3());
            var n = s_.n || (s_.n = new U1.Vector3());
            var w0 = s_.w0 || (s_.w0 = new U1.Vector3());
            var w = s_.w || (s_.w = new U1.Vector3());
            u.SetSubtract(v1, v0);
            v.SetSubtract(v2, v0);
            n.SetCross(u, v);
            if (n.IsZero)
                return null;
            var dir = ray.Direction;
            w0.SetSubtract(ray.Position, v0);
            var a = U1.Vector3.Dot(n, w0);
            a *= -1;
            var b = U1.Vector3.Dot(n, dir);
            if (Math.abs(b) < 0.00001)
                return null;
            var r = a / b;
            res.r = r;
            if (dirCheck && r < 0)
                return null;
            var isectp = U1.Vector3.ScaleAdd(ray.Position, r, dir);
            var uu = U1.Vector3.Dot(u, u);
            var uv = U1.Vector3.Dot(u, v);
            var vv = U1.Vector3.Dot(v, v);
            w.SetSubtract(isectp, v0);
            var wu = U1.Vector3.Dot(w, u);
            var wv = U1.Vector3.Dot(w, v);
            var d = uv * uv - uu * vv;
            var s, t;
            res.u = s = (uv * wv - vv * wu) / d;
            if (s < 0.0 || s > 1.0)
                return null;
            res.v = t = (uv * wu - uu * wv) / d;
            if (t < 0.0 || (s + t) > 1.0)
                return null;
            return isectp;
        }
        static CheckEdgeCross(planes, sv, ev) {
            var c_in = 0;
            for (var pi = 0; pi < planes.length; pi++) {
                var ls = planes[pi].DotCoordinate(sv);
                var le = planes[pi].DotCoordinate(ev);
                if (ls > 0 && le > 0)
                    return false;
                if (ls <= 0 && le <= 0) {
                    c_in++;
                }
            }
            if (c_in == planes.length)
                return true;
            var dir = U1.Vector3.Zero;
            for (var pi = 0; pi < planes.length; pi++) {
                var ls = planes[pi].DotCoordinate(sv);
                var le = planes[pi].DotCoordinate(ev);
                if (ls * le < 0.0000001) {
                    dir.SetSubtract(ev, sv);
                    var t = planes[pi].IntersectsLine(sv, dir);
                    if (t == null)
                        continue;
                    var isect = U1.Vector3.ScaleAdd(sv, t, dir);
                    c_in = 0;
                    for (var i = 0; i < planes.length; i++) {
                        if (i == pi)
                            continue;
                        if (planes[i].DotCoordinate(isect) < 0)
                            c_in++;
                        else
                            break;
                    }
                    if (c_in == planes.length - 1)
                        return true;
                }
            }
            return false;
        }
    }
    U1.MeshUtil = MeshUtil;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Rectangle {
        constructor(x = 0, y = 0, width = 0, height = 0) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        get X() {
            return this.x;
        }
        set X(value) {
            this.x = value;
        }
        get Y() {
            return this.y;
        }
        set Y(value) {
            this.y = value;
        }
        get Width() {
            return this.width;
        }
        set Width(value) {
            this.width = value;
        }
        get Height() {
            return this.height;
        }
        set Height(value) {
            this.height = value;
        }
        get MinX() {
            return this.x;
        }
        get MinY() {
            return this.y;
        }
        get MaxX() {
            return this.x + this.width;
        }
        get MaxY() {
            return this.y + this.height;
        }
        get Left() {
            return this.X;
        }
        get Top() {
            return this.Y;
        }
        get Right() {
            return (this.X + this.Width);
        }
        get Bottom() {
            return (this.Y + this.Height);
        }
        get IsEmpty() {
            return ((((this.height == 0) && (this.width == 0)) && (this.x == 0)) && (this.y == 0));
        }
        Equals(obj) {
            if (!(obj instanceof Rectangle)) {
                return false;
            }
            var rectangle = obj;
            return ((((rectangle.X == this.X) && (rectangle.Y == this.Y)) && (rectangle.Width == this.Width)) && (rectangle.Height == this.Height));
        }
        Contains(x, y) {
            return ((((this.X <= x) && (x < (this.X + this.Width))) && (this.Y <= y)) && (y < (this.Y + this.Height)));
        }
        Contains1(x, y, w, h) {
            return ((((this.X <= x) && ((x + w) <= (this.X + this.Width))) && (this.Y <= y)) && ((y + h) <= (this.Y + this.Height)));
        }
        ContainsRect(rect) {
            return ((((this.X <= rect.X) && ((rect.X + rect.Width) <= (this.X + this.Width))) && (this.Y <= rect.Y)) && ((rect.Y + rect.Height) <= (this.Y + this.Height)));
        }
        GetHashCode() {
            return (((this.X ^ ((this.Y << 13) | (this.Y >> 0x13))) ^ ((this.Width << 0x1a) | (this.Width >> 6))) ^ ((this.Height << 7) | (this.Height >> 0x19)));
        }
        Inflate(width, height) {
            this.X -= width;
            this.Y -= height;
            this.Width += 2 * width;
            this.Height += 2 * height;
        }
        Set(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.width = w;
            this.height = h;
            return this;
        }
        static Inflate(rect, x, y) {
            var rectangle = new Rectangle(rect.x, rect.y, rect.width, rect.height);
            rectangle.Inflate(x, y);
            return rectangle;
        }
        Intersect(rect) {
            var rectangle = Rectangle.Intersect(rect, this);
            this.X = rectangle.X;
            this.Y = rectangle.Y;
            this.Width = rectangle.Width;
            this.Height = rectangle.Height;
        }
        static Intersect(a, b) {
            var x = Math.max(a.X, b.X);
            var num2 = Math.min((a.X + a.Width), (b.X + b.Width));
            var y = Math.max(a.Y, b.Y);
            var num4 = Math.min((a.Y + a.Height), (b.Y + b.Height));
            if ((num2 >= x) && (num4 >= y)) {
                return new Rectangle(x, y, num2 - x, num4 - y);
            }
            return new Rectangle(0, 0, 0, 0);
        }
        IntersectsWith(rect) {
            return ((((rect.X < (this.X + this.Width)) && (this.X < (rect.X + rect.Width))) && (rect.Y < (this.Y + this.Height))) && (this.Y < (rect.Y + rect.Height)));
        }
        IntersectsWith1(x, y, w, h) {
            return ((((x < (this.X + this.Width)) && (this.X < (x + w))) && (y < (this.Y + this.Height))) && (this.Y < (y + h)));
        }
        static Union(a, b) {
            var x = Math.min(a.X, b.X);
            var num2 = Math.max((a.X + a.Width), (b.X + b.Width));
            var y = Math.min(a.Y, b.Y);
            var num4 = Math.max((a.Y + a.Height), (b.Y + b.Height));
            return new Rectangle(x, y, num2 - x, num4 - y);
        }
        Union(b) {
            var a = this;
            var x = Math.min(a.X, b.X);
            var num2 = Math.max((a.X + a.Width), (b.X + b.Width));
            var y = Math.min(a.Y, b.Y);
            var num4 = Math.max((a.Y + a.Height), (b.Y + b.Height));
            this.x = x;
            this.y = y;
            this.width = num2 - x;
            this.height = num4 - y;
        }
        Offset(x, y) {
            this.X += x;
            this.Y += y;
        }
        Add(x, y) {
            var d1 = Math.min(this.MinX, x);
            var d2 = Math.max(this.MaxX, x);
            var d3 = Math.min(this.MinY, y);
            var d4 = Math.max(this.MaxY, y);
            this.Set(d1, d3, d2 - d1, d4 - d3);
        }
        static FromPoints(points, result) {
            var minx = Number.MAX_VALUE;
            var miny = Number.MAX_VALUE;
            var maxx = Number.MIN_VALUE;
            var maxy = Number.MIN_VALUE;
            for (var i = 0; i < points.length; i++) {
                var p = points[i];
                minx = minx > p.X ? p.X : minx;
                miny = miny > p.Y ? p.Y : miny;
                maxx = maxx < p.X ? p.X : maxx;
                maxy = maxx < p.Y ? p.Y : maxy;
            }
            result = result || new Rectangle();
            result.Set(minx, miny, maxx - minx, maxy - miny);
            return result;
        }
        toString() {
            return `${this.x},${this.y},${this.width},${this.height}`;
        }
    }
    U1.Rectangle = Rectangle;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var BRep;
    (function (BRep) {
        class Shell {
            constructor(other) {
                this._vertices = [];
                this._faces = [];
                this._id = Shell._id++;
                if (other instanceof Shell) {
                    this.Vertices = other.Vertices.map(o_ => o_.Clone());
                    this.Faces = other.Faces.map(o_ => {
                        var nf = o_.Clone();
                        nf.Shell = this;
                        return nf;
                    });
                }
            }
            get Vertices() {
                return this._vertices;
            }
            set Vertices(value) {
                this._vertices = value;
                if (this._vertices != null) {
                    var num = 0;
                    for (var v of this._vertices) {
                        v.Num = num++;
                    }
                }
            }
            get Faces() {
                return this._faces;
            }
            set Faces(value) {
                this._faces = value;
                if (this._faces != null) {
                    for (var f of this._faces)
                        f.Shell = this;
                }
            }
            get Edges() {
                return this._edges;
            }
            set Edges(value) {
                this._edges = value;
            }
            static get RANDOMVECTORS() {
                if (Shell._randomVectors === undefined) {
                    var rand = new U1.Random(1);
                    for (var i = 0; i < 100; i++) {
                        var x = rand.next() - 0.5;
                        var y = rand.next() - 0.5;
                        var z = rand.next() - 0.5;
                        var ray = new U1.Vector3(x, y, z);
                        ray.Normalize();
                        Shell._randomVectors[i] = ray;
                    }
                }
                return Shell._randomVectors;
            }
            get Octree() {
                if (this._octree === undefined) {
                    this._octree = U1.Octree.createOctree(this.Faces);
                }
                return this._octree;
            }
            get ID() {
                return this._id;
            }
            AddVertex(p, n, uv) {
                var nv = new BRep.Vertex(p);
                nv.Normal = n;
                nv.UV0 = uv;
                nv.Num = this.Vertices.length;
                this.Vertices.push(nv);
                return nv;
            }
            SplitEdge(p0, p1, amount) {
                var p = U1.Vector3.Lerp(p0, p1, amount);
                var nv = this.AddVertex(p);
                nv.SetLerp(p0, p1, amount);
                return nv;
            }
            SplitByShell(other) {
                var octree = other.Octree;
                var old_faces = this.Faces.slice();
                var new_faces = [];
                var ctr_faces = [];
                var ctd_fs = [];
                var tplane = new U1.Plane();
                for (var face of old_faces) {
                    ctr_faces.length = 0;
                    octree.searchBox(face.getMin(), face.getMax(), ctr_faces);
                    if (ctr_faces.length === 0) {
                        new_faces.push(face);
                        continue;
                    }
                    ctd_fs.length = 0;
                    ctd_fs.push(face);
                    for (var cutter of ctr_faces) {
                        var plane = tplane.SetFromPointNormal(other.Vertices[cutter.Boundary[0]], cutter.Normal);
                        var last = ctd_fs.length;
                        for (var i = 0; i < last; i++) {
                            var tface = ctd_fs[i];
                            if (tface.Deleted)
                                continue;
                            if (U1.GeometryHelper3.BoxBoxIntersection(tface.getMin(), tface.getMax(), cutter.getMin(), cutter.getMax()))
                                continue;
                            if (!tface.CheckCross(plane))
                                continue;
                            if (tface.CutByPlane(plane, ctd_fs, ctd_fs)) {
                                tface.Deleted = true;
                            }
                        }
                    }
                    new_faces.push(...ctd_fs.filter(o_ => !o_.Deleted));
                }
                this.Faces = new_faces;
            }
            AddFace(boundary, holes, mId) {
                var f = new BRep.Face();
                f.Shell = this;
                f.SetBoundary(boundary);
                f.SetHoles(holes);
                f.MId = mId;
                this._faces.push(f);
            }
            CheckInside(p) {
                var tv0 = Shell[".ci.v0"] || (Shell[".ci.v0"] = new U1.Vector3());
                if (this._octree === undefined) {
                    this._octree = U1.Octree.createOctree(this.Faces);
                }
                var faces = [];
                for (var i = 0; i < Shell.N_RANDOMS; i++) {
                    var dir = Shell.RANDOMVECTORS[i];
                    var opp = tv0.SetNegate(dir);
                    faces.length = 0;
                    this._octree.searchRay(p, dir, true, faces);
                    if (faces.length == 0)
                        return false;
                    var fcount = 0;
                    var bcount = 0;
                    for (var face of faces) {
                        if (face.CheckIntersectRay(p, dir) == U1.FaceIntersectionTypeEnum.Inside)
                            fcount++;
                        if (face.CheckIntersectRay(p, opp) == U1.FaceIntersectionTypeEnum.Inside)
                            bcount++;
                    }
                    if (fcount % 2 !== bcount % 2)
                        continue;
                    return fcount % 2 == 1;
                }
                return false;
            }
            static Union(a, b) {
                return null;
            }
            Read(reader, ver = 1) {
                var vertices = this.Vertices = [];
                var faces = this.Faces = [];
                var edges = this.Edges = [];
                var idx_byte = reader.ReadInt32();
                var v_num = reader.ReadInt32();
                if (v_num === 0)
                    return;
                var v_elm_num = reader.ReadInt8();
                var e_num = reader.ReadInt32();
                var f_num = reader.ReadInt32();
                for (var i = 0; i < v_num; i++) {
                    var v = new BRep.Vertex();
                    v.X = reader.ReadFloat32();
                    v.Y = reader.ReadFloat32();
                    v.Z = reader.ReadFloat32();
                    if (v_elm_num > 1) {
                        var n = new U1.Vector3();
                        n.X = reader.ReadFloat32();
                        n.Y = reader.ReadFloat32();
                        n.Z = reader.ReadFloat32();
                        v.Normal = n;
                    }
                    if (v_elm_num > 2) {
                        var uv = new U1.Vector2();
                        uv.X = reader.ReadFloat32();
                        uv.Y = reader.ReadFloat32();
                        v.UV0 = uv;
                    }
                    vertices.push(v);
                }
                for (var i = 0; i < e_num; i++) {
                    if (idx_byte === 8)
                        edges.push(reader.ReadUint8());
                    else if (idx_byte === 16)
                        edges.push(reader.ReadInt16());
                    else
                        edges.push(reader.ReadInt32());
                }
                for (var i = 0; i < f_num; i++) {
                    var face = new BRep.Face();
                    face.Shell = this;
                    var f_stat = reader.ReadInt16();
                    var tri_num = reader.ReadInt16();
                    var pgon_num = reader.ReadInt16();
                    face.State = f_stat;
                    var triFaces = [];
                    for (let j = 0; j < tri_num; j++) {
                        if (idx_byte === 8)
                            triFaces[j] = reader.ReadUint8();
                        else if (idx_byte === 16)
                            triFaces[j] = reader.ReadInt16();
                        else
                            triFaces[j] = reader.ReadInt32();
                    }
                    face.TriFaces = triFaces;
                    for (let j = 0; j < pgon_num; j++) {
                        var pnt_num = reader.ReadInt16();
                        var indics = new Array(pnt_num);
                        for (let k = 0; k < pnt_num; k++) {
                            if (idx_byte === 8)
                                indics[k] = reader.ReadUint8();
                            else if (idx_byte === 16)
                                indics[k] = reader.ReadInt16();
                            else
                                indics[k] = reader.ReadInt32();
                        }
                        if (j == 0)
                            face.Boundary = indics;
                        else {
                            if (face.Holes === undefined)
                                face.Holes = [];
                            face.Holes.push(indics);
                        }
                    }
                    faces.push(face);
                }
            }
            Merge(other) {
                if (this == other)
                    return;
                if (this.Vertices == other.Vertices) {
                    if (other.Edges != null) {
                        this.Edges = this.Edges || [];
                        this.Edges.push(...other.Edges);
                    }
                    if (other.Faces != null) {
                        var faces = this.Faces || [];
                        faces.push(...other.Faces.map(o_ => o_.Clone()));
                        this.Faces = faces;
                    }
                    return;
                }
                var vstart = this.Vertices.length;
                var vs = this.Vertices;
                other.Vertices.forEach(o_ => {
                    let nv = o_.Clone();
                    nv.Num += vstart;
                    vs.push(nv);
                });
                var update_ = (v_, i_, arr_) => {
                    arr_[i_] += vstart;
                };
                if (other.Faces != null) {
                    let faces = this.Faces || [];
                    for (let f of other.Faces) {
                        var nf = f.Clone();
                        nf.Boundary.forEach(update_);
                        if (nf.HasHoles) {
                            for (let h of nf.Holes) {
                                h.forEach(update_);
                            }
                        }
                        faces.push(nf);
                    }
                    this.Faces = faces;
                }
                if (other.Edges != null) {
                    this.Edges = this.Edges || [];
                    this.Edges.push(...other.Edges.map(o_ => o_ + vstart));
                }
            }
        }
        Shell.N_RANDOMS = 100;
        Shell._id = 0;
        BRep.Shell = Shell;
    })(BRep = U1.BRep || (U1.BRep = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Octree {
        constructor(allNodes, level, maxLevel, minLevelNodes) {
            this.min = U1.Vector3.MaxValue;
            this.max = U1.Vector3.MinValue;
            var center = new U1.Vector3();
            for (var i = 0; i < allNodes.length; i++) {
                var node = allNodes[i];
                var min = node.getMin();
                var max = node.getMax();
                this.addToBound(min);
                this.addToBound(max);
                center.Add(min);
                center.Add(max);
            }
            center.Scale(1.0 / (allNodes.length * 2));
            var nodes = [];
            var subNodes = null;
            for (var i = 0; i < allNodes.length; i++) {
                var nodeData = allNodes[i];
                var index = -1;
                if (level < maxLevel) {
                    index = Octree.getOctreeIndex(nodeData, center);
                }
                if (index == -1) {
                    if (nodes == null) {
                        nodes = [];
                    }
                    nodes.push(nodeData);
                }
                else {
                    if (subNodes == null) {
                        subNodes = new Array(8);
                    }
                    if (subNodes[index] == null) {
                        var initialSize = Math.max(allNodes.length / 8, 4);
                        subNodes[index] = new Array(initialSize);
                    }
                    subNodes[index].push(nodeData);
                }
            }
            var children = null;
            if (subNodes != null) {
                for (var i = 0; i < subNodes.length; i++) {
                    var subNodeData = subNodes[i];
                    if (subNodeData != null) {
                        if (subNodeData.length > minLevelNodes) {
                            if (children == null) {
                                children = new Array(8);
                            }
                            children[i] = new Octree(subNodeData, level + 1, maxLevel, minLevelNodes);
                        }
                        else {
                            if (nodes == null) {
                                nodes = new Array();
                            }
                            nodes.AddRange(subNodeData);
                        }
                    }
                }
            }
            this.childArray = (children != null ? children : null);
            this.nodeArray = ((nodes != null) && (nodes.length > 0) ? nodes.slice() : null);
        }
        static getOctreeIndex(node, point) {
            var index = 0;
            var min = node.getMin();
            var max = node.getMax();
            if (min.X > point.X) {
                index += 4;
            }
            else if (max.X >= point.X) {
                return -1;
            }
            if (min.Y > point.Y) {
                index += 2;
            }
            else if (max.Y >= point.Y) {
                return -1;
            }
            if (min.Z > point.Z) {
                index++;
            }
            else if (max.Z >= point.Z) {
                return -1;
            }
            return index;
        }
        static createOctree(nodes) {
            return Octree.createOctree1(nodes, 8, 16);
        }
        static createOctree1(nodes, maxLevel, minLevelNodes) {
            return new Octree(nodes, 0, maxLevel, minLevelNodes);
        }
        addToBound(p) {
            this.min.X = Math.min(this.min.X, p.X);
            this.min.Y = Math.min(this.min.Y, p.Y);
            this.min.Z = Math.min(this.min.Z, p.Z);
            this.max.X = Math.max(this.max.X, p.X);
            this.max.Y = Math.max(this.max.Y, p.Y);
            this.max.Z = Math.max(this.max.Z, p.Z);
        }
        getChildren() {
            return this.childArray;
        }
        getMin() {
            return this.min;
        }
        getMax() {
            return this.max;
        }
        searchRay(rayOrigin, rayDir, checkDir, result) {
            if (U1.GeometryHelper3.RayBoxIntersection(rayOrigin, rayDir, this.min, this.max, checkDir)) {
                if (this.nodeArray != null) {
                    for (var i = 0; i < this.nodeArray.length; i++) {
                        var node = this.nodeArray[i];
                        if (U1.GeometryHelper3.RayBoxIntersection(rayOrigin, rayDir, node.getMin(), node.getMax(), checkDir)) {
                            result.push(this.nodeArray[i]);
                        }
                    }
                }
                if (this.childArray != null) {
                    for (var i = 0; i < this.childArray.length; i++) {
                        var tree = this.childArray[i];
                        if (tree != null) {
                            tree.searchRay(rayOrigin, rayDir, checkDir, result);
                        }
                    }
                }
            }
        }
        searchBox(searchMin, searchMax, result) {
            if (U1.GeometryHelper3.BoxBoxIntersection(searchMin, searchMax, this.min, this.max)) {
                if (this.nodeArray != null) {
                    for (var i = 0; i < this.nodeArray.length; i++) {
                        var node = this.nodeArray[i];
                        if (U1.GeometryHelper3.BoxBoxIntersection(searchMin, searchMax, node.getMin(), node.getMax())) {
                            result.push(this.nodeArray[i]);
                        }
                    }
                }
                if (this.childArray != null) {
                    for (var i = 0; i < this.childArray.length; i++) {
                        var tree = this.childArray[i];
                        if (tree != null) {
                            tree.searchBox(searchMin, searchMax, result);
                        }
                    }
                }
            }
        }
    }
    Octree.DEFAULT_MAX_LEVEL = 8;
    Octree.DEFAULT_MIN_LEVEL_DATA = 16;
    Octree.INDEX_POSITIVE_X = 4;
    Octree.INDEX_POSITIVE_Y = 2;
    Octree.INDEX_POSITIVE_Z = 1;
    Octree.INDEX_NONE = -1;
    U1.Octree = Octree;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    class Cookie {
        static setCookie(cname, cvalue, exdays = 1000) {
            var d = new Date();
            d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
            var expires = "expires=" + d.toUTCString();
            document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
        }
        static getCookie(cname) {
            var name = cname + "=";
            var decodedCookie = decodeURIComponent(document.cookie);
            var ca = decodedCookie.split(';');
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                    return c.substring(name.length, c.length);
                }
            }
            return "";
        }
    }
    U1.Cookie = Cookie;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    let ContainmentType;
    (function (ContainmentType) {
        ContainmentType[ContainmentType["Disjoint"] = 0] = "Disjoint";
        ContainmentType[ContainmentType["Contains"] = 1] = "Contains";
        ContainmentType[ContainmentType["Intersects"] = 2] = "Intersects";
    })(ContainmentType = U1.ContainmentType || (U1.ContainmentType = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class VcControl {
            constructor() {
                this._ver = 0;
                this._updatever = 0;
                this.Order = 0;
                this.AfterMouseDown = new U1.Event2();
                this.AfterMouseUp = new U1.Event2();
            }
            get Container() {
                return this._container;
            }
            set Container(value) {
                if (value == null)
                    throw "Container must be null";
                this._container = value;
            }
            get IsDisposed() {
                return this._isDisposed;
            }
            get View() {
                return this.Container.View;
            }
            get Scene() {
                return this.View.Scene;
            }
            get Transform() {
                return this._transform;
            }
            set Transform(value) {
                if (this._transform === value)
                    return;
                this._transform = value;
                this.MarkChanged();
            }
            MarkChanged() {
                this._ver++;
                if (this.View != null)
                    this.View.Invalidate();
            }
            CheckIntersect(isectContext) {
                return null;
            }
            Update() {
                this.OnUpdate();
            }
            OnUpdate() {
            }
            Dispose() {
                if (this._isDisposed === true)
                    return;
                this._isDisposed = true;
                this._container.RemoveControl(this);
                this.Clear();
                this.AfterMouseDown = null;
            }
            Clear() {
            }
            OnMouseEnter(ev) {
                return false;
            }
            OnMouseLeave(ev) {
                return false;
            }
            OnMouseMove(ev) {
                return false;
            }
            OnMouseUp(ev) {
                this.AfterMouseUp.Invoke(this, ev);
                return false;
            }
            OnMouseDown(ev) {
                this.AfterMouseDown.Invoke(this, ev);
                return false;
            }
            OnMouseWheel(ev) {
                return false;
            }
            OnPress(ev) {
                return false;
            }
            OnPanMove(ev) {
                return false;
            }
            OnPanStart(ev) {
                return false;
            }
            OnPanEnd(ev) {
                return false;
            }
            OnPinch(ev) {
                return false;
            }
            OnTouchStart(ev) {
                return false;
            }
            OnTouchMove(ev) {
                return false;
            }
            OnTouchEnd(ev) {
                return false;
            }
            Invalidate() {
                if (this.View != null)
                    this.View.Invalidate();
            }
            get PropertyChanged() {
                if (this._propertyChanged === undefined)
                    this._propertyChanged = new U1.PropertyChangedEvent();
                return this._propertyChanged;
            }
            InvokePropertyChanged(prop) {
                if (this._propertyChanged != null)
                    this._propertyChanged.Invoke(this, prop);
            }
        }
        Views.VcControl = VcControl;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class VcNavigator extends Views.VcControl {
            OnUpdate() {
                if (this._meshModel == null) {
                }
            }
        }
        Views.VcNavigator = VcNavigator;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class VcXForm extends Views.VcControl {
            constructor() {
                super();
                this.TM_Mode = VcXForm.TM_Modes.None;
                this.CanScale = true;
                this.CanRotate = true;
                this.CanMove = true;
                this.CanMovePivot = true;
            }
            get OBB() {
                if (this.GetOBB != null)
                    return this.GetOBB(this);
                return this._obb;
            }
            set OBB(value) {
                this._obb = value;
                if (this.SetOBB != null)
                    this.SetOBB(this, value);
                this.Invalidate();
            }
            get Color() {
                if (this.GetColor != null)
                    return this.GetColor(this);
                return this._color;
            }
            set Color(value) {
                this._color = value;
                if (this.SetColor != null)
                    this.SetColor(this, value);
            }
            get HasPivot() {
                var result = this.GetPivot != null ? this.GetPivot(this) : null;
                if (result == null)
                    return false;
                return true;
            }
            get Center() {
                return this.OBB != null ? this.OBB.Center : null;
            }
            get Pivot() {
                var result = this.GetPivot != null ? this.GetPivot(this) : this._pivot;
                return result;
            }
            set Pivot(value) {
                this._pivot = value;
                if (this.SetPivot != null) {
                    this.SetPivot(this, value);
                    this.Invalidate();
                }
            }
            get CanScale() {
                return this.m_canScale;
            }
            set CanScale(value) {
                this.m_canScale = value;
            }
            get CanRotate() {
                return this.m_canRotate;
            }
            set CanRotate(value) {
                this.m_canRotate = value;
            }
            get CanMove() {
                return this.m_canMove;
            }
            set CanMove(value) {
                this.m_canMove = value;
            }
            get CanMovePivot() {
                return this.m_canMovePivot;
            }
            set CanMovePivot(value) {
                this.m_canMovePivot = value;
            }
            BeginMove() {
                if (!this.CanMove)
                    return;
                this.m_oldOBB = new U1.OrientedBox3().CopyFrom(this.OBB);
                this.old_pivot = new U1.Vector3(this.Pivot != null ? this.Pivot : this.Center);
                this.has_pivot = this.HasPivot;
                this.MovingFrom = U1.Vector3.Zero;
                this.MovingTo = U1.Vector3.Zero;
                this.TM_Mode = VcXForm.TM_Modes.Move;
                if (this.OnBeginMove != null)
                    this.OnBeginMove(this);
            }
            Move(from, to) {
                if (!this.CanMove)
                    return;
                this.MakeSnapped(from, to);
                let offset = U1.Vector3.Subtract(to, from);
                let obb = this.m_oldOBB.Clone();
                let tm = U1.Matrix4.CreateTranslation(offset);
                obb.Transform(tm);
                this.OBB = obb;
                this.Pivot = this.old_pivot.Clone().Add(offset);
                var tc = {
                    TM: tm,
                    From: from,
                    To: to,
                    Offset: offset
                };
                if (this.OnMove != null)
                    this.OnMove(this, tc);
                this.InvokePropertyChanged("Move");
            }
            EndMove(from, to) {
                if (!this.CanMove)
                    return;
                this.MakeSnapped(from, to);
                let offset = U1.Vector3.Subtract(to, from);
                let tm = U1.Matrix4.CreateTranslation(offset);
                var tc = {
                    TM: tm,
                    From: from,
                    To: to,
                    Offset: offset
                };
                if (this.OnEndMove != null)
                    this.OnEndMove(this, tc);
                this.TM_Mode = VcXForm.TM_Modes.None;
                this.InvokePropertyChanged("EndMove");
            }
            CancelMove() {
                if (!this.CanMove)
                    return;
                if (this.OnCancelMove != null)
                    this.OnCancelMove(this);
                if (this.has_pivot)
                    this.Pivot = this.old_pivot;
                else
                    this.Pivot = null;
                this.TM_Mode = VcXForm.TM_Modes.None;
                this.InvokePropertyChanged("EndMove");
            }
            MakeSnapped(from, to) {
                var obb = new U1.OrientedBox3(this.m_oldOBB);
                var offset = U1.Vector3.Subtract(to, from);
                obb.Center.Add(offset);
                var o_bx = U1.BoundingBox.CreateFromPoints(this.m_oldOBB.GetVs());
                var c_bx = U1.BoundingBox.CreateFromPoints(obb.GetVs());
                var o_lt = new U1.Vector3(o_bx.Min.X, o_bx.Max.Y, o_bx.Min.Z);
                var c_lt = new U1.Vector3(c_bx.Min.X, c_bx.Max.Y, c_bx.Min.Z);
                offset.SetSubtract(c_lt, o_lt);
                to.SetAdd(from, offset);
                this.MovingFrom = from;
                this.MovingTo = to;
            }
            BeginMovePivot() {
                if (!this.CanMovePivot)
                    return;
                this.TM_Mode = VcXForm.TM_Modes.MovePivot;
                this.m_oldOBB = new U1.OrientedBox3(this.OBB);
                this.old_pivot = new U1.Vector3(this.Pivot != null ? this.Pivot : this.Center);
                if (this.OnBeginMovePivot != null)
                    this.OnBeginMovePivot(this);
            }
            MovePivot(from, to) {
                if (!this.CanMovePivot)
                    return;
                let offset = U1.Vector3.Subtract(to, from);
                let tm = U1.Matrix4.CreateTranslation(offset);
                this.Pivot = U1.Vector3.Add(this.old_pivot, offset);
                var tc = {
                    TM: tm,
                    From: from,
                    To: to,
                    Offset: offset
                };
                if (this.OnMovePivot != null)
                    this.OnMovePivot(this, tc);
            }
            EndMovePivot(from, to) {
                if (!this.CanMovePivot)
                    return;
                let offset = U1.Vector3.Subtract(to, from);
                let tm = U1.Matrix4.CreateTranslation(offset);
                var tc = {
                    TM: tm,
                    From: from,
                    To: to,
                    Offset: offset
                };
                if (this.OnEndMovePivot != null)
                    this.OnEndMovePivot(this, tc);
                this.Pivot = U1.Vector3.Add(this.old_pivot, offset);
                this.TM_Mode = VcXForm.TM_Modes.None;
            }
            CancelMovePivot() {
                if (!this.CanMovePivot)
                    return;
                if (this.OnCancelMovePivot != null)
                    this.OnCancelMovePivot(this);
                this.Pivot = null;
                this.TM_Mode = VcXForm.TM_Modes.None;
            }
            BeginRotate() {
                if (!this.CanRotate)
                    return;
                this.TM_Mode = VcXForm.TM_Modes.Rotate;
                this.m_oldOBB = new U1.OrientedBox3(this.OBB);
                if (this.OnBeginRotate != null)
                    this.OnBeginRotate(this);
            }
            Rotate(cent, norm, from, to) {
                if (!this.CanRotate)
                    return;
                var angle = U1.GeometryHelper3.AngleCCW(U1.Vector3.Subtract(from, cent), norm, U1.Vector3.Subtract(to, cent));
                var rm = U1.Matrix4.CreateTranslation(U1.Vector3.Negate(cent)).Multiply(U1.Matrix4.CreateFromAxisAngle(norm, angle)).Multiply(U1.Matrix4.CreateTranslation(cent));
                var obb = new U1.OrientedBox3(this.m_oldOBB);
                obb.Center = U1.Vector3.Transform(obb.Center, rm);
                obb.Axes = obb.Axes.map(o_ => U1.Vector3.TransformNormal(o_, rm));
                this.OBB = obb;
                var rc = {
                    RM: rm,
                    Base: cent,
                    Norm: norm,
                    Angle: angle,
                    From: from,
                    To: to
                };
                if (this.OnRotate != null)
                    this.OnRotate(this, rc);
            }
            EndRotate(cent, norm, from, to) {
                if (!this.CanRotate)
                    return;
                var angle = U1.GeometryHelper3.AngleCCW(U1.Vector3.Subtract(from, cent), norm, U1.Vector3.Subtract(to, cent));
                var rm = U1.Matrix4.CreateTranslation(U1.Vector3.Negate(cent)).Multiply(U1.Matrix4.CreateFromAxisAngle(norm, angle)).Multiply(U1.Matrix4.CreateTranslation(cent));
                var rc = {
                    RM: rm,
                    Base: cent,
                    Norm: norm,
                    Angle: angle,
                    From: from,
                    To: to
                };
                if (this.OnEndRotate != null)
                    this.OnEndRotate(this, rc);
                this.TM_Mode = VcXForm.TM_Modes.None;
            }
            CancelRotate() {
                if (!this.CanRotate)
                    return;
                if (this.OnCancelMove != null)
                    this.OnCancelMove(this);
                this.TM_Mode = VcXForm.TM_Modes.None;
            }
            BeginScale() {
                if (!this.CanScale)
                    return;
                this.TM_Mode = VcXForm.TM_Modes.Scale;
                this.m_oldOBB = new U1.OrientedBox3(this.OBB);
                if (this.OnBeginScale != null)
                    this.OnBeginScale(this);
            }
            Scale(cent, from, to) {
                if (!this.CanScale)
                    return;
                var obb = new U1.OrientedBox3(this.m_oldOBB);
                this.OBB = U1.OrientedBox3.ScaleWithTowPoints(obb, cent, from, to);
                var sm = U1.OrientedBox3.GetMatrixBetween(this.m_oldOBB, this.OBB);
                var sc = {
                    Base: cent,
                    From: from,
                    To: to,
                    SM: sm
                };
                if (this.OnScale != null)
                    this.OnScale(this, sc);
            }
            EndScale(cent, from, to) {
                if (!this.CanScale)
                    return;
                var obb = new U1.OrientedBox3(this.m_oldOBB);
                this.OBB = U1.OrientedBox3.ScaleWithTowPoints(obb, cent, from, to);
                var sm = U1.OrientedBox3.GetMatrixBetween(this.m_oldOBB, this.OBB);
                var sc = {
                    Base: cent,
                    From: from,
                    To: to,
                    SM: sm
                };
                if (this.OnEndScale != null)
                    this.OnEndScale(this, sc);
                this.TM_Mode = VcXForm.TM_Modes.None;
            }
            CancelScale() {
                if (!this.CanScale)
                    return;
                if (this.OnCancelScale != null)
                    this.OnCancelScale(this);
                this.TM_Mode = VcXForm.TM_Modes.None;
            }
            Init(nodes) {
                var s_;
                s_ = VcXForm[".ini."] || (VcXForm[".ini."] = s_ = {
                    v0: new U1.Vector3,
                    v1: new U1.Vector3,
                    v2: new U1.Vector3,
                    m0: new U1.Matrix4
                });
                var tmp_1 = s_.v0;
                var tmp_2 = s_.v1;
                var tmp_3 = s_.v2;
                var tmp_m1 = s_.m0;
                var min = tmp_1.SetMaxValue();
                var max = tmp_2.SetMinValue();
                var p = tmp_3;
                var tm = tmp_m1;
                var prsnt3s = [];
                for (var node of nodes) {
                    let prsent = node.Presenter;
                    if (prsent instanceof Views.UElementPresenter3D) {
                        if (prsnt3s.indexOf(prsent) < 0) {
                            prsnt3s.push(prsent);
                        }
                    }
                }
                {
                    for (var node of nodes) {
                        var wm = node.WorldTransform;
                        tm.CopyFrom(wm);
                        node.BoundingBox.GetCorners()
                            .forEach((v_, i_) => {
                            p.SetTransform(v_, tm);
                            min.Minimize(p);
                            max.Maximize(p);
                        });
                    }
                    let obb = this.OBB || (this.OBB = new U1.OrientedBox3());
                    obb.Center.SetAdd(min, max).Scale(0.5);
                    obb.Axes[0].Set(1, 0, 0);
                    obb.Axes[1].Set(0, 1, 0);
                    obb.Axes[2].Set(0, 0, 1);
                    obb.Extents[0] = (max.X - min.X) * 0.5;
                    obb.Extents[1] = (max.Y - min.Y) * 0.5;
                    obb.Extents[2] = (max.Z - min.Z) * 0.5;
                }
            }
            Clear() {
                this.GetOBB = undefined;
                this.SetOBB = undefined;
                this.GetColor = undefined;
                this.SetColor = undefined;
                this.GetPivot = undefined;
                this.SetPivot = undefined;
                this.OnBeginRotate = undefined;
                this.OnBeginMove = undefined;
                this.OnBeginScale = undefined;
                this.OnBeginMovePivot = undefined;
                this.OnMove = undefined;
                this.OnRotate = undefined;
                this.OnScale = undefined;
                this.OnMovePivot = undefined;
                this.OnEndRotate = undefined;
                this.OnEndMove = undefined;
                this.OnEndScale = undefined;
                this.OnEndMovePivot = undefined;
                this.OnCancelRotate = undefined;
                this.OnCancelMove = undefined;
                this.OnCancelScale = undefined;
                this.OnCancelMovePivot = undefined;
            }
        }
        VcXForm.TM_Modes = {
            None: 0,
            Move: 1,
            Rotate: 2,
            Scale: 3,
            MovePivot: 4
        };
        Views.VcXForm = VcXForm;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class MathExtensions {
            static WithinEpsilon(a, b) {
                var num = a - b;
                return -1.401298E-45 <= num && num <= 1.401298E-45;
            }
            static Project1(source, matrix) {
                var vector = U1.Vector3.Transform(source, matrix);
                var a = (((source.X * matrix.M14) + (source.Y * matrix.M24)) + (source.Z * matrix.M34)) + matrix.M44;
                if (!MathExtensions.WithinEpsilon(a, 1) && !MathExtensions.WithinEpsilon(a, 0)) {
                    vector = vector.Scale(1 / a);
                }
                return vector;
            }
            static Project2(source, projection, view, world, minDepth, maxDepth, x, y, width, heiht) {
                var matrix = U1.Matrix4.Multiply(U1.Matrix4.Multiply(world, view), projection);
                var vector = U1.Vector3.Transform(source, matrix);
                var a = (((source.X * matrix.M14) + (source.Y * matrix.M24)) + (source.Z * matrix.M34)) + matrix.M44;
                if (!U1.WithinEpsilon(a, 1) && !U1.WithinEpsilon(a, 0)) {
                    vector = (vector.Scale(1 / a));
                }
                vector.X = (((vector.X + 1) * 0.5) * width) + x;
                vector.Y = (((-vector.Y + 1) * 0.5) * heiht) + y;
                vector.Z = (vector.Z * (maxDepth - minDepth)) + minDepth;
                return vector;
            }
        }
        Views.MathExtensions = MathExtensions;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        let RenderingPriorityEnum;
        (function (RenderingPriorityEnum) {
            RenderingPriorityEnum[RenderingPriorityEnum["Normal"] = 0] = "Normal";
            RenderingPriorityEnum[RenderingPriorityEnum["High"] = 1] = "High";
            RenderingPriorityEnum[RenderingPriorityEnum["Low"] = 2] = "Low";
        })(RenderingPriorityEnum = Views.RenderingPriorityEnum || (Views.RenderingPriorityEnum = {}));
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class UDocumentPresenter {
            constructor() {
                this.document = null;
                this.view = null;
                this._elementPresenters = {};
                this.m_selection = new Array();
                this.m_selectionBoxDirty = true;
                this.m_sortedPresenters = [];
            }
            static Register(ecreater, pcreate) {
                var funcNameRegex = /function (.{1,})\(/;
                var results = (funcNameRegex).exec(ecreater.toString());
                var name = (results && results.length > 1) ? results[1] : "";
                UDocumentPresenter.Creaters[name] = pcreate;
            }
            get Document() {
                return this.document;
            }
            set Document(value) {
                if (this.document == value)
                    return;
                if (this.document != null) {
                    this.document.ElementAdded.Remove(this, this.OnElementAdded);
                    this.document.ElementRemoving.Remove(this, this.OnElementRemoving);
                    this.document.ElementChanged.Remove(this, this.OnElementPropertyChanged);
                    this.document.Selection.SelectionChanged.Remove(this, this.OnSelectionChanged);
                    this.document.AfterUndoRedo.Remove(this, this.OnAfterUndoRedo);
                    this.document.AfterLoaded.Remove(this, this.OnAfterLoaded);
                    this.document.AfterClear.Remove(this, this.OnAfterClear);
                    this.document.AfterAbortTransaction.Remove(this, this.OnAfterAbortTransaction);
                    this.document.AfterEndTransaction.Remove(this, this.OnAfterEndTransaction);
                }
                this.document = value;
                if (this.document != null) {
                    this.document.ElementAdded.Add(this, this.OnElementAdded);
                    this.document.ElementRemoving.Add(this, this.OnElementRemoving);
                    this.document.ElementChanged.Add(this, this.OnElementPropertyChanged);
                    this.document.Selection.SelectionChanged.Add(this, this.OnSelectionChanged);
                    this.document.AfterUndoRedo.Add(this, this.OnAfterUndoRedo);
                    this.document.AfterLoaded.Add(this, this.OnAfterLoaded);
                    this.document.AfterClear.Add(this, this.OnAfterClear);
                    this.document.AfterAbortTransaction.Add(this, this.OnAfterAbortTransaction);
                    this.document.AfterEndTransaction.Add(this, this.OnAfterEndTransaction);
                }
                for (var elm of this.document.Elements) {
                    this.OnElementAdded(this.document, elm);
                }
            }
            get View() {
                return this.view;
            }
            set View(value) {
                this.view = value;
            }
            get Selection() {
                return this.m_selection;
            }
            get ElementPresenters() {
                return this._elementPresenters;
            }
            Update() {
                var sortedPresenters = this.m_sortedPresenters;
                if (sortedPresenters.length == 0) {
                    for (var p in this._elementPresenters) {
                        var elmPresenter = this._elementPresenters[p];
                        if (elmPresenter != null) {
                            sortedPresenters.push(elmPresenter);
                        }
                    }
                    sortedPresenters.sort((a_, b_) => {
                        if (a_.Order === b_.Order)
                            return 0;
                        if (a_.Order === undefined)
                            return 1;
                        if (b_.Order === undefined)
                            return -1;
                        return a_.Order < b_.Order ? -1 : 1;
                    });
                }
                for (var elmPresenter of sortedPresenters) {
                    if (elmPresenter.Invalid && elmPresenter.Element != null) {
                        elmPresenter.Update();
                        elmPresenter.Invalid = false;
                    }
                }
                if (this.m_selectionBoxDirty) {
                    this.m_selectionBoxDirty = false;
                    this.ShowSelectionBox();
                }
            }
            InvalidateAll() {
                var presentres = this.ElementPresenters;
                for (var idx in presentres) {
                    var presenter = presentres[idx];
                    presenter.Invalid = true;
                }
                this.m_sortedPresenters.length = 0;
                this.view.Invalidate();
            }
            OnElementAdded(doc_, elm_) {
                this.OnAttach(elm_);
                this.m_sortedPresenters.length = 0;
            }
            OnElementRemoving(doc_, elm_) {
                var elemPresenter = this._elementPresenters[elm_.ID];
                if (elemPresenter != null) {
                    elemPresenter.Dispose();
                    delete this._elementPresenters[elm_.ID];
                    this.View.Invalidate();
                }
            }
            OnElementPropertyChanged(doc_, elem, prop) {
                if (this._elementPresenters[elem.ID] != null) {
                    this._elementPresenters[elem.ID].OnElementPropertyChanged(elem, prop);
                }
            }
            OnSelectionChanged(selectin) {
                var oldSelection = this.m_selection.splice(0);
                var sel_elements = selectin.SelectedElements;
                var self = this;
                sel_elements.forEach(elm => {
                    var presenter = self._elementPresenters[elm.ID];
                    if (presenter instanceof Views.UElementPresenter3D) {
                        var idx = oldSelection.indexOf(presenter);
                        if (idx > -1) {
                            oldSelection.splice(idx, 1);
                        }
                        this.m_selection.push(presenter);
                    }
                });
                oldSelection.forEach(o_ => {
                    o_.IsSelected = false;
                });
                this.m_selection.forEach(o_ => {
                    o_.IsSelected = true;
                });
                this.ShowSelectionBox();
                this.View.Invalidate();
            }
            OnAfterUndoRedo(doc, isUndo) {
                this.m_selectionBoxDirty = true;
                this.View.Invalidate();
            }
            OnAfterLoaded(doc) {
                for (var elm of doc.Elements) {
                    this.OnAttach(elm);
                }
                this.InvalidateAll();
            }
            OnAfterClear(doc) {
                this.Clear();
            }
            OnAfterAbortTransaction(doc) {
                this.m_selectionBoxDirty = true;
                this.View.Invalidate();
            }
            OnAfterEndTransaction(doc) {
                this.m_selectionBoxDirty = true;
                this.View.Invalidate();
            }
            OnAttach(elm) {
                var presenter = this.CreatePresenter(elm);
                if (presenter != null) {
                    presenter.Element = elm;
                    presenter.DocumentPresesnter = this;
                    this._elementPresenters[elm.ID] = presenter;
                    this.View.Invalidate();
                }
            }
            CreatePresenter(elm_) {
                return null;
            }
            Clear() {
                var elmPresenters = this._elementPresenters;
                this._elementPresenters = {};
                for (var idx in elmPresenters) {
                    elmPresenters[idx].Dispose();
                }
            }
            GetPresenter(ctr, elm) {
                var id = elm.ID;
                var presnt = this._elementPresenters[id];
                if (presnt instanceof ctr) {
                    return presnt;
                }
                return null;
            }
            ShowSelectionBox() {
                var sel_nodes = new Array();
                var canMove = true;
                var canRot = true;
                var canScl = true;
                var canMovePivot = true;
                this.Selection.forEach((v_) => {
                    this.View.Scene.World.Children.forEach(node_ => {
                        var prs3d;
                        if (node_.Presenter instanceof Views.UElementPresenter3D) {
                            prs3d = node_.Presenter;
                        }
                        if (prs3d != null && prs3d == v_ && prs3d.ShowBoundingBox == true) {
                            if (prs3d.CanMove != true)
                                canMove = false;
                            if (prs3d.CanRotate != true)
                                canRot = false;
                            if (prs3d.CanScale != true)
                                canScl = false;
                            sel_nodes.push(node_);
                        }
                    });
                });
                if (sel_nodes.length > 0) {
                    if (this.xform == null) {
                        this.xform = this.view.Controls.AddControl(Views.VcXForm);
                        this.xform.CanMove = canMove;
                        this.xform.CanRotate = canRot;
                        this.xform.CanScale = canScl;
                        this.AddMoveHandlers();
                        this.AddRotateHandlers();
                        this.AddScaleHandlers();
                    }
                    this.xform.Init(sel_nodes);
                    this.view.ActiveControl = this.xform;
                }
                else {
                    if (this.xform != null) {
                        this.xform.Dispose();
                    }
                    this.xform = null;
                }
            }
            GetWorldBoundingSelection() {
                return null;
            }
            GetWorldBounding() {
                return null;
            }
            AddRotateHandlers() {
                this.xform.OnBeginRotate = (vcTBox_) => {
                    for (var sel of this.Selection)
                        sel.OnStartRotate();
                };
                this.xform.OnRotate = (vcTBox_, rc_) => {
                    for (var sel of this.Selection)
                        sel.OnRotate(rc_);
                };
                this.xform.OnEndRotate = (vcTBox_, rc_) => {
                    this.Document.BeginTransaction();
                    try {
                        for (var sel of this.Selection)
                            sel.OnEndRotate(rc_);
                        this.View.Invalidate();
                        this.Document.EndTransaction();
                    }
                    catch (ex) {
                        U1.LogService.WriteException(ex);
                        this.Document.AbortTransaction();
                    }
                };
                this.xform.OnCancelRotate = (vcTBox_) => {
                    for (var sel of this.Selection)
                        sel.OnCancelRotate();
                    this.Document.AbortTransaction();
                };
            }
            AddMoveHandlers() {
                this.xform.OnBeginMove = (vcTBox_) => {
                    for (var sel of this.Selection)
                        sel.OnStartMove();
                };
                this.xform.OnMove = (vcTBox_, tc_) => {
                    for (var sel of this.Selection)
                        sel.OnMove(tc_);
                };
                this.xform.OnEndMove = (vcTBox_, tc_) => {
                    this.Document.BeginTransaction();
                    try {
                        for (var sel of this.Selection)
                            sel.OnEndMove(tc_);
                        this.View.Invalidate();
                        this.Document.EndTransaction();
                    }
                    catch (ex) {
                        U1.LogService.WriteException(ex);
                        this.Document.AbortTransaction();
                    }
                };
                this.xform.OnCancelMove = (vcTBox_) => {
                    for (var sel of this.Selection)
                        sel.OnCancelMove();
                    this.Document.AbortTransaction();
                };
            }
            AddScaleHandlers() {
                this.xform.OnBeginScale = (vcTBox_) => {
                    for (var sel of this.Selection)
                        sel.OnStartScale();
                };
                this.xform.OnScale = (vcTBox_, sc_) => {
                    for (var sel of this.Selection)
                        sel.OnScale(sc_);
                };
                this.xform.OnEndScale = (vcTBox_, sc_) => {
                    this.Document.BeginTransaction();
                    try {
                        for (var sel of this.Selection)
                            sel.OnEndScale(sc_);
                        this.View.Invalidate();
                        this.Document.EndTransaction();
                    }
                    catch (ex) {
                        U1.LogService.WriteException(ex);
                        this.Document.AbortTransaction();
                    }
                };
                this.xform.OnCancelScale = (vcTBox_) => {
                    for (var sel of this.Selection)
                        sel.OnCancelScale();
                    this.Document.AbortTransaction();
                };
            }
            StartMove() {
                if (this.xform == null)
                    return;
                this.xform.BeginMove();
            }
            Move(from, to) {
                if (this.xform == null)
                    return;
                this.xform.Move(from, to);
            }
            EndMove(from, to) {
                if (this.xform == null)
                    return;
                this.xform.EndMove(from, to);
            }
            CancelMove() {
                if (this.xform == null)
                    return;
                this.xform.CancelMove();
            }
            Pick(isectContext) {
                var res_isect = null;
                var res_node = null;
                if (this.m_sortedPresenters == null)
                    return null;
                for (var i = this.m_sortedPresenters.length - 1; i >= 0; i--) {
                    var node = this.m_sortedPresenters[i];
                    if (!node.Visible())
                        continue;
                    var isect = node.CheckIntersect(isectContext);
                    if (isect == null)
                        continue;
                    if (res_isect == null || isect.Distance < res_isect.Distance) {
                        isectContext.MaxDistance = isect.Distance;
                        res_node = node;
                        res_isect = isect;
                    }
                }
                var result = new Views.PickResult();
                result.ISect = res_isect;
                result.Presenter = res_node;
                return result;
            }
            SelectRegion(lt, rb, allowCross = false) {
                if (this.m_sortedPresenters == null)
                    return null;
                var result = new Array();
                var clipingCorners = this.View.GetClippingCorners(lt, rb);
                var context = new U1.ContainContext();
                context.LeftTop = lt;
                context.RightBottom = rb;
                context.SelectionBoxConers = clipingCorners;
                context.AllowCross = allowCross;
                for (var i = this.m_sortedPresenters.length - 1; i >= 0; i--) {
                    var presenter = this.m_sortedPresenters[i];
                    if (!presenter.Visible())
                        continue;
                    if (presenter.LastVisible != true)
                        continue;
                    if (presenter.CheckContains(context))
                        result.push(presenter);
                }
                return result;
            }
            UpdateVisible() { }
        }
        UDocumentPresenter.Creaters = {};
        Views.UDocumentPresenter = UDocumentPresenter;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScEntity {
            constructor() {
                this._transform = U1.Matrix4.Identity;
                this._worldTransform = null;
                this._boundingBox = new U1.BoundingBox();
                this._boundingSphere = new U1.BoundingSphere();
                this._geometryBBx = new U1.BoundingBox(U1.Vector3.MaxValue, U1.Vector3.MinValue);
                this._worldBoundingSphere = new U1.BoundingSphere();
                this._isInvalidBounding = true;
                this._isInvalidWorldBounding = true;
                this._order = 0;
                this._invalidOrder = true;
                this.Ver = 0;
                this.UpdateVer = -1;
                this.Visible = true;
                this.Handle = ScEntity._handle++;
            }
            get IsDisposed() {
                return this._isDisposed;
            }
            get Presenter() {
                if (this._presenter != null)
                    return this._presenter;
                if (this._parent != null)
                    return this.Parent.Presenter;
                return null;
            }
            set Presenter(value) {
                this._presenter = value;
            }
            ;
            get Control() {
                if (this._control != null)
                    return this._control;
                if (this._control != null)
                    return this.Parent.Control;
                return null;
            }
            set Control(value) {
                this._control = value;
            }
            ;
            get Parent() {
                return this._parent;
            }
            get Order() {
                return this._order;
            }
            set Order(order) {
                this._order = order;
                if (this.Parent != null)
                    this.Parent._invalidOrder = true;
            }
            get Transform() {
                return this._transform;
            }
            set Transform(value) {
                this._transform.CopyFrom(value);
                this._isInvalidBounding = true;
                this.InvalidateWorldTransform();
                this.Invalidate();
            }
            get WorldTransform() {
                if (this._worldTransform == null) {
                    if (this._parent == null) {
                        this._worldTransform = this.Transform;
                    }
                    else {
                        this._worldTransform = U1.Matrix4.Multiply(this.Transform, this._parent.WorldTransform);
                    }
                }
                return this._worldTransform;
            }
            get BoundingBox() {
                if (this._isInvalidBounding) {
                    this.UpdateBounding();
                    this._isInvalidBounding = false;
                }
                return this._boundingBox;
            }
            get BoundingSphere() {
                if (this._isInvalidBounding) {
                    this.UpdateBounding();
                    this._isInvalidBounding = false;
                }
                return this._boundingSphere;
            }
            get WorldBoundingSphere() {
                if (this._isInvalidWorldBounding) {
                    this._isInvalidWorldBounding = false;
                    U1.BoundingSphere.Transform(this.BoundingSphere, this.WorldTransform, this._worldBoundingSphere);
                }
                return this._worldBoundingSphere;
            }
            get Container() {
                if (this instanceof Views.ScEntityContainer)
                    return this;
                if (this._parent instanceof Views.ScEntityContainer)
                    return this._parent;
                if (this._parent != null)
                    return this._parent.Container;
                return null;
            }
            get Scene() {
                if (this.Container != null)
                    return this.Container.Scene;
                return null;
            }
            get Children() {
                return this._children;
            }
            get OrderedChildren() {
                if (this._orderedChildren == null && this._children != null) {
                    this._invalidOrder = true;
                    this._orderedChildren = this._children.slice();
                }
                if (this._orderedChildren == null)
                    this._orderedChildren = [];
                if (this._orderedChildren != null) {
                    this._orderedChildren = this._orderedChildren.sort((a, b) => {
                        if (a.Order == b.Order)
                            return 0;
                        if (a.Order < b.Order)
                            return -1;
                        return 1;
                    });
                    this._invalidOrder = false;
                }
                return this._orderedChildren;
            }
            AddChild(entity) {
                if (entity._parent != null) {
                    throw "The instance of Entity is already added as child to another parent";
                }
                entity._parent = this;
                if (this._children == null) {
                    this._children = new Array();
                }
                this._children.push(entity);
                this._orderedChildren = null;
                this.InvalidateBounding();
                this.InvalidateOrderedChildren();
                return entity;
            }
            RemoveChild(entity) {
                if (this.Children == null)
                    return;
                var idx = this.Children.indexOf(entity);
                if (idx >= 0) {
                    this.Children.splice(idx, 1);
                    this.InvalidateBounding();
                }
                this._orderedChildren = null;
            }
            Dispose() {
                if (this._isDisposed)
                    return;
                this.OnDisposing();
                if (this._children != null) {
                    var children = this._children.slice();
                    children.forEach(o_ => o_.Dispose());
                }
                if (this._parent != null) {
                    this._parent.RemoveChild(this);
                }
                this._parent = null;
                this._children = null;
                this._isDisposed = true;
            }
            SetChanged() {
                this.Ver++;
                this.InvalidateBounding();
            }
            UpdateBounding() {
                this.UpdateGeometryBounding();
                var min = this._geometryBBx.Min.Clone();
                var max = this._geometryBBx.Max.Clone();
                var tmp_p = ScEntity[".ub.p"] || (ScEntity[".ub.p"] = new U1.Vector3());
                if (this.Children != null) {
                    for (var child of this.Children) {
                        if (child instanceof (Views.ScLineBatch)) {
                            for (var idx in child.Items) {
                                let item = child.Items[idx];
                                if (item == null)
                                    continue;
                                var bbx = item.LocalBBX;
                                if (bbx == null)
                                    continue;
                                if (bbx.Min.X > bbx.Max.X)
                                    continue;
                                bbx.GetCorners().forEach(o_ => {
                                    var p = U1.Vector3.Transform(o_, item.Transform, tmp_p);
                                    min.Minimize(p);
                                    max.Maximize(p);
                                });
                            }
                        }
                        else {
                            var bbx = child.BoundingBox;
                            if (bbx == null)
                                continue;
                            if (bbx.Min.X > bbx.Max.X)
                                continue;
                            bbx.GetCorners().forEach(o_ => {
                                var p = U1.Vector3.Transform(o_, child.Transform, tmp_p);
                                min.Minimize(p);
                                max.Maximize(p);
                            });
                        }
                    }
                }
                this._boundingBox.Min.CopyFrom(min);
                this._boundingBox.Max.CopyFrom(max);
                this._boundingSphere.SetCreateFromBoundingBox(this._boundingBox);
                this._isInvalidWorldBounding = true;
            }
            UpdateGeometryBounding() {
            }
            OnDisposing() {
                this.OnClear();
            }
            CheckIntersect(isectContext) {
                var wsphere = this.WorldBoundingSphere;
                if (isectContext.Ray.IntersectsBoundingSphere(wsphere) === null) {
                    return null;
                }
                var result = null;
                var isect;
                var orderedChildren = this.OrderedChildren;
                for (var i = orderedChildren.length - 1; i >= 0; i--) {
                    var chEntity = orderedChildren[i];
                    isect = chEntity.CheckIntersect(isectContext);
                    if (isect == null)
                        continue;
                    if (result == null || isect.Distance < result.Distance) {
                        result = isect;
                    }
                }
                var tmp_isect = new U1.ISectInfo();
                isect = this.OnCheckIntersect(isectContext, tmp_isect);
                if (isect != null && (result == null || isect.Distance < result.Distance)) {
                    result = isect;
                }
                return result;
            }
            OnCheckIntersect(isectContext, result) {
                return null;
            }
            OnCheckInsideLocal(local_planes, checkCross) {
                return null;
            }
            CheckInside(wplanes, checkCross) {
                var inv_wm = ScEntity.inv_wm.SetInvert(this.WorldTransform);
                var l_planes = ScEntity.l_planes;
                var num_planes = l_planes.length = wplanes.length;
                for (var i = 0; i < num_planes; i++) {
                    var lp = l_planes[i] || (l_planes[i] = new U1.Plane());
                    lp.SetTransform(wplanes[i], inv_wm);
                }
                var isInside = this.OnCheckInsideLocal(l_planes, checkCross);
                if (isInside === true && checkCross)
                    return true;
                if (this.Children != null) {
                    for (var geom of this.Children) {
                        var chInside = geom.CheckInside(wplanes, checkCross);
                        if (chInside == null)
                            continue;
                        isInside = chInside;
                        if (isInside && checkCross)
                            return true;
                        if (!isInside && !checkCross)
                            return false;
                    }
                }
                return isInside;
            }
            Invalidate() {
                this.IsInvalid = true;
                if (this._parent != null)
                    this._parent.Invalidate();
            }
            InvalidateBounding() {
                this._isInvalidBounding = true;
                this._isInvalidWorldBounding = true;
                if (this._parent != null) {
                    this._parent.InvalidateBounding();
                }
            }
            InvalidateOrderedChildren() {
                this._orderedChildren = null;
            }
            Update(context) {
                this.OnUpdate(context);
                for (var ch of this.OrderedChildren) {
                    ch.Update(context);
                }
            }
            OnUpdate(context) {
            }
            Draw(context) {
                this.OnDraw(context);
                for (var ch of this.OrderedChildren) {
                    ch.Draw(context);
                }
            }
            OnDraw(context) {
            }
            OnClear() { }
            InvalidateWorldTransform() {
                this._worldTransform = null;
                this._isInvalidWorldBounding = true;
                if (this.Children != null) {
                    for (var ch of this.Children) {
                        ch.InvalidateWorldTransform();
                    }
                }
            }
            static NeedDrawing1(context, RenderingPriority, localSphere, transform) {
                var wsphere = ScEntity._wsphere = U1.BoundingSphere.Transform(localSphere, transform, ScEntity._wsphere);
                if (context.getView() == null)
                    return false;
                var scene = context.getView().Scene;
                if (context.ViewFrustum != null
                    && context.ViewFrustum.ContainsBoundingSphere(wsphere) == U1.ContainmentTypeEnum.Disjoint) {
                    return false;
                }
                if (scene.QualityLevel == 0) {
                    context.visibleObjectCount++;
                    return true;
                }
                var invisibleSize = scene.MinimumVolumnVisibleSize;
                if (invisibleSize > 0) {
                    if (RenderingPriority == Views.RenderingPriorityEnum.Low)
                        invisibleSize *= 8;
                    else if (RenderingPriority == Views.RenderingPriorityEnum.High)
                        invisibleSize /= 8;
                    var rad = wsphere.Radius;
                    var invView = context.getInvViewM();
                    var p0 = new U1.Vector3(invView.M11 * rad, invView.M12 * rad, invView.M13 * rad).Add(wsphere.Center);
                    var p1 = new U1.Vector3(invView.M11 * -rad, invView.M12 * -rad, invView.M13 * -rad).Add(wsphere.Center);
                    p0 = Views.MathExtensions.Project1(p0, context.getViewProjM());
                    p1 = Views.MathExtensions.Project1(p1, context.getViewProjM());
                    p0.Z = p1.Z = 0;
                    var dist = U1.Vector3.Distance(p0, p1);
                    if (dist < invisibleSize)
                        return false;
                }
                context.visibleObjectCount++;
                return true;
            }
            static NeedDrawing2(context, RenderingPriority, wsphere) {
                if (context.getView() == null)
                    return false;
                var scene = context.getView().Scene;
                if (context.ViewFrustum != null
                    && context.ViewFrustum.ContainsBoundingSphere(wsphere) == U1.ContainmentTypeEnum.Disjoint) {
                    return false;
                }
                if (scene.QualityLevel == 0) {
                    context.visibleObjectCount++;
                    return true;
                }
                var invisibleSize = scene.MinimumVolumnVisibleSize;
                if (context.FastRender) {
                    if (RenderingPriority == Views.RenderingPriorityEnum.Low)
                        invisibleSize *= 8;
                    else if (RenderingPriority == Views.RenderingPriorityEnum.High)
                        invisibleSize /= 8;
                }
                if (invisibleSize > 0) {
                    var rad = wsphere.Radius;
                    var p0 = new U1.Vector3(rad, rad, rad).Add(wsphere.Center);
                    var p1 = new U1.Vector3(-rad, -rad, -rad).Add(wsphere.Center);
                    p0 = Views.MathExtensions.Project1(p0, context.getViewProjM());
                    p1 = Views.MathExtensions.Project1(p1, context.getViewProjM());
                    p0.Z = p1.Z = 0;
                    var dist = U1.Vector3.Distance(p0, p1);
                    if (dist < invisibleSize)
                        return false;
                }
                context.visibleObjectCount++;
                return true;
            }
        }
        ScEntity._handle = 0;
        ScEntity.l_planes = [];
        ScEntity.inv_wm = U1.Matrix4.Identity;
        ScEntity.tmp_m0 = U1.Matrix4.Identity;
        ScEntity.tmp_m1 = U1.Matrix4.Identity;
        ScEntity.tmp_m2 = U1.Matrix4.Identity;
        ScEntity.tmp_m3 = U1.Matrix4.Identity;
        ScEntity.tmp_v30 = U1.Vector3.Zero;
        ScEntity.tmp_v31 = U1.Vector3.Zero;
        ScEntity.tmp_v32 = U1.Vector3.Zero;
        ScEntity.tmp_v33 = U1.Vector3.Zero;
        ScEntity.tmp_v34 = U1.Vector3.Zero;
        ScEntity.tmp_bx0 = new U1.BoundingBox();
        ScEntity.tmp_bx1 = new U1.BoundingBox();
        ScEntity.tmp_bx2 = new U1.BoundingBox();
        ScEntity.tmp_r30 = new U1.Ray3();
        ScEntity.tmp_r31 = new U1.Ray3();
        ScEntity.tmp_sphere_1 = new U1.BoundingSphere();
        Views.ScEntity = ScEntity;
        class ScGroup extends ScEntity {
        }
        Views.ScGroup = ScGroup;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScMeshBatch extends Views.ScEntity {
            constructor() {
                super(...arguments);
                this.m_pointCount = 3000;
                this.m_items = {};
                this.m_isInvalid = true;
                this.m_lastNum = 0;
            }
            get PointCount() {
                return this.m_pointCount;
            }
            set PointCount(value) {
                this.Ver++;
                this.m_pointCount = value;
                this.m_isInvalid = true;
            }
            get Items() {
                return this.m_items;
            }
            CreateItem() {
                return new ScMeshBatchItem();
            }
            AddItem() {
                this.Container.Ver++;
                var result = this.CreateItem();
                result.Number = ++this.m_lastNum;
                result.Container = this;
                this.m_items[result.Number] = result;
                return result;
            }
            RemoveItem(inst) {
                if (inst != null && inst.Container == this)
                    this.m_items[inst.Number] = undefined;
                this.Ver++;
            }
        }
        Views.ScMeshBatch = ScMeshBatch;
        class ScMeshBatchItem {
            constructor() {
                this.m_transform = U1.Matrix4.Identity;
                this.m_color = U1.Colors.Black;
                this.IsDirty = true;
                this.IsInsideView = true;
                this.UpdateVer = 0;
                this.Visible = true;
                this.RenderingPriority = Views.RenderingPriorityEnum.Normal;
            }
            get Geom() {
                return this.m_Geom;
            }
            set Geom(value) {
                this.m_Geom = value;
                this.m_xformedGeom = null;
                this.m_lbsphere = this.m_Geom.BoundingSphere;
                this.Container.Ver++;
            }
            get XFormedGeom() {
                if (this.m_xformedGeom == null && this.m_Geom != null) {
                    this.m_xformedGeom = this.m_Geom.Clone();
                    this.m_xformedGeom.ApplyTransform(this.Transform);
                    this.m_wbsphere = this.m_xformedGeom.BoundingSphere.Clone();
                }
                return this.m_xformedGeom;
            }
            get Color() {
                return this.m_color;
            }
            set Color(value) {
                this.m_color = value;
                this.Container.Ver++;
            }
            get Transform() {
                return this.m_transform;
            }
            set Transform(value) {
                this.m_transform = value;
                this.m_xformedGeom = null;
                this.Container.Ver++;
            }
            NeedDrawing(context) {
                if (!this.Visible)
                    return false;
                var opacity = this.Color.A >= 254 && context.EntityAlpha >= 0.99;
                if (context.RenderOpacity != opacity)
                    return false;
                if (this.m_wbsphere != null)
                    return Views.ScEntity.NeedDrawing2(context, this.RenderingPriority, this.m_wbsphere);
                return Views.ScEntity.NeedDrawing1(context, this.RenderingPriority, this.m_lbsphere, this.m_transform);
            }
            Intersect(isectContext) {
                if (this.m_xformedGeom == null)
                    return null;
                var view = this.Container.Scene.View;
                var minLen = 5;
                var minDepth = isectContext.MaxDistance;
                var wray = isectContext.Ray;
                if (wray.IntersectsBoundingSphere(this.m_wbsphere) == null)
                    return null;
                var result = this.m_xformedGeom.Intersect(wray);
                if (result != null) {
                    result.Source = this;
                }
                return result;
            }
            Contains(planes, fCross) {
                if (this.m_xformedGeom == null)
                    return false;
                return this.m_xformedGeom.IsInside(planes, fCross);
            }
            Remove() {
                this.Container.RemoveItem(this);
            }
        }
        Views.ScMeshBatchItem = ScMeshBatchItem;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScText3 extends Views.ScEntity {
            constructor() {
                super(...arguments);
                this._width = 0;
                this._height = 1;
                this._isMultiLine = false;
                this._orign = U1.Vector3.Zero;
                this._axisY = U1.Vector3.UnitY;
                this._axisX = U1.Vector3.UnitX;
                this._fontSize = 1;
                this._fontStyle = U1.Geoms.FontStyleEnum.Normal;
                this._fontWeight = U1.Geoms.FontWeightEnum.Normal;
                this._textAlignment = U1.Geoms.TextAlignmentEnum.Left;
                this._fontFamily = "Arial";
                this._geometryInvalid = true;
                this._transformInvalid = true;
                this._boundingInvalid = true;
                this._color = U1.Colors.Black;
            }
            get Text() {
                return this._text;
            }
            set Text(value) {
                if (this._text == value)
                    return;
                this._text = value;
                this.Ver++;
            }
            get FontSize() {
                return this._fontSize;
            }
            set FontSize(value) {
                if (this._fontSize == value)
                    return;
                this._fontSize = value;
                this.Ver++;
            }
            get FontStyle() {
                return this._fontStyle;
            }
            set FontStyle(value) {
                if (this._fontStyle == value)
                    return;
                this._fontStyle = value;
                this.Ver++;
            }
            get FontWeight() {
                return this._fontWeight;
            }
            set FontWeight(value) {
                if (this._fontWeight == value)
                    return;
                this._fontWeight = value;
                this.Ver++;
            }
            get TextAlignment() {
                return this._textAlignment;
            }
            set TextAlignment(value) {
                if (this._textAlignment == value)
                    return;
                this._textAlignment = value;
                this.Ver++;
            }
            get FontFamily() {
                return this._fontFamily;
            }
            set FontFamily(value) {
                if (this._fontFamily == value)
                    return;
                this._fontFamily = value;
                this.Ver++;
            }
            get Width() {
                return this._width;
            }
            set Width(value) {
                this._width = value;
                this._boundingInvalid = true;
                this.Ver++;
            }
            get Height() {
                return this._height;
            }
            set Height(value) {
                this._height = value;
                this._boundingInvalid = true;
                this.Ver++;
            }
            get IsMultiLine() {
                return this._isMultiLine;
            }
            set IsMultiLine(value) {
                if (this._isMultiLine == value)
                    return;
                this._isMultiLine = value;
                this._boundingInvalid = true;
                this.Ver++;
            }
            get Orign() {
                return this._orign;
            }
            set Orign(value) {
                this._orign = value;
                this._boundingInvalid = true;
                this.Ver++;
                this._transform = null;
            }
            get AxisY() {
                return this._axisY;
            }
            set AxisY(value) {
                if (this._axisY == value)
                    return;
                this._axisY = value;
                this.Ver;
                this._transform = null;
            }
            get AxisX() {
                return this._axisX;
            }
            set AxisX(value) {
                if (this._axisX == value)
                    return;
                this._axisX = value;
                this.Ver++;
                this._transform = null;
            }
            get Transform() {
                if (this._transform == null) {
                    var axisx = U1.Vector3.Normalize(this.AxisX);
                    var axisz = U1.Vector3.Cross(axisx, this.AxisY);
                    var axisy = U1.Vector3.Cross(axisz, axisx);
                    this._transform = U1.Matrix4.CreateFromAxes(axisx, axisy, axisz);
                    this._transform.Translation = this.Orign;
                }
                return this._transform;
            }
            get Color() {
                return this._color;
            }
            set Color(value) {
                this._color = value;
                this.Ver++;
            }
        }
        Views.ScText3 = ScText3;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScEntityContainer extends Views.ScEntity {
            constructor(scene) {
                super();
                this._namedEntities = {};
                this._scene = scene;
                this._children = new Array();
            }
            get Scene() {
                return this._scene;
            }
            Invalidate() {
                this._scene.View.Invalidate();
            }
            Pick(isectContext) {
                var res_isect = null;
                var res_node = null;
                var orderedItems = this.OrderedChildren;
                for (var i = orderedItems.length - 1; i >= 0; i--) {
                    var node = orderedItems[i];
                    if (!node.Visible || node.IsPickable === false)
                        continue;
                    var isect = node.CheckIntersect(isectContext);
                    if (isect == null)
                        continue;
                    if (res_isect == null || isect.Distance < res_isect.Distance) {
                        isectContext.MaxDistance = isect.Distance;
                        res_node = node;
                        res_isect = isect;
                    }
                }
                var result = new Views.PickResult();
                result.ISect = res_isect;
                result.Node = res_node;
                return result;
            }
            SelectRegion(lt, rb, allowCross = false) {
                var result = new Array();
                var regionBox = this.Scene.View.GetClippingCorners(lt, rb);
                var planes = new Array(4);
                planes[0] = U1.Plane.FromTriangle(regionBox[0], regionBox[6], regionBox[1]);
                planes[1] = U1.Plane.FromTriangle(regionBox[0], regionBox[1], regionBox[2]);
                planes[2] = U1.Plane.FromTriangle(regionBox[2], regionBox[3], regionBox[4]);
                planes[3] = U1.Plane.FromTriangle(regionBox[4], regionBox[7], regionBox[6]);
                for (var node of this.Children) {
                    if (!node.Visible)
                        continue;
                    if (node.CheckInside(planes, allowCross))
                        result.push(node);
                }
                return result;
            }
            Clear() {
                var children = this.Children;
                if (children != null) {
                    children = children.slice();
                    for (var ch of children) {
                        this.RemoveChild(ch);
                        ch.Dispose();
                    }
                }
            }
            AddEntity(ctor) {
                var entity = this.Scene.newEntity(ctor);
                if (entity != null)
                    this.AddChild(entity);
                return entity;
            }
            GetNamedEntity(ctor, name) {
                if (this._namedEntities[name] instanceof ctor)
                    return this._namedEntities[name];
                return null;
            }
            AddNamedEntity(ctor, name) {
                this._namedEntities[name] = this.AddEntity(ctor);
                return this._namedEntities[name];
            }
            GetOrAddNamedEntity(ctor, name) {
                var result = this.GetNamedEntity(ctor, name);
                if (result == null) {
                    result = this.AddNamedEntity(ctor, name);
                }
                return result;
            }
            RemoveChild(entity) {
                if (entity.Name != null && this._namedEntities[entity.Name] == entity) {
                    this._namedEntities[entity.Name] = undefined;
                }
                super.RemoveChild(entity);
            }
        }
        Views.ScEntityContainer = ScEntityContainer;
        class ScWorld extends ScEntityContainer {
            constructor(scene) {
                super(scene);
                this.m_showGrid = false;
            }
            get ShowGrid() {
                return this.m_showGrid;
            }
            set ShowGrid(value) {
                this.m_showGrid = value;
            }
            get Grid() {
                return this.m_grid;
            }
            OnUpdate(context) {
                super.OnUpdate(context);
                if (this.m_showGrid) {
                    if (this.m_grid == null) {
                        this.m_grid = this.AddEntity(Views.ScGrid);
                    }
                }
                else {
                    if (this.m_grid != null)
                        this.m_grid.Dispose();
                    this.m_grid = undefined;
                }
            }
            Clear() {
                if (this.m_grid != null)
                    this.m_grid.Dispose();
                this.m_grid = undefined;
            }
        }
        Views.ScWorld = ScWorld;
        class ScOverlayWorld extends ScEntityContainer {
            constructor(scene) {
                super(scene);
            }
        }
        Views.ScOverlayWorld = ScOverlayWorld;
        class ScScreenWorld extends ScEntityContainer {
            constructor(scene) {
                super(scene);
            }
        }
        Views.ScScreenWorld = ScScreenWorld;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScLight extends Views.ScEntity {
            constructor() {
                super(...arguments);
                this.Light = new U1.Light();
            }
        }
        Views.ScLight = ScLight;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScLineBatch extends Views.ScEntity {
            constructor() {
                super(...arguments);
                this.m_pointCount = 1000;
                this.m_indexCount = 2000;
                this.m_items = {};
                this.m_isInvalid = true;
                this.m_lastNum = 0;
            }
            get PointCount() {
                return this.m_pointCount;
            }
            set PointCount(value) {
                this.Ver++;
                this.m_pointCount = value;
                this.m_isInvalid = true;
            }
            get IndexCount() {
                return this.m_indexCount;
            }
            set IndexCount(value) {
                this.Ver++;
                this.m_indexCount = value;
                this.m_isInvalid = true;
            }
            get Items() {
                return this.m_items;
            }
            CreateItem() {
                return new ScLineBatchItem();
            }
            AddItem() {
                this.Container.Ver++;
                var result = this.CreateItem();
                result.Number = ++this.m_lastNum;
                result.Container = this;
                this.m_items[result.Number] = result;
                return result;
            }
            RemoveItem(inst) {
                if (inst != null && inst.Container == this)
                    this.m_items[inst.Number] = undefined;
                this.Ver++;
                if (this.Parent != null)
                    this.Parent.InvalidateBounding();
            }
        }
        Views.ScLineBatch = ScLineBatch;
        class ScLineBatchItem {
            constructor() {
                this.m_transform = U1.Matrix4.Identity;
                this.m_color = U1.Colors.Black;
                this.IsDirty = true;
                this.IsInsideView = true;
                this.UpdateVer = 0;
                this.Visible = true;
                this.RenderingPriority = Views.RenderingPriorityEnum.Normal;
            }
            get LocalBBX() {
                return this.m_lbbx;
            }
            get Pattern() {
                return this.m_pattern;
            }
            set Pattern(value) {
                this.m_pattern = value;
                this.m_xFormedPath = null;
                this.Container.Ver++;
            }
            get Path() {
                return this.m_path;
            }
            set Path(value) {
                this.m_path = value;
                this.m_xFormedPath = null;
                if (this.Container != null) {
                    if (this.Container.PointCount < this.m_path.length)
                        this.Container.PointCount = this.m_path.length;
                    if (this.Container.IndexCount < this.m_path.length + 1)
                        this.Container.IndexCount = this.m_path.length + 1;
                }
                this.m_lbsphere = U1.BoundingSphere.CreateFromPoints(this.m_path);
                this.m_lbbx = U1.BoundingBox.CreateFromPoints(this.m_path);
                this.Container.Ver++;
            }
            get XFormedPath() {
                if (this.m_xFormedPath == null && this.m_path != null) {
                    this.m_xFormedPath = this.m_path.map(o_ => new U1.Vector3(o_));
                    for (var i = 0; i < this.m_xFormedPath.length; ++i) {
                        this.m_xFormedPath[i].Transform(this.m_transform);
                    }
                    this.m_wbsphere = U1.BoundingSphere.CreateFromPoints(this.m_xFormedPath);
                    if (this.m_pattern != null && this.m_pattern.length > 1) {
                        this.ApplyPattern();
                    }
                }
                return this.m_xFormedPath;
            }
            get Color() {
                return this.m_color;
            }
            set Color(value) {
                this.m_color = value;
                this.Container.Ver++;
            }
            get Transform() {
                return this.m_transform;
            }
            set Transform(value) {
                this.m_transform = value;
                this.m_xFormedPath = null;
                this.Container.Ver++;
            }
            ApplyPattern() {
                var patterned = new Array();
                var pt_idx = 0;
                var warkPath = new WalkPath();
                warkPath.Path = this.m_xFormedPath;
                var is_solid = true;
                while (warkPath.HasNext()) {
                    var segs = warkPath.GetNextSegments(this.m_pattern[pt_idx]);
                    if (is_solid)
                        patterned.AddRange(segs);
                    is_solid = !is_solid;
                    pt_idx++;
                    if (pt_idx >= this.m_pattern.length)
                        pt_idx = 0;
                }
                this.m_xFormedPath = patterned;
            }
            NeedDrawing(context) {
                if (!this.Visible)
                    return false;
                var opacity = this.Color.A >= 254 && context.EntityAlpha >= 0.99;
                if (context.RenderOpacity != opacity)
                    return false;
                if (this.m_wbsphere != null)
                    return Views.ScEntity.NeedDrawing2(context, this.RenderingPriority, this.m_wbsphere);
                return Views.ScEntity.NeedDrawing1(context, this.RenderingPriority, this.m_lbsphere, this.m_transform);
            }
            Intersect(isectContext) {
                if (this.m_xFormedPath == null)
                    return null;
                var view = this.Container.Scene.View;
                var minLen = 5;
                var minDepth = isectContext.MaxDistance;
                var wray = isectContext.Ray;
                if (wray.IntersectsBoundingSphere(this.m_wbsphere) == null)
                    return null;
                var path = this.m_xFormedPath;
                if (path == null)
                    return null;
                for (var i = 0; i < path.length - 1; i++) {
                    var sp = path[i];
                    var ep = path[i + 1];
                    var dr = U1.Vector3.Subtract(ep, sp);
                    var distRes = { s: 0, t: 0 };
                    var len = U1.Line3.SquardDistance1(wray.Position, wray.Direction, sp, dr, distRes);
                    var s = distRes.s;
                    var t = distRes.t;
                    if (s >= minDepth)
                        continue;
                    if (t < 0 || t > 1)
                        continue;
                    var w0 = U1.Vector3.ScaleAdd(wray.Position, s, wray.Direction);
                    var w1 = U1.Vector3.ScaleAdd(sp, t, dr);
                    var s0 = isectContext.WorldToScreen(w0).XY();
                    var s1 = isectContext.WorldToScreen(w1).XY();
                    if (s0 == null || s1 == null)
                        continue;
                    if (U1.Vector2.Distance(s0, s1) < minLen) {
                        var isectInfo = new U1.ISectInfo();
                        isectInfo.Distance = s;
                        isectInfo.IsectPosition;
                        isectInfo.Attr = 0;
                        isectInfo.Source = this;
                        return isectInfo;
                    }
                }
                return null;
            }
            Contains(planes, fCross) {
                if (this.m_xFormedPath == null)
                    return false;
                return U1.LineGeometry.IsInside1(planes, this.m_wbsphere, this.m_xFormedPath, fCross);
            }
            Remove() {
                this.Container.RemoveItem(this);
            }
        }
        Views.ScLineBatchItem = ScLineBatchItem;
        class WalkPath {
            constructor() {
                this.m_pathLength = -1;
                this.m_curLoc = 0.0;
                this.m_curKnotIdx = 0;
            }
            get Path() {
                return this.m_path;
            }
            set Path(value) {
                this.m_path = value;
                if (this.m_path != null) {
                    this.m_knots = new Array(value.length);
                    this.m_knots[0] = 0.0;
                    for (var i = 1; i < this.m_path.length; i++) {
                        this.m_knots[i] = this.m_knots[i - 1] + U1.Vector3.Distance(this.m_path[i], this.m_path[i - 1]);
                    }
                }
                else {
                    this.m_path = null;
                }
            }
            HasNext() {
                return this.m_curKnotIdx < this.m_path.length - 1;
            }
            GetNextSegments(span) {
                var result = new Array();
                while (this.m_curKnotIdx + 1 < this.m_path.length && span > 0) {
                    var p0 = this.Path[this.m_curKnotIdx];
                    var p1 = this.Path[this.m_curKnotIdx + 1];
                    var loc0 = this.m_knots[this.m_curKnotIdx];
                    var loc1 = this.m_knots[this.m_curKnotIdx + 1];
                    var d = U1.Vector3.Normalize(p1.Subtract(p0));
                    var l = U1.Vector3.Distance(p0, p1);
                    var sp = p0.Add(U1.Vector3.Scale(d, (this.m_curLoc + loc0)));
                    if (loc1 - this.m_curLoc < span) {
                        result.push(sp);
                        result.push(p1);
                        this.m_curKnotIdx++;
                        span -= (loc1 - this.m_curLoc);
                        this.m_curLoc = loc1;
                        continue;
                    }
                    else {
                        var ep = sp.Add(U1.Vector3.Scale(d, span));
                        result.push(sp);
                        result.push(ep);
                        this.m_curLoc += span;
                        break;
                    }
                }
                return result;
            }
        }
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScRenderContext {
            constructor(other) {
                this.m_WorldM = U1.Matrix4.Identity;
                this.m_ViewM = U1.Matrix4.Identity;
                this.m_ProjM = U1.Matrix4.Identity;
                this.m_ViewProjM = U1.Matrix4.Identity;
                this.m_InvViewM = U1.Matrix4.Identity;
                this.RenderOpacity = true;
                this.visibleObjectCount = 0;
                this.WorldToScreenRation = 1;
                this.EntityAlpha = 1;
                this.XRayAlpha = 0.2;
                if (other != null) {
                    this.RenderOpacity = other.RenderOpacity;
                    this.setWorldM(other.getWorldM());
                    this.setView(other.getView());
                    this.setProjM(other.getProjM());
                    this.ViewFrustum = other.ViewFrustum;
                    this.RenderingMode = other.RenderingMode;
                }
            }
            getWorldM() { return this.m_WorldM; }
            setWorldM(value) { this.m_WorldM = value; }
            getViewM() { return this.m_ViewM; }
            setViewM(value) { this.m_ViewM = value; }
            getProjM() { return this.m_ProjM; }
            setProjM(value) { this.m_ProjM = value; }
            getViewProjM() { return this.m_ProjM; }
            setViewProjM(value) { this.m_ProjM = value; }
            getInvViewM() { return this.m_ViewProjM; }
            setInvViewM(value) { this.m_ViewProjM = value; }
            getView() { return this.m_view; }
            setView(value) { this.m_view = value; }
            GetWVP() {
                return this.getWorldM().Multiply(this.getViewM()).Multiply(this.getProjM());
            }
        }
        Views.ScRenderContext = ScRenderContext;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        let URenderingMode;
        (function (URenderingMode) {
            URenderingMode[URenderingMode["Solid"] = 0] = "Solid";
            URenderingMode[URenderingMode["Wireframe"] = 1] = "Wireframe";
            URenderingMode[URenderingMode["RemoveHiddenLine"] = 2] = "RemoveHiddenLine";
            URenderingMode[URenderingMode["XRay"] = 3] = "XRay";
            URenderingMode[URenderingMode["SolidWithOutline"] = 4] = "SolidWithOutline";
            URenderingMode[URenderingMode["XRayWithOutline"] = 5] = "XRayWithOutline";
        })(URenderingMode = Views.URenderingMode || (Views.URenderingMode = {}));
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var LibTess;
    (function (LibTess) {
        class Debug {
            static Assert(isTrue) {
            }
        }
        let WindingRule;
        (function (WindingRule) {
            WindingRule[WindingRule["EvenOdd"] = 0] = "EvenOdd";
            WindingRule[WindingRule["NonZero"] = 1] = "NonZero";
            WindingRule[WindingRule["Positive"] = 2] = "Positive";
            WindingRule[WindingRule["Negative"] = 3] = "Negative";
            WindingRule[WindingRule["AbsGeqTwo"] = 4] = "AbsGeqTwo";
        })(WindingRule = LibTess.WindingRule || (LibTess.WindingRule = {}));
        let ElementType;
        (function (ElementType) {
            ElementType[ElementType["Polygons"] = 0] = "Polygons";
            ElementType[ElementType["ConnectedPolygons"] = 1] = "ConnectedPolygons";
            ElementType[ElementType["BoundaryContours"] = 2] = "BoundaryContours";
        })(ElementType = LibTess.ElementType || (LibTess.ElementType = {}));
        let ContourOrientation;
        (function (ContourOrientation) {
            ContourOrientation[ContourOrientation["Original"] = 0] = "Original";
            ContourOrientation[ContourOrientation["Clockwise"] = 1] = "Clockwise";
            ContourOrientation[ContourOrientation["CounterClockwise"] = 2] = "CounterClockwise";
        })(ContourOrientation = LibTess.ContourOrientation || (LibTess.ContourOrientation = {}));
        class PQHandle {
            constructor(handle = 0) {
                this._handle = handle;
            }
        }
        PQHandle.Invalid = 0x0fffffff;
        LibTess.PQHandle = PQHandle;
        class Vec3 {
            static get Zero() { return new Vec3(); }
            constructor(X = 0, Y = 0, Z = 0) {
                this[0] = X;
                this[1] = Y;
                this[2] = Z;
            }
            SetValues(x, y, z) {
                this.X = x;
                this.Y = y;
                this.Z = z;
            }
            CopyFrom(source) {
                this.X = source.X;
                this.Y = source.Y;
                this.Z = source.Z;
            }
            get X() {
                return this[0];
            }
            set X(value) {
                this[0] = value;
            }
            get Y() {
                return this[1];
            }
            set Y(value) {
                this[1] = value;
            }
            get Z() {
                return this[2];
            }
            set Z(value) {
                this[2] = value;
            }
            static Sub(lhs, rhs, result) {
                result.X = lhs.X - rhs.X;
                result.Y = lhs.Y - rhs.Y;
                result.Z = lhs.Z - rhs.Z;
            }
            static Neg(v) {
                v.X = -v.X;
                v.Y = -v.Y;
                v.Z = -v.Z;
            }
            static Dot(u, v) {
                var dot = u.X * v.X + u.Y * v.Y + u.Z * v.Z;
                return dot;
            }
            static Normalize(v) {
                var len = v.X * v.X + v.Y * v.Y + v.Z * v.Z;
                Debug.Assert(len >= 0.0);
                len = 1.0 / Math.sqrt(len);
                v.X *= len;
                v.Y *= len;
                v.Z *= len;
            }
            static LongAxis(v) {
                var i = 0;
                if (Math.abs(v.Y) > Math.abs(v.X))
                    i = 1;
                if (Math.abs(v.Z) > Math.abs(i == 0 ? v.X : v.Y))
                    i = 2;
                return i;
            }
            toString() {
                return `${this.X}, ${this.Y}, ${this.Z}`;
            }
        }
        LibTess.Vec3 = Vec3;
        class Vertex {
            constructor() {
                this._coords = Vec3.Zero;
                this._pqHandle = new PQHandle();
            }
        }
        LibTess.Vertex = Vertex;
        class Face {
            get VertsCount() {
                var n = 0;
                var eCur = this._anEdge;
                do {
                    n++;
                    eCur = eCur._Lnext;
                } while (eCur != this._anEdge);
                return n;
            }
        }
        LibTess.Face = Face;
        class EdgePair {
            static Create() {
                var pair = new EdgePair();
                pair._e = new Edge();
                pair._e._pair = pair;
                pair._eSym = new Edge();
                pair._eSym._pair = pair;
                return pair;
            }
        }
        LibTess.EdgePair = EdgePair;
        class Edge {
            get _Rface() { return this._Sym._Lface; }
            set _Rface(value) { this._Sym._Lface = value; }
            get _Dst() { return this._Sym._Org; }
            set _Dst(value) { this._Sym._Org = value; }
            get _Oprev() { return this._Sym._Lnext; }
            set _Oprev(value) { this._Sym._Lnext = value; }
            get _Lprev() { return this._Onext._Sym; }
            set _Lprev(value) { this._Onext._Sym = value; }
            get _Dprev() { return this._Lnext._Sym; }
            set _Dprev(value) { this._Lnext._Sym = value; }
            get _Rprev() { return this._Sym._Onext; }
            set _Rprev(value) { this._Sym._Onext = value; }
            get _Dnext() { return this._Rprev._Sym; }
            set _Dnext(value) { this._Rprev._Sym = value; }
            get _Rnext() { return this._Oprev._Sym; }
            set _Rnext(value) { this._Oprev._Sym = value; }
            static EnsureFirst(e) {
                if (e == e._pair._eSym) {
                    return e._Sym;
                }
                return e;
            }
        }
        LibTess.Edge = Edge;
        class MeshUtils {
            static MakeEdge(eNext) {
                var pair = EdgePair.Create();
                var e = pair._e;
                var eSym = pair._eSym;
                eNext = Edge.EnsureFirst(eNext);
                var ePrev = eNext._Sym._next;
                eSym._next = ePrev;
                ePrev._Sym._next = e;
                e._next = eNext;
                eNext._Sym._next = eSym;
                e._Sym = eSym;
                e._Onext = e;
                e._Lnext = eSym;
                e._Org = null;
                e._Lface = null;
                e._winding = 0;
                e._activeRegion = null;
                eSym._Sym = e;
                eSym._Onext = eSym;
                eSym._Lnext = e;
                eSym._Org = null;
                eSym._Lface = null;
                eSym._winding = 0;
                eSym._activeRegion = null;
                return e;
            }
            static Splice(a, b) {
                var aOnext = a._Onext;
                var bOnext = b._Onext;
                aOnext._Sym._Lnext = b;
                bOnext._Sym._Lnext = a;
                a._Onext = bOnext;
                b._Onext = aOnext;
            }
            static MakeVertex(vNew, eOrig, vNext) {
                var vPrev = vNext._prev;
                vNew._prev = vPrev;
                vPrev._next = vNew;
                vNew._next = vNext;
                vNext._prev = vNew;
                vNew._anEdge = eOrig;
                var e = eOrig;
                do {
                    e._Org = vNew;
                    e = e._Onext;
                } while (e != eOrig);
            }
            static MakeFace(fNew, eOrig, fNext) {
                var fPrev = fNext._prev;
                fNew._prev = fPrev;
                fPrev._next = fNew;
                fNew._next = fNext;
                fNext._prev = fNew;
                fNew._anEdge = eOrig;
                fNew._trail = null;
                fNew._marked = false;
                fNew._inside = fNext._inside;
                var e = eOrig;
                do {
                    e._Lface = fNew;
                    e = e._Lnext;
                } while (e != eOrig);
            }
            static KillEdge(eDel) {
                eDel = Edge.EnsureFirst(eDel);
                var eNext = eDel._next;
                var ePrev = eDel._Sym._next;
                eNext._Sym._next = ePrev;
                ePrev._Sym._next = eNext;
            }
            static KillVertex(vDel, newOrg) {
                var eStart = vDel._anEdge;
                var e = eStart;
                do {
                    e._Org = newOrg;
                    e = e._Onext;
                } while (e != eStart);
                var vPrev = vDel._prev;
                var vNext = vDel._next;
                vNext._prev = vPrev;
                vPrev._next = vNext;
            }
            static KillFace(fDel, newLFace) {
                var eStart = fDel._anEdge;
                var e = eStart;
                do {
                    e._Lface = newLFace;
                    e = e._Lnext;
                } while (e != eStart);
                var fPrev = fDel._prev;
                var fNext = fDel._next;
                fNext._prev = fPrev;
                fPrev._next = fNext;
            }
        }
        MeshUtils.Undef = Number.MIN_VALUE;
        LibTess.MeshUtils = MeshUtils;
        class ContourVertex {
            constructor() {
                this.Position = Vec3.Zero;
            }
            toString() {
                return this.Position.toString() + (this.Data != null) ? this.Data.toString() : "";
            }
        }
        LibTess.ContourVertex = ContourVertex;
        class Node {
            get Key() {
                return this._key;
            }
            get Prev() {
                return this._prev;
            }
            get Next() {
                return this._next;
            }
        }
        LibTess.Node = Node;
        class Dict {
            constructor(leq) {
                this._leq = leq;
                this._head = new Node();
                this._head._key = null;
                this._head._prev = this._head;
                this._head._next = this._head;
            }
            Insert(key) {
                return this.InsertBefore(this._head, key);
            }
            InsertBefore(node, key) {
                do {
                    node = node.Prev;
                } while (node.Key != null && !this._leq(node.Key, key));
                var newNode = new Node();
                newNode._key = key;
                newNode._next = node._next;
                node._next._prev = newNode;
                newNode._prev = node;
                node._next = newNode;
                return newNode;
            }
            Find(key) {
                var node = this._head;
                do {
                    node = node._next;
                } while (node._key != null && !this._leq(key, node._key));
                return node;
            }
            Min() {
                return this._head._next;
            }
            Remove(node) {
                node._next._prev = node._prev;
                node._prev._next = node._next;
            }
        }
        LibTess.Dict = Dict;
        class HandleElem {
        }
        LibTess.HandleElem = HandleElem;
        class PriorityHeap {
            constructor(initialSize, leq) {
                this._size = 0;
                this._leq = leq;
                this._nodes = new Array(initialSize + 1);
                this._handles = new Array(initialSize + 1);
                this._size = 0;
                this._max = initialSize;
                this._freeList = 0;
                this._initialized = false;
                this._nodes[1] = 1;
                this._handles[1] = new HandleElem();
                this._handles[1]._key = null;
            }
            get Empty() { return this._size == 0; }
            FloatDown(curr) {
                var child;
                var hCurr;
                var hChild;
                hCurr = this._nodes[curr];
                while (true) {
                    child = curr << 1;
                    if (child < this._size && this._leq(this._handles[this._nodes[child + 1]]._key, this._handles[this._nodes[child]]._key)) {
                        ++child;
                    }
                    hChild = this._nodes[child];
                    if (child > this._size || this._leq(this._handles[hCurr]._key, this._handles[hChild]._key)) {
                        this._nodes[curr] = hCurr;
                        this._handles[hCurr]._node = curr;
                        break;
                    }
                    this._nodes[curr] = hChild;
                    this._handles[hChild]._node = curr;
                    curr = child;
                }
            }
            FloatUp(curr) {
                var parent;
                var hCurr;
                var hParent;
                hCurr = this._nodes[curr];
                while (true) {
                    parent = curr >> 1;
                    hParent = this._nodes[parent];
                    if (parent == 0 || this._leq(this._handles[hParent]._key, this._handles[hCurr]._key)) {
                        this._nodes[curr] = hCurr;
                        this._handles[hCurr]._node = curr;
                        break;
                    }
                    this._nodes[curr] = hParent;
                    this._handles[hParent]._node = curr;
                    curr = parent;
                }
            }
            Init() {
                for (var i = this._size; i >= 1; --i) {
                    this.FloatDown(i);
                }
                this._initialized = true;
            }
            Insert(value) {
                var curr = ++this._size;
                if ((curr * 2) > this._max) {
                    this._max <<= 1;
                    var t_nodes = new Array(this._max + 1);
                    var t_handles = new Array(this._max + 1);
                    this._nodes.forEach((v_, i_) => {
                        t_nodes[i_] = v_;
                    });
                    this._handles.forEach((v_, i_) => {
                        t_handles[i_] = v_;
                    });
                    this._nodes = t_nodes;
                    this._handles = t_handles;
                }
                var free;
                if (this._freeList == 0) {
                    free = curr;
                }
                else {
                    free = this._freeList;
                    this._freeList = this._handles[free]._node;
                }
                this._nodes[curr] = free;
                if (this._handles[free] == null) {
                    this._handles[free] = new HandleElem();
                    this._handles[free]._key = value;
                    this._handles[free]._node = curr;
                }
                else {
                    this._handles[free]._node = curr;
                    this._handles[free]._key = value;
                }
                if (this._initialized) {
                    this.FloatUp(curr);
                }
                var result = new PQHandle();
                result._handle = free;
                return result;
            }
            ExtractMin() {
                var hMin = this._nodes[1];
                var min = this._handles[hMin]._key;
                if (this._size > 0) {
                    this._nodes[1] = this._nodes[this._size];
                    this._handles[this._nodes[1]]._node = 1;
                    this._handles[hMin]._key = null;
                    this._handles[hMin]._node = this._freeList;
                    this._freeList = hMin;
                    if (--this._size > 0) {
                        this.FloatDown(1);
                    }
                }
                return min;
            }
            Minimum() {
                return this._handles[this._nodes[1]]._key;
            }
            Remove(handle) {
                var hCurr = handle._handle;
                var curr = this._handles[hCurr]._node;
                this._nodes[curr] = this._nodes[this._size];
                this._handles[this._nodes[curr]]._node = curr;
                if (curr <= --this._size) {
                    if (curr <= 1 || this._leq(this._handles[this._nodes[curr >> 1]]._key, this._handles[this._nodes[curr]]._key)) {
                        this.FloatDown(curr);
                    }
                    else {
                        this.FloatUp(curr);
                    }
                }
                this._handles[hCurr]._key = null;
                this._handles[hCurr]._node = this._freeList;
                this._freeList = hCurr;
            }
        }
        LibTess.PriorityHeap = PriorityHeap;
        class StackItem {
            constructor(ap, ar) {
                this.p = ap;
                this.r = ar;
            }
        }
        LibTess.StackItem = StackItem;
        ;
        class PriorityQueue {
            constructor(initialSize, leq) {
                this._leq = leq;
                this._heap = new PriorityHeap(initialSize, leq);
                this._keys = new Array(initialSize);
                this._size = 0;
                this._max = initialSize;
                this._initialized = false;
            }
            get Empty() {
                return this._size == 0 && this._heap.Empty;
            }
            static Swap(ab) {
                var tmp = ab.a;
                ab.a = ab.b;
                ab.b = tmp;
            }
            Init() {
                var stack = new Array();
                var p, r, i, j, piv;
                var seed = 2016473283;
                p = 0;
                r = this._size - 1;
                this._order = new Array(this._size + 1);
                for (piv = 0, i = p; i <= r; ++piv, ++i) {
                    this._order[i] = piv;
                }
                stack.push(new StackItem(p, r));
                while (stack.length > 0) {
                    var top = stack.pop();
                    p = top.p;
                    r = top.r;
                    while (r > p + 10) {
                        seed = seed * 1539415821 + 1;
                        seed = seed & 0xffffff;
                        i = p + Math.floor(seed % (r - p + 1));
                        piv = this._order[i];
                        this._order[i] = this._order[p];
                        this._order[p] = piv;
                        i = p - 1;
                        j = r + 1;
                        do {
                            do {
                                ++i;
                            } while (!this._leq(this._keys[this._order[i]], this._keys[piv]));
                            do {
                                --j;
                            } while (!this._leq(this._keys[piv], this._keys[this._order[j]]));
                            var t = this._order[j];
                            this._order[j] = this._order[i];
                            this._order[i] = t;
                        } while (i < j);
                        var t = this._order[j];
                        this._order[j] = this._order[i];
                        this._order[i] = t;
                        if (i - p < r - j) {
                            stack.push(new StackItem(j + 1, r));
                            r = i - 1;
                        }
                        else {
                            stack.push(new StackItem(p, i - 1));
                            p = j + 1;
                        }
                    }
                    for (i = p + 1; i <= r; ++i) {
                        piv = this._order[i];
                        for (j = i; j > p && !this._leq(this._keys[piv], this._keys[this._order[j - 1]]); --j) {
                            this._order[j] = this._order[j - 1];
                        }
                        this._order[j] = piv;
                    }
                }
                this._max = this._size;
                this._initialized = true;
                this._heap.Init();
            }
            Insert(value) {
                if (this._initialized) {
                    return this._heap.Insert(value);
                }
                var curr = this._size;
                if (++this._size >= this._max) {
                    this._max <<= 1;
                    var nKeys = new Array(this._max);
                    this._keys.forEach((v_, i_) => {
                        nKeys[i_] = v_;
                    });
                    this._keys = nKeys;
                }
                this._keys[curr] = value;
                return new PQHandle(-(curr + 1));
            }
            ExtractMin() {
                if (this._size == 0) {
                    return this._heap.ExtractMin();
                }
                var sortMin = this._keys[this._order[this._size - 1]];
                if (!this._heap.Empty) {
                    var heapMin = this._heap.Minimum();
                    if (this._leq(heapMin, sortMin))
                        return this._heap.ExtractMin();
                }
                do {
                    --this._size;
                } while (this._size > 0 && this._keys[this._order[this._size - 1]] == null);
                return sortMin;
            }
            Minimum() {
                if (this._size == 0) {
                    return this._heap.Minimum();
                }
                var sortMin = this._keys[this._order[this._size - 1]];
                if (!this._heap.Empty) {
                    var heapMin = this._heap.Minimum();
                    if (this._leq(heapMin, sortMin))
                        return heapMin;
                }
                return sortMin;
            }
            Remove(handle) {
                var curr = handle._handle;
                if (curr >= 0) {
                    this._heap.Remove(handle);
                    return;
                }
                curr = -(curr + 1);
                this._keys[curr] = null;
                while (this._size > 0 && this._keys[this._order[this._size - 1]] == null) {
                    --this._size;
                }
            }
        }
        LibTess.PriorityQueue = PriorityQueue;
        class Geom {
            static IsWindingInside(rule, n) {
                "use asm";
                n = n | 0;
                rule = rule | 0;
                switch (rule) {
                    case WindingRule.EvenOdd:
                        return (n & 1) == 1;
                    case WindingRule.NonZero:
                        return n != 0;
                    case WindingRule.Positive:
                        return n > 0;
                    case WindingRule.Negative:
                        return n < 0;
                    case WindingRule.AbsGeqTwo:
                        return n >= 2 || n <= -2;
                }
                throw ("Wrong winding rule");
            }
            static VertCCW(u, v, w) {
                return (u._s * (v._t - w._t) + v._s * (w._t - u._t) + w._s * (u._t - v._t)) >= 0.0;
            }
            static VertEq(lhs, rhs) {
                return lhs._s == rhs._s && lhs._t == rhs._t;
            }
            static VertLeq(lhs, rhs) {
                return (lhs._s < rhs._s) || (lhs._s == rhs._s && lhs._t <= rhs._t);
            }
            static EdgeEval(u, v, w) {
                var gapL = v._s - u._s;
                var gapR = w._s - v._s;
                if (gapL + gapR > 0.0) {
                    if (gapL < gapR) {
                        return (v._t - u._t) + (u._t - w._t) * (gapL / (gapL + gapR));
                    }
                    else {
                        return (v._t - w._t) + (w._t - u._t) * (gapR / (gapL + gapR));
                    }
                }
                return 0.0;
            }
            static EdgeSign(u, v, w) {
                var gapL = v._s - u._s;
                var gapR = w._s - v._s;
                if (gapL + gapR > 0.0) {
                    return (v._t - w._t) * gapL + (v._t - u._t) * gapR;
                }
                return 0.0;
            }
            static TransLeq(lhs, rhs) {
                return (lhs._t < rhs._t) || (lhs._t == rhs._t && lhs._s <= rhs._s);
            }
            static TransEval(u, v, w) {
                var gapL = v._t - u._t;
                var gapR = w._t - v._t;
                if (gapL + gapR > 0.0) {
                    if (gapL < gapR) {
                        return (v._s - u._s) + (u._s - w._s) * (gapL / (gapL + gapR));
                    }
                    else {
                        return (v._s - w._s) + (w._s - u._s) * (gapR / (gapL + gapR));
                    }
                }
                return 0.0;
            }
            static TransSign(u, v, w) {
                var gapL = v._t - u._t;
                var gapR = w._t - v._t;
                if (gapL + gapR > 0.0) {
                    return (v._s - w._s) * gapL + (v._s - u._s) * gapR;
                }
                return 0.0;
            }
            static EdgeGoesLeft(e) {
                return Geom.VertLeq(e._Dst, e._Org);
            }
            static EdgeGoesRight(e) {
                return Geom.VertLeq(e._Org, e._Dst);
            }
            static VertL1dist(u, v) {
                return Math.abs(u._s - v._s) + Math.abs(u._t - v._t);
            }
            static AddWinding(eDst, eSrc) {
                eDst._winding += eSrc._winding;
                eDst._Sym._winding += eSrc._Sym._winding;
            }
            static Interpolate(a, x, b, y) {
                a = a < 0.0 ? 0.0 : a;
                b = b < 0.0 ? 0.0 : b;
                return ((a <= b) ? ((b == 0.0) ? ((x + y) / 2.0)
                    : (x + (y - x) * (a / (a + b))))
                    : (y + (x - y) * (b / (a + b))));
            }
            static EdgeIntersect(o1, d1, o2, d2, v) {
                var z1;
                var z2;
                if (!Geom.VertLeq(o1, d1)) {
                    var c = o1;
                    o1 = d1;
                    d1 = c;
                }
                if (!Geom.VertLeq(o2, d2)) {
                    var c = o2;
                    o2 = d2;
                    d2 = c;
                }
                if (!Geom.VertLeq(o1, o2)) {
                    var c = o1;
                    o1 = o2;
                    o2 = c;
                    var c = d1;
                    d1 = d2;
                    d2 = c;
                }
                if (!Geom.VertLeq(o2, d1)) {
                    v._s = (o2._s + d1._s) / 2.0;
                }
                else if (Geom.VertLeq(d1, d2)) {
                    z1 = Geom.EdgeEval(o1, o2, d1);
                    z2 = Geom.EdgeEval(o2, d1, d2);
                    if (z1 + z2 < 0.0) {
                        z1 = -z1;
                        z2 = -z2;
                    }
                    v._s = Geom.Interpolate(z1, o2._s, z2, d1._s);
                }
                else {
                    z1 = Geom.EdgeSign(o1, o2, d1);
                    z2 = -Geom.EdgeSign(o1, d2, d1);
                    if (z1 + z2 < 0.0) {
                        z1 = -z1;
                        z2 = -z2;
                    }
                    v._s = Geom.Interpolate(z1, o2._s, z2, d2._s);
                }
                if (!Geom.TransLeq(o1, d1)) {
                    var c = o1;
                    o1 = d1;
                    d1 = c;
                }
                if (!Geom.TransLeq(o2, d2)) {
                    var c = o2;
                    o2 = d2;
                    d2 = c;
                }
                if (!Geom.TransLeq(o1, o2)) {
                    var c = o1;
                    o1 = o2;
                    o2 = c;
                    var c = d1;
                    d1 = d2;
                    d2 = c;
                }
                if (!Geom.TransLeq(o2, d1)) {
                    v._t = (o2._t + d1._t) / 2.0;
                }
                else if (Geom.TransLeq(d1, d2)) {
                    z1 = Geom.TransEval(o1, o2, d1);
                    z2 = Geom.TransEval(o2, d1, d2);
                    if (z1 + z2 < 0.0) {
                        z1 = -z1;
                        z2 = -z2;
                    }
                    v._t = Geom.Interpolate(z1, o2._t, z2, d1._t);
                }
                else {
                    z1 = Geom.TransSign(o1, o2, d1);
                    z2 = -Geom.TransSign(o1, d2, d1);
                    if (z1 + z2 < 0.0) {
                        z1 = -z1;
                        z2 = -z2;
                    }
                    v._t = Geom.Interpolate(z1, o2._t, z2, d2._t);
                }
            }
        }
        LibTess.Geom = Geom;
        class Mesh {
            constructor() {
                var v = this._vHead = new Vertex();
                var f = this._fHead = new Face();
                var pair = EdgePair.Create();
                var e = this._eHead = pair._e;
                var eSym = this._eHeadSym = pair._eSym;
                v._next = v._prev = v;
                v._anEdge = null;
                f._next = f._prev = f;
                f._anEdge = null;
                f._trail = null;
                f._marked = false;
                f._inside = false;
                e._next = e;
                e._Sym = eSym;
                e._Onext = null;
                e._Lnext = null;
                e._Org = null;
                e._Lface = null;
                e._winding = 0;
                e._activeRegion = null;
                eSym._next = eSym;
                eSym._Sym = e;
                eSym._Onext = null;
                eSym._Lnext = null;
                eSym._Org = null;
                eSym._Lface = null;
                eSym._winding = 0;
                eSym._activeRegion = null;
            }
            MakeEdge() {
                var e = MeshUtils.MakeEdge(this._eHead);
                MeshUtils.MakeVertex(new Vertex(), e, this._vHead);
                MeshUtils.MakeVertex(new Vertex(), e._Sym, this._vHead);
                MeshUtils.MakeFace(new Face(), e, this._fHead);
                return e;
            }
            Splice(eOrg, eDst) {
                if (eOrg == eDst) {
                    return;
                }
                var joiningVertices = false;
                if (eDst._Org != eOrg._Org) {
                    joiningVertices = true;
                    MeshUtils.KillVertex(eDst._Org, eOrg._Org);
                }
                var joiningLoops = false;
                if (eDst._Lface != eOrg._Lface) {
                    joiningLoops = true;
                    MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
                }
                MeshUtils.Splice(eDst, eOrg);
                if (!joiningVertices) {
                    MeshUtils.MakeVertex(new Vertex(), eDst, eOrg._Org);
                    eOrg._Org._anEdge = eOrg;
                }
                if (!joiningLoops) {
                    MeshUtils.MakeFace(new Face(), eDst, eOrg._Lface);
                    eOrg._Lface._anEdge = eOrg;
                }
            }
            Delete(eDel) {
                var eDelSym = eDel._Sym;
                var joiningLoops = false;
                if (eDel._Lface != eDel._Rface) {
                    joiningLoops = true;
                    MeshUtils.KillFace(eDel._Lface, eDel._Rface);
                }
                if (eDel._Onext == eDel) {
                    MeshUtils.KillVertex(eDel._Org, null);
                }
                else {
                    eDel._Rface._anEdge = eDel._Oprev;
                    eDel._Org._anEdge = eDel._Onext;
                    MeshUtils.Splice(eDel, eDel._Oprev);
                    if (!joiningLoops) {
                        MeshUtils.MakeFace(new Face(), eDel, eDel._Lface);
                    }
                }
                if (eDelSym._Onext == eDelSym) {
                    MeshUtils.KillVertex(eDelSym._Org, null);
                    MeshUtils.KillFace(eDelSym._Lface, null);
                }
                else {
                    eDel._Lface._anEdge = eDelSym._Oprev;
                    eDelSym._Org._anEdge = eDelSym._Onext;
                    MeshUtils.Splice(eDelSym, eDelSym._Oprev);
                }
                MeshUtils.KillEdge(eDel);
            }
            AddEdgeVertex(eOrg) {
                var eNew = MeshUtils.MakeEdge(eOrg);
                var eNewSym = eNew._Sym;
                MeshUtils.Splice(eNew, eOrg._Lnext);
                eNew._Org = eOrg._Dst;
                MeshUtils.MakeVertex(new Vertex(), eNewSym, eNew._Org);
                eNew._Lface = eNewSym._Lface = eOrg._Lface;
                return eNew;
            }
            SplitEdge(eOrg) {
                var eTmp = this.AddEdgeVertex(eOrg);
                var eNew = eTmp._Sym;
                MeshUtils.Splice(eOrg._Sym, eOrg._Sym._Oprev);
                MeshUtils.Splice(eOrg._Sym, eNew);
                eOrg._Dst = eNew._Org;
                eNew._Dst._anEdge = eNew._Sym;
                eNew._Rface = eOrg._Rface;
                eNew._winding = eOrg._winding;
                eNew._Sym._winding = eOrg._Sym._winding;
                return eNew;
            }
            Connect(eOrg, eDst) {
                var eNew = MeshUtils.MakeEdge(eOrg);
                var eNewSym = eNew._Sym;
                var joiningLoops = false;
                if (eDst._Lface != eOrg._Lface) {
                    joiningLoops = true;
                    MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
                }
                MeshUtils.Splice(eNew, eOrg._Lnext);
                MeshUtils.Splice(eNewSym, eDst);
                eNew._Org = eOrg._Dst;
                eNewSym._Org = eDst._Org;
                eNew._Lface = eNewSym._Lface = eOrg._Lface;
                eOrg._Lface._anEdge = eNewSym;
                if (!joiningLoops) {
                    MeshUtils.MakeFace(new Face(), eNew, eOrg._Lface);
                }
                return eNew;
            }
            ZapFace(fZap) {
                var eStart = fZap._anEdge;
                var eNext = eStart._Lnext;
                var e;
                var eSym;
                do {
                    e = eNext;
                    eNext = e._Lnext;
                    e._Lface = null;
                    if (e._Rface == null) {
                        if (e._Onext == e) {
                            MeshUtils.KillVertex(e._Org, null);
                        }
                        else {
                            e._Org._anEdge = e._Onext;
                            MeshUtils.Splice(e, e._Oprev);
                        }
                        eSym = e._Sym;
                        if (eSym._Onext == eSym) {
                            MeshUtils.KillVertex(eSym._Org, null);
                        }
                        else {
                            eSym._Org._anEdge = eSym._Onext;
                            MeshUtils.Splice(eSym, eSym._Oprev);
                        }
                        MeshUtils.KillEdge(e);
                    }
                } while (e != eStart);
                var fPrev = fZap._prev;
                var fNext = fZap._next;
                fNext._prev = fPrev;
                fPrev._next = fNext;
            }
            MergeConvexFaces(maxVertsPerFace) {
                for (var f = this._fHead._next; f != this._fHead; f = f._next) {
                    if (!f._inside) {
                        continue;
                    }
                    var eCur = f._anEdge;
                    var vStart = eCur._Org;
                    while (true) {
                        var eNext = eCur._Lnext;
                        var eSym = eCur._Sym;
                        if (eSym != null && eSym._Lface != null && eSym._Lface._inside) {
                            var curNv = f.VertsCount;
                            var symNv = eSym._Lface.VertsCount;
                            if ((curNv + symNv - 2) <= maxVertsPerFace) {
                                if (Geom.VertCCW(eCur._Lprev._Org, eCur._Org, eSym._Lnext._Lnext._Org) &&
                                    Geom.VertCCW(eSym._Lprev._Org, eSym._Org, eCur._Lnext._Lnext._Org)) {
                                    eNext = eSym._Lnext;
                                    this.Delete(eSym);
                                    eCur = null;
                                }
                            }
                        }
                        if (eCur != null && eCur._Lnext._Org == vStart)
                            break;
                        eCur = eNext;
                    }
                }
            }
            Check() {
                var e;
                var fPrev = this._fHead;
                var f;
                for (fPrev = this._fHead; (f = fPrev._next) != this._fHead; fPrev = f) {
                    e = f._anEdge;
                    do {
                        Debug.Assert(e._Sym != e);
                        Debug.Assert(e._Sym._Sym == e);
                        Debug.Assert(e._Lnext._Onext._Sym == e);
                        Debug.Assert(e._Onext._Sym._Lnext == e);
                        Debug.Assert(e._Lface == f);
                        e = e._Lnext;
                    } while (e != f._anEdge);
                }
                Debug.Assert(f._prev == fPrev && f._anEdge == null);
                var vPrev = this._vHead;
                var v;
                for (vPrev = this._vHead; (v = vPrev._next) != this._vHead; vPrev = v) {
                    Debug.Assert(v._prev == vPrev);
                    e = v._anEdge;
                    do {
                        Debug.Assert(e._Sym != e);
                        Debug.Assert(e._Sym._Sym == e);
                        Debug.Assert(e._Lnext._Onext._Sym == e);
                        Debug.Assert(e._Onext._Sym._Lnext == e);
                        Debug.Assert(e._Org == v);
                        e = e._Onext;
                    } while (e != v._anEdge);
                }
                Debug.Assert(v._prev == vPrev && v._anEdge == null);
                var ePrev = this._eHead;
                for (ePrev = this._eHead; (e = ePrev._next) != this._eHead; ePrev = e) {
                    Debug.Assert(e._Sym._next == ePrev._Sym);
                    Debug.Assert(e._Sym != e);
                    Debug.Assert(e._Sym._Sym == e);
                    Debug.Assert(e._Org != null);
                    Debug.Assert(e._Dst != null);
                    Debug.Assert(e._Lnext._Onext._Sym == e);
                    Debug.Assert(e._Onext._Sym._Lnext == e);
                }
                Debug.Assert(e._Sym._next == ePrev._Sym
                    && e._Sym == this._eHeadSym
                    && e._Sym._Sym == e
                    && e._Org == null && e._Dst == null
                    && e._Lface == null && e._Rface == null);
            }
        }
        LibTess.Mesh = Mesh;
        class ActiveRegion {
        }
        LibTess.ActiveRegion = ActiveRegion;
        class Tess {
            constructor() {
                this._normal = new Vec3();
                this._sUnit = new Vec3();
                this._tUnit = new Vec3();
                this.SUnitX = 1.0;
                this.SUnitY = 0.0;
                this.SentinelCoord = 4e30;
                this._normal = Vec3.Zero;
                this._bminX = this._bminY = this._bmaxX = this._bmaxY = 0.0;
                this._windingRule = WindingRule.EvenOdd;
                this._mesh = null;
                this._vertices = null;
                this._vertexCount = 0;
                this._elements = null;
                this._elementCount = 0;
            }
            get Normal() { return this._normal; }
            set Normal(value) { this._normal = value; }
            get Vertices() { return this._vertices; }
            get VertexCount() { return this._vertexCount; }
            get Elements() { return this._elements; }
            get ElementCount() { return this._elementCount; }
            ComputeNormal(norm) {
                var v = this._mesh._vHead._next;
                var minVal = [v._coords.X, v._coords.Y, v._coords.Z];
                var minVert = [v, v, v];
                var maxVal = [v._coords.X, v._coords.Y, v._coords.Z];
                var maxVert = [v, v, v];
                for (; v != this._mesh._vHead; v = v._next) {
                    if (v._coords.X < minVal[0]) {
                        minVal[0] = v._coords.X;
                        minVert[0] = v;
                    }
                    if (v._coords.Y < minVal[1]) {
                        minVal[1] = v._coords.Y;
                        minVert[1] = v;
                    }
                    if (v._coords.Z < minVal[2]) {
                        minVal[2] = v._coords.Z;
                        minVert[2] = v;
                    }
                    if (v._coords.X > maxVal[0]) {
                        maxVal[0] = v._coords.X;
                        maxVert[0] = v;
                    }
                    if (v._coords.Y > maxVal[1]) {
                        maxVal[1] = v._coords.Y;
                        maxVert[1] = v;
                    }
                    if (v._coords.Z > maxVal[2]) {
                        maxVal[2] = v._coords.Z;
                        maxVert[2] = v;
                    }
                }
                var i = 0;
                if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {
                    i = 1;
                }
                if (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) {
                    i = 2;
                }
                if (minVal[i] >= maxVal[i]) {
                    norm.SetValues(0.0, 0.0, 1.0);
                    return;
                }
                var maxLen2 = 0.0, tLen2;
                var v1 = minVert[i];
                var v2 = maxVert[i];
                var d1 = Vec3.Zero;
                var d2 = Vec3.Zero;
                var tNorm = Vec3.Zero;
                Vec3.Sub(v1._coords, v2._coords, d1);
                for (v = this._mesh._vHead._next; v != this._mesh._vHead; v = v._next) {
                    Vec3.Sub(v._coords, v2._coords, d2);
                    tNorm.X = d1.Y * d2.Z - d1.Z * d2.Y;
                    tNorm.Y = d1.Z * d2.X - d1.X * d2.Z;
                    tNorm.Z = d1.X * d2.Y - d1.Y * d2.X;
                    tLen2 = tNorm.X * tNorm.X + tNorm.Y * tNorm.Y + tNorm.Z * tNorm.Z;
                    if (tLen2 > maxLen2) {
                        maxLen2 = tLen2;
                        norm.CopyFrom(tNorm);
                    }
                }
                if (maxLen2 <= 0.0) {
                    norm.SetValues(0, 0, 0);
                    i = Vec3.LongAxis(d1);
                    norm[i] = 1.0;
                }
            }
            CheckOrientation() {
                var area = 0.0;
                for (var f = this._mesh._fHead._next; f != this._mesh._fHead; f = f._next) {
                    var e = f._anEdge;
                    if (e._winding <= 0) {
                        continue;
                    }
                    do {
                        area += (e._Org._s - e._Dst._s) * (e._Org._t + e._Dst._t);
                        e = e._Lnext;
                    } while (e != f._anEdge);
                }
                if (area < 0.0) {
                    for (var v = this._mesh._vHead._next; v != this._mesh._vHead; v = v._next) {
                        v._t = -v._t;
                    }
                    Vec3.Neg(this._tUnit);
                }
            }
            ProjectPolygon() {
                var norm = this._normal;
                var computedNormal = false;
                if (norm.X == 0.0 && norm.Y == 0.0 && norm.Z == 0.0) {
                    this.ComputeNormal(norm);
                    computedNormal = true;
                }
                var i = Vec3.LongAxis(norm);
                this._sUnit[i] = 0.0;
                this._sUnit[(i + 1) % 3] = this.SUnitX;
                this._sUnit[(i + 2) % 3] = this.SUnitY;
                this._tUnit[i] = 0.0;
                this._tUnit[(i + 1) % 3] = norm[i] > 0.0 ? -this.SUnitY : this.SUnitY;
                this._tUnit[(i + 2) % 3] = norm[i] > 0.0 ? this.SUnitX : -this.SUnitX;
                for (var v = this._mesh._vHead._next; v != this._mesh._vHead; v = v._next) {
                    v._s = Vec3.Dot(v._coords, this._sUnit);
                    v._t = Vec3.Dot(v._coords, this._tUnit);
                }
                if (computedNormal) {
                    this.CheckOrientation();
                }
                var first = true;
                for (var v = this._mesh._vHead._next; v != this._mesh._vHead; v = v._next) {
                    if (first) {
                        this._bminX = this._bmaxX = v._s;
                        this._bminY = this._bmaxY = v._t;
                        first = false;
                    }
                    else {
                        if (v._s < this._bminX)
                            this._bminX = v._s;
                        if (v._s > this._bmaxX)
                            this._bmaxX = v._s;
                        if (v._t < this._bminY)
                            this._bminY = v._t;
                        if (v._t > this._bmaxY)
                            this._bmaxY = v._t;
                    }
                }
            }
            TessellateMonoRegion(face) {
                var up = face._anEdge;
                Debug.Assert(up._Lnext != up && up._Lnext._Lnext != up);
                for (; Geom.VertLeq(up._Dst, up._Org); up = up._Lprev)
                    ;
                for (; Geom.VertLeq(up._Org, up._Dst); up = up._Lnext)
                    ;
                var lo = up._Lprev;
                while (up._Lnext != lo) {
                    if (Geom.VertLeq(up._Dst, lo._Org)) {
                        while (lo._Lnext != up && (Geom.EdgeGoesLeft(lo._Lnext)
                            || Geom.EdgeSign(lo._Org, lo._Dst, lo._Lnext._Dst) <= 0.0)) {
                            lo = this._mesh.Connect(lo._Lnext, lo)._Sym;
                        }
                        lo = lo._Lprev;
                    }
                    else {
                        while (lo._Lnext != up && (Geom.EdgeGoesRight(up._Lprev)
                            || Geom.EdgeSign(up._Dst, up._Org, up._Lprev._Org) >= 0.0)) {
                            up = this._mesh.Connect(up, up._Lprev)._Sym;
                        }
                        up = up._Lnext;
                    }
                }
                Debug.Assert(lo._Lnext != up);
                while (lo._Lnext._Lnext != up) {
                    lo = this._mesh.Connect(lo._Lnext, lo)._Sym;
                }
            }
            TessellateInterior() {
                var f;
                var next;
                for (f = this._mesh._fHead._next; f != this._mesh._fHead; f = next) {
                    next = f._next;
                    if (f._inside) {
                        this.TessellateMonoRegion(f);
                    }
                }
            }
            DiscardExterior() {
                var f;
                var next;
                for (f = this._mesh._fHead._next; f != this._mesh._fHead; f = next) {
                    next = f._next;
                    if (!f._inside) {
                        this._mesh.ZapFace(f);
                    }
                }
            }
            SetWindingNumber(value, keepOnlyBoundary) {
                var e;
                var eNext;
                for (e = this._mesh._eHead._next; e != this._mesh._eHead; e = eNext) {
                    eNext = e._next;
                    if (e._Rface._inside != e._Lface._inside) {
                        e._winding = (e._Lface._inside) ? value : -value;
                    }
                    else {
                        if (!keepOnlyBoundary) {
                            e._winding = 0;
                        }
                        else {
                            this._mesh.Delete(e);
                        }
                    }
                }
            }
            GetNeighbourFace(edge) {
                if (edge._Rface == null)
                    return MeshUtils.Undef;
                if (!edge._Rface._inside)
                    return MeshUtils.Undef;
                return edge._Rface._n;
            }
            OutputPolymesh(elementType, polySize) {
                var v;
                var f;
                var edge;
                var maxFaceCount = 0;
                var maxVertexCount = 0;
                var faceVerts;
                var i;
                if (polySize < 3) {
                    polySize = 3;
                }
                if (polySize > 3) {
                    this._mesh.MergeConvexFaces(polySize);
                }
                for (v = this._mesh._vHead._next; v != this._mesh._vHead; v = v._next)
                    v._n = MeshUtils.Undef;
                for (f = this._mesh._fHead._next; f != this._mesh._fHead; f = f._next) {
                    f._n = MeshUtils.Undef;
                    if (!f._inside)
                        continue;
                    edge = f._anEdge;
                    faceVerts = 0;
                    do {
                        v = edge._Org;
                        if (v._n == MeshUtils.Undef) {
                            v._n = maxVertexCount;
                            maxVertexCount++;
                        }
                        faceVerts++;
                        edge = edge._Lnext;
                    } while (edge != f._anEdge);
                    Debug.Assert(faceVerts <= polySize);
                    f._n = maxFaceCount;
                    ++maxFaceCount;
                }
                this._elementCount = maxFaceCount;
                if (elementType == ElementType.ConnectedPolygons)
                    maxFaceCount *= 2;
                this._elements = new Array(maxFaceCount * polySize);
                this._vertexCount = maxVertexCount;
                this._vertices = new Array(this._vertexCount);
                for (var i = 0; i < this._vertexCount; i++) {
                    this._vertices[i] = new ContourVertex();
                }
                ;
                for (v = this._mesh._vHead._next; v != this._mesh._vHead; v = v._next) {
                    if (v._n != MeshUtils.Undef) {
                        var n = v._n;
                        this._vertices[v._n].Position.CopyFrom(v._coords);
                        this._vertices[v._n].Data = v._data;
                    }
                }
                var elementIndex = 0;
                for (f = this._mesh._fHead._next; f != this._mesh._fHead; f = f._next) {
                    if (!f._inside)
                        continue;
                    edge = f._anEdge;
                    faceVerts = 0;
                    do {
                        v = edge._Org;
                        this._elements[elementIndex++] = v._n;
                        faceVerts++;
                        edge = edge._Lnext;
                    } while (edge != f._anEdge);
                    for (i = faceVerts; i < polySize; ++i) {
                        this._elements[elementIndex++] = MeshUtils.Undef;
                    }
                    if (elementType == ElementType.ConnectedPolygons) {
                        edge = f._anEdge;
                        do {
                            this._elements[elementIndex++] = this.GetNeighbourFace(edge);
                            edge = edge._Lnext;
                        } while (edge != f._anEdge);
                        for (i = faceVerts; i < polySize; ++i) {
                            this._elements[elementIndex++] = MeshUtils.Undef;
                        }
                    }
                }
            }
            OutputContours() {
                var f;
                var edge;
                var start;
                var startVert = 0;
                var vertCount = 0;
                this._vertexCount = 0;
                this._elementCount = 0;
                for (f = this._mesh._fHead._next; f != this._mesh._fHead; f = f._next) {
                    if (!f._inside)
                        continue;
                    start = edge = f._anEdge;
                    do {
                        ++this._vertexCount;
                        edge = edge._Lnext;
                    } while (edge != start);
                    ++this._elementCount;
                }
                this._elements = new Array(this._elementCount * 2);
                this._vertices = new Array(this._vertexCount);
                for (var i = 0; i < this._vertexCount; i++) {
                    this._vertices[i] = new ContourVertex();
                }
                ;
                var vertIndex = 0;
                var elementIndex = 0;
                startVert = 0;
                for (f = this._mesh._fHead._next; f != this._mesh._fHead; f = f._next) {
                    if (!f._inside)
                        continue;
                    vertCount = 0;
                    start = edge = f._anEdge;
                    do {
                        this._vertices[vertIndex].Position.CopyFrom(edge._Org._coords);
                        this._vertices[vertIndex].Data = edge._Org._data;
                        ++vertIndex;
                        ++vertCount;
                        edge = edge._Lnext;
                    } while (edge != start);
                    this._elements[elementIndex++] = startVert;
                    this._elements[elementIndex++] = vertCount;
                    startVert += vertCount;
                }
            }
            SignedArea(vertices) {
                var area = 0.0;
                for (var i = 0; i < vertices.length; i++) {
                    var v0 = vertices[i];
                    var v1 = vertices[(i + 1) % vertices.length];
                    area += v0.Position.X * v1.Position.Y;
                    area -= v0.Position.Y * v1.Position.X;
                }
                return area * 0.5;
            }
            AddContour(vertices, forceOrientation = ContourOrientation.Original) {
                if (this._mesh == null) {
                    this._mesh = new Mesh();
                }
                var reverse = false;
                if (forceOrientation != ContourOrientation.Original) {
                    var area = this.SignedArea(vertices);
                    reverse = (forceOrientation == ContourOrientation.Clockwise && area < 0.0) || (forceOrientation == ContourOrientation.CounterClockwise && area > 0.0);
                }
                var e = null;
                for (var i = 0; i < vertices.length; ++i) {
                    if (e == null) {
                        e = this._mesh.MakeEdge();
                        this._mesh.Splice(e, e._Sym);
                    }
                    else {
                        this._mesh.SplitEdge(e);
                        e = e._Lnext;
                    }
                    var index = reverse ? vertices.length - 1 - i : i;
                    e._Org._coords.CopyFrom(vertices[index].Position);
                    e._Org._data = vertices[index].Data;
                    e._winding = 1;
                    e._Sym._winding = -1;
                }
            }
            Tessellate(windingRule, elementType, polySize, combineCallback) {
                this._vertices = null;
                this._elements = null;
                this._windingRule = windingRule;
                this._combineCallback = combineCallback;
                if (this._mesh == null) {
                    return;
                }
                this.ProjectPolygon();
                this.ComputeInterior();
                if (elementType == ElementType.BoundaryContours) {
                    this.SetWindingNumber(1, true);
                }
                else {
                    this.TessellateInterior();
                }
                this._mesh.Check();
                if (elementType == ElementType.BoundaryContours) {
                    this.OutputContours();
                }
                else {
                    this.OutputPolymesh(elementType, polySize);
                }
                this._mesh = null;
            }
            RegionBelow(reg) {
                return reg._nodeUp._prev._key;
            }
            RegionAbove(reg) {
                return reg._nodeUp._next._key;
            }
            EdgeLeq() {
                return (reg1, reg2) => {
                    var e1 = reg1._eUp;
                    var e2 = reg2._eUp;
                    if (e1._Dst == this._event) {
                        if (e2._Dst == this._event) {
                            if (Geom.VertLeq(e1._Org, e2._Org)) {
                                return Geom.EdgeSign(e2._Dst, e1._Org, e2._Org) <= 0.0;
                            }
                            return Geom.EdgeSign(e1._Dst, e2._Org, e1._Org) >= 0.0;
                        }
                        return Geom.EdgeSign(e2._Dst, this._event, e2._Org) <= 0.0;
                    }
                    if (e2._Dst == this._event) {
                        return Geom.EdgeSign(e1._Dst, this._event, e1._Org) >= 0.0;
                    }
                    var t1 = Geom.EdgeEval(e1._Dst, this._event, e1._Org);
                    var t2 = Geom.EdgeEval(e2._Dst, this._event, e2._Org);
                    return (t1 >= t2);
                };
            }
            DeleteRegion(reg) {
                if (reg._fixUpperEdge) {
                    Debug.Assert(reg._eUp._winding == 0);
                }
                reg._eUp._activeRegion = null;
                this._dict.Remove(reg._nodeUp);
            }
            FixUpperEdge(reg, newEdge) {
                Debug.Assert(reg._fixUpperEdge);
                this._mesh.Delete(reg._eUp);
                reg._fixUpperEdge = false;
                reg._eUp = newEdge;
                newEdge._activeRegion = reg;
            }
            TopLeftRegion(reg) {
                var org = reg._eUp._Org;
                do {
                    reg = this.RegionAbove(reg);
                } while (reg._eUp._Org == org);
                if (reg._fixUpperEdge) {
                    var e = this._mesh.Connect(this.RegionBelow(reg)._eUp._Sym, reg._eUp._Lnext);
                    this.FixUpperEdge(reg, e);
                    reg = this.RegionAbove(reg);
                }
                return reg;
            }
            TopRightRegion(reg) {
                var dst = reg._eUp._Dst;
                do {
                    reg = this.RegionAbove(reg);
                } while (reg._eUp._Dst == dst);
                return reg;
            }
            AddRegionBelow(regAbove, eNewUp) {
                var regNew = new ActiveRegion();
                regNew._eUp = eNewUp;
                regNew._nodeUp = this._dict.InsertBefore(regAbove._nodeUp, regNew);
                regNew._fixUpperEdge = false;
                regNew._sentinel = false;
                regNew._dirty = false;
                eNewUp._activeRegion = regNew;
                return regNew;
            }
            ComputeWinding(reg) {
                reg._windingNumber = this.RegionAbove(reg)._windingNumber + reg._eUp._winding;
                reg._inside = Geom.IsWindingInside(this._windingRule, reg._windingNumber);
            }
            FinishRegion(reg) {
                var e = reg._eUp;
                var f = e._Lface;
                f._inside = reg._inside;
                f._anEdge = e;
                this.DeleteRegion(reg);
            }
            FinishLeftRegions(regFirst, regLast) {
                var regPrev = regFirst;
                var ePrev = regFirst._eUp;
                while (regPrev != regLast) {
                    regPrev._fixUpperEdge = false;
                    var reg = this.RegionBelow(regPrev);
                    var e = reg._eUp;
                    if (e._Org != ePrev._Org) {
                        if (!reg._fixUpperEdge) {
                            this.FinishRegion(regPrev);
                            break;
                        }
                        e = this._mesh.Connect(ePrev._Lprev, e._Sym);
                        this.FixUpperEdge(reg, e);
                    }
                    if (ePrev._Onext != e) {
                        this._mesh.Splice(e._Oprev, e);
                        this._mesh.Splice(ePrev, e);
                    }
                    this.FinishRegion(regPrev);
                    ePrev = reg._eUp;
                    regPrev = reg;
                }
                return ePrev;
            }
            AddRightEdges(regUp, eFirst, eLast, eTopLeft, cleanUp) {
                var firstTime = true;
                var e = eFirst;
                do {
                    Debug.Assert(Geom.VertLeq(e._Org, e._Dst));
                    this.AddRegionBelow(regUp, e._Sym);
                    e = e._Onext;
                } while (e != eLast);
                if (eTopLeft == null) {
                    eTopLeft = this.RegionBelow(regUp)._eUp._Rprev;
                }
                var regPrev = regUp;
                var reg;
                var ePrev = eTopLeft;
                while (true) {
                    reg = this.RegionBelow(regPrev);
                    e = reg._eUp._Sym;
                    if (e._Org != ePrev._Org)
                        break;
                    if (e._Onext != ePrev) {
                        this._mesh.Splice(e._Oprev, e);
                        this._mesh.Splice(ePrev._Oprev, e);
                    }
                    reg._windingNumber = regPrev._windingNumber - e._winding;
                    reg._inside = Geom.IsWindingInside(this._windingRule, reg._windingNumber);
                    regPrev._dirty = true;
                    if (!firstTime && this.CheckForRightSplice(regPrev)) {
                        Geom.AddWinding(e, ePrev);
                        this.DeleteRegion(regPrev);
                        this._mesh.Delete(ePrev);
                    }
                    firstTime = false;
                    regPrev = reg;
                    ePrev = e;
                }
                regPrev._dirty = true;
                Debug.Assert(regPrev._windingNumber - e._winding == reg._windingNumber);
                if (cleanUp) {
                    this.WalkDirtyRegions(regPrev);
                }
            }
            SpliceMergeVertices(e1, e2) {
                this._mesh.Splice(e1, e2);
            }
            VertexWeights(isect, org, dst, out) {
                var t1 = Geom.VertL1dist(org, isect);
                var t2 = Geom.VertL1dist(dst, isect);
                out.w0 = 0.5 * t2 / (t1 + t2);
                out.w1 = 0.5 * t1 / (t1 + t2);
                isect._coords.X += out.w0 * org._coords.X + out.w1 * dst._coords.X;
                isect._coords.Y += out.w0 * org._coords.Y + out.w1 * dst._coords.Y;
                isect._coords.Z += out.w0 * org._coords.Z + out.w1 * dst._coords.Z;
            }
            GetIntersectData(isect, orgUp, dstUp, orgLo, dstLo) {
                isect._coords = Vec3.Zero;
                var out1 = { w0: 0, w1: 0 };
                var out2 = { w0: 0, w1: 0 };
                this.VertexWeights(isect, orgUp, dstUp, out1);
                this.VertexWeights(isect, orgLo, dstLo, out2);
                if (this._combineCallback != null) {
                    isect._data = this._combineCallback(isect._coords, [orgUp._data, dstUp._data, orgLo._data, dstLo._data], [out1.w0, out1.w1, out2.w0, out2.w1]);
                }
            }
            CheckForRightSplice(regUp) {
                var regLo = this.RegionBelow(regUp);
                var eUp = regUp._eUp;
                var eLo = regLo._eUp;
                if (Geom.VertLeq(eUp._Org, eLo._Org)) {
                    if (Geom.EdgeSign(eLo._Dst, eUp._Org, eLo._Org) > 0.0) {
                        return false;
                    }
                    if (!Geom.VertEq(eUp._Org, eLo._Org)) {
                        this._mesh.SplitEdge(eLo._Sym);
                        this._mesh.Splice(eUp, eLo._Oprev);
                        regUp._dirty = regLo._dirty = true;
                    }
                    else if (eUp._Org != eLo._Org) {
                        this._pq.Remove(eUp._Org._pqHandle);
                        this.SpliceMergeVertices(eLo._Oprev, eUp);
                    }
                }
                else {
                    if (Geom.EdgeSign(eUp._Dst, eLo._Org, eUp._Org) < 0.0) {
                        return false;
                    }
                    this.RegionAbove(regUp)._dirty = regUp._dirty = true;
                    this._mesh.SplitEdge(eUp._Sym);
                    this._mesh.Splice(eLo._Oprev, eUp);
                }
                return true;
            }
            CheckForLeftSplice(regUp) {
                var regLo = this.RegionBelow(regUp);
                var eUp = regUp._eUp;
                var eLo = regLo._eUp;
                Debug.Assert(!Geom.VertEq(eUp._Dst, eLo._Dst));
                if (Geom.VertLeq(eUp._Dst, eLo._Dst)) {
                    if (Geom.EdgeSign(eUp._Dst, eLo._Dst, eUp._Org) < 0.0) {
                        return false;
                    }
                    this.RegionAbove(regUp)._dirty = regUp._dirty = true;
                    var e = this._mesh.SplitEdge(eUp);
                    this._mesh.Splice(eLo._Sym, e);
                    e._Lface._inside = regUp._inside;
                }
                else {
                    if (Geom.EdgeSign(eLo._Dst, eUp._Dst, eLo._Org) > 0.0) {
                        return false;
                    }
                    regUp._dirty = regLo._dirty = true;
                    var e = this._mesh.SplitEdge(eLo);
                    this._mesh.Splice(eUp._Lnext, eLo._Sym);
                    e._Rface._inside = regUp._inside;
                }
                return true;
            }
            CheckForIntersect(regUp) {
                var regLo = this.RegionBelow(regUp);
                var eUp = regUp._eUp;
                var eLo = regLo._eUp;
                var orgUp = eUp._Org;
                var orgLo = eLo._Org;
                var dstUp = eUp._Dst;
                var dstLo = eLo._Dst;
                Debug.Assert(!Geom.VertEq(dstLo, dstUp));
                Debug.Assert(Geom.EdgeSign(dstUp, this._event, orgUp) <= 0.0);
                Debug.Assert(Geom.EdgeSign(dstLo, this._event, orgLo) >= 0.0);
                Debug.Assert(orgUp != this._event && orgLo != this._event);
                Debug.Assert(!regUp._fixUpperEdge && !regLo._fixUpperEdge);
                if (orgUp == orgLo) {
                    return false;
                }
                var tMinUp = Math.min(orgUp._t, dstUp._t);
                var tMaxLo = Math.max(orgLo._t, dstLo._t);
                if (tMinUp > tMaxLo) {
                    return false;
                }
                if (Geom.VertLeq(orgUp, orgLo)) {
                    if (Geom.EdgeSign(dstLo, orgUp, orgLo) > 0.0) {
                        return false;
                    }
                }
                else {
                    if (Geom.EdgeSign(dstUp, orgLo, orgUp) < 0.0) {
                        return false;
                    }
                }
                var isect = new Vertex();
                Geom.EdgeIntersect(dstUp, orgUp, dstLo, orgLo, isect);
                Debug.Assert(Math.min(orgUp._t, dstUp._t) <= isect._t);
                Debug.Assert(isect._t <= Math.max(orgLo._t, dstLo._t));
                Debug.Assert(Math.min(dstLo._s, dstUp._s) <= isect._s);
                Debug.Assert(isect._s <= Math.max(orgLo._s, orgUp._s));
                if (Geom.VertLeq(isect, this._event)) {
                    isect._s = this._event._s;
                    isect._t = this._event._t;
                }
                var orgMin = Geom.VertLeq(orgUp, orgLo) ? orgUp : orgLo;
                if (Geom.VertLeq(orgMin, isect)) {
                    isect._s = orgMin._s;
                    isect._t = orgMin._t;
                }
                if (Geom.VertEq(isect, orgUp) || Geom.VertEq(isect, orgLo)) {
                    this.CheckForRightSplice(regUp);
                    return false;
                }
                if ((!Geom.VertEq(dstUp, this._event)
                    && Geom.EdgeSign(dstUp, this._event, isect) >= 0.0)
                    || (!Geom.VertEq(dstLo, this._event)
                        && Geom.EdgeSign(dstLo, this._event, isect) <= 0.0)) {
                    if (dstLo == this._event) {
                        this._mesh.SplitEdge(eUp._Sym);
                        this._mesh.Splice(eLo._Sym, eUp);
                        regUp = this.TopLeftRegion(regUp);
                        eUp = this.RegionBelow(regUp)._eUp;
                        this.FinishLeftRegions(this.RegionBelow(regUp), regLo);
                        this.AddRightEdges(regUp, eUp._Oprev, eUp, eUp, true);
                        return true;
                    }
                    if (dstUp == this._event) {
                        this._mesh.SplitEdge(eLo._Sym);
                        this._mesh.Splice(eUp._Lnext, eLo._Oprev);
                        regLo = regUp;
                        regUp = this.TopRightRegion(regUp);
                        var e = this.RegionBelow(regUp)._eUp._Rprev;
                        regLo._eUp = eLo._Oprev;
                        eLo = this.FinishLeftRegions(regLo, null);
                        this.AddRightEdges(regUp, eLo._Onext, eUp._Rprev, e, true);
                        return true;
                    }
                    if (Geom.EdgeSign(dstUp, this._event, isect) >= 0.0) {
                        this.RegionAbove(regUp)._dirty = regUp._dirty = true;
                        this._mesh.SplitEdge(eUp._Sym);
                        eUp._Org._s = this._event._s;
                        eUp._Org._t = this._event._t;
                    }
                    if (Geom.EdgeSign(dstLo, this._event, isect) <= 0.0) {
                        regUp._dirty = regLo._dirty = true;
                        this._mesh.SplitEdge(eLo._Sym);
                        eLo._Org._s = this._event._s;
                        eLo._Org._t = this._event._t;
                    }
                    return false;
                }
                this._mesh.SplitEdge(eUp._Sym);
                this._mesh.SplitEdge(eLo._Sym);
                this._mesh.Splice(eLo._Oprev, eUp);
                eUp._Org._s = isect._s;
                eUp._Org._t = isect._t;
                eUp._Org._pqHandle = this._pq.Insert(eUp._Org);
                if (eUp._Org._pqHandle._handle == PQHandle.Invalid) {
                    throw "PQHandle should not be invalid";
                }
                this.GetIntersectData(eUp._Org, orgUp, dstUp, orgLo, dstLo);
                this.RegionAbove(regUp)._dirty = regUp._dirty = regLo._dirty = true;
                return false;
            }
            WalkDirtyRegions(regUp) {
                var regLo = this.RegionBelow(regUp);
                var eUp;
                var eLo;
                while (true) {
                    while (regLo._dirty) {
                        regUp = regLo;
                        regLo = this.RegionBelow(regLo);
                    }
                    if (!regUp._dirty) {
                        regLo = regUp;
                        regUp = this.RegionAbove(regUp);
                        if (regUp == null || !regUp._dirty) {
                            return;
                        }
                    }
                    regUp._dirty = false;
                    eUp = regUp._eUp;
                    eLo = regLo._eUp;
                    if (eUp._Dst != eLo._Dst) {
                        if (this.CheckForLeftSplice(regUp)) {
                            if (regLo._fixUpperEdge) {
                                this.DeleteRegion(regLo);
                                this._mesh.Delete(eLo);
                                regLo = this.RegionBelow(regUp);
                                eLo = regLo._eUp;
                            }
                            else if (regUp._fixUpperEdge) {
                                this.DeleteRegion(regUp);
                                this._mesh.Delete(eUp);
                                regUp = this.RegionAbove(regLo);
                                eUp = regUp._eUp;
                            }
                        }
                    }
                    if (eUp._Org != eLo._Org) {
                        if (eUp._Dst != eLo._Dst
                            && !regUp._fixUpperEdge && !regLo._fixUpperEdge
                            && (eUp._Dst == this._event || eLo._Dst == this._event)) {
                            if (this.CheckForIntersect(regUp)) {
                                return;
                            }
                        }
                        else {
                            this.CheckForRightSplice(regUp);
                        }
                    }
                    if (eUp._Org == eLo._Org && eUp._Dst == eLo._Dst) {
                        Geom.AddWinding(eLo, eUp);
                        this.DeleteRegion(regUp);
                        this._mesh.Delete(eUp);
                        regUp = this.RegionAbove(regLo);
                    }
                }
            }
            ConnectRightVertex(regUp, eBottomLeft) {
                var eTopLeft = eBottomLeft._Onext;
                var regLo = this.RegionBelow(regUp);
                var eUp = regUp._eUp;
                var eLo = regLo._eUp;
                var degenerate = false;
                if (eUp._Dst != eLo._Dst) {
                    this.CheckForIntersect(regUp);
                }
                if (Geom.VertEq(eUp._Org, this._event)) {
                    this._mesh.Splice(eTopLeft._Oprev, eUp);
                    regUp = this.TopLeftRegion(regUp);
                    eTopLeft = this.RegionBelow(regUp)._eUp;
                    this.FinishLeftRegions(this.RegionBelow(regUp), regLo);
                    degenerate = true;
                }
                if (Geom.VertEq(eLo._Org, this._event)) {
                    this._mesh.Splice(eBottomLeft, eLo._Oprev);
                    eBottomLeft = this.FinishLeftRegions(regLo, null);
                    degenerate = true;
                }
                if (degenerate) {
                    this.AddRightEdges(regUp, eBottomLeft._Onext, eTopLeft, eTopLeft, true);
                    return;
                }
                var eNew;
                if (Geom.VertLeq(eLo._Org, eUp._Org)) {
                    eNew = eLo._Oprev;
                }
                else {
                    eNew = eUp;
                }
                eNew = this._mesh.Connect(eBottomLeft._Lprev, eNew);
                this.AddRightEdges(regUp, eNew, eNew._Onext, eNew._Onext, false);
                eNew._Sym._activeRegion._fixUpperEdge = true;
                this.WalkDirtyRegions(regUp);
            }
            ConnectLeftDegenerate(regUp, vEvent) {
                var e = regUp._eUp;
                if (Geom.VertEq(e._Org, vEvent)) {
                    throw ("Vertices should have been merged before");
                }
                if (!Geom.VertEq(e._Dst, vEvent)) {
                    this._mesh.SplitEdge(e._Sym);
                    if (regUp._fixUpperEdge) {
                        this._mesh.Delete(e._Onext);
                        regUp._fixUpperEdge = false;
                    }
                    this._mesh.Splice(vEvent._anEdge, e);
                    this.SweepEvent(vEvent);
                    return;
                }
                throw ("Vertices should have been merged before");
            }
            ConnectLeftVertex(vEvent) {
                var tmp = new ActiveRegion();
                tmp._eUp = vEvent._anEdge._Sym;
                var regUp = this._dict.Find(tmp).Key;
                var regLo = this.RegionBelow(regUp);
                if (regLo == null) {
                    return;
                }
                var eUp = regUp._eUp;
                var eLo = regLo._eUp;
                if (Geom.EdgeSign(eUp._Dst, vEvent, eUp._Org) == 0.0) {
                    this.ConnectLeftDegenerate(regUp, vEvent);
                    return;
                }
                var reg = Geom.VertLeq(eLo._Dst, eUp._Dst) ? regUp : regLo;
                if (regUp._inside || reg._fixUpperEdge) {
                    var eNew;
                    if (reg == regUp) {
                        eNew = this._mesh.Connect(vEvent._anEdge._Sym, eUp._Lnext);
                    }
                    else {
                        eNew = this._mesh.Connect(eLo._Dnext, vEvent._anEdge)._Sym;
                    }
                    if (reg._fixUpperEdge) {
                        this.FixUpperEdge(reg, eNew);
                    }
                    else {
                        this.ComputeWinding(this.AddRegionBelow(regUp, eNew));
                    }
                    this.SweepEvent(vEvent);
                }
                else {
                    this.AddRightEdges(regUp, vEvent._anEdge, vEvent._anEdge, null, true);
                }
            }
            SweepEvent(vEvent) {
                this._event = vEvent;
                var e = vEvent._anEdge;
                while (e._activeRegion == null) {
                    e = e._Onext;
                    if (e == vEvent._anEdge) {
                        this.ConnectLeftVertex(vEvent);
                        return;
                    }
                }
                var regUp = this.TopLeftRegion(e._activeRegion);
                var reg = this.RegionBelow(regUp);
                var eTopLeft = reg._eUp;
                var eBottomLeft = this.FinishLeftRegions(reg, null);
                if (eBottomLeft._Onext == eTopLeft) {
                    this.ConnectRightVertex(regUp, eBottomLeft);
                }
                else {
                    this.AddRightEdges(regUp, eBottomLeft._Onext, eTopLeft, eTopLeft, true);
                }
            }
            AddSentinel(smin, smax, t) {
                var e = this._mesh.MakeEdge();
                e._Org._s = smax;
                e._Org._t = t;
                e._Dst._s = smin;
                e._Dst._t = t;
                this._event = e._Dst;
                var reg = new ActiveRegion();
                reg._eUp = e;
                reg._windingNumber = 0;
                reg._inside = false;
                reg._fixUpperEdge = false;
                reg._sentinel = true;
                reg._dirty = false;
                reg._nodeUp = this._dict.Insert(reg);
            }
            InitEdgeDict() {
                this._dict = new Dict(this.EdgeLeq());
                this.AddSentinel(-this.SentinelCoord, this.SentinelCoord, -this.SentinelCoord);
                this.AddSentinel(-this.SentinelCoord, this.SentinelCoord, +this.SentinelCoord);
            }
            DoneEdgeDict() {
                var fixedEdges = 0;
                var reg;
                while ((reg = this._dict.Min().Key) != null) {
                    if (!reg._sentinel) {
                        Debug.Assert(reg._fixUpperEdge);
                        Debug.Assert(++fixedEdges == 1);
                    }
                    Debug.Assert(reg._windingNumber == 0);
                    this.DeleteRegion(reg);
                }
                this._dict = null;
            }
            RemoveDegenerateEdges() {
                var eHead = this._mesh._eHead;
                var e;
                var eNext;
                var eLnext;
                for (e = eHead._next; e != eHead; e = eNext) {
                    eNext = e._next;
                    eLnext = e._Lnext;
                    if (Geom.VertEq(e._Org, e._Dst) && e._Lnext._Lnext != e) {
                        this.SpliceMergeVertices(eLnext, e);
                        this._mesh.Delete(e);
                        e = eLnext;
                        eLnext = e._Lnext;
                    }
                    if (eLnext._Lnext == e) {
                        if (eLnext != e) {
                            if (eLnext == eNext || eLnext == eNext._Sym) {
                                eNext = eNext._next;
                            }
                            this._mesh.Delete(eLnext);
                        }
                        if (e == eNext || e == eNext._Sym) {
                            eNext = eNext._next;
                        }
                        this._mesh.Delete(e);
                    }
                }
            }
            InitPriorityQ() {
                var vHead = this._mesh._vHead;
                var v;
                var vertexCount = 0;
                for (v = vHead._next; v != vHead; v = v._next) {
                    vertexCount++;
                }
                vertexCount += 8;
                this._pq = new PriorityQueue(vertexCount, Geom.VertLeq);
                vHead = this._mesh._vHead;
                for (v = vHead._next; v != vHead; v = v._next) {
                    v._pqHandle = this._pq.Insert(v);
                    if (v._pqHandle._handle == PQHandle.Invalid) {
                        throw ("PQHandle should not be invalid");
                    }
                }
                this._pq.Init();
            }
            DonePriorityQ() {
                this._pq = null;
            }
            RemoveDegenerateFaces() {
                var f;
                var fNext;
                var e;
                for (f = this._mesh._fHead._next; f != this._mesh._fHead; f = fNext) {
                    fNext = f._next;
                    e = f._anEdge;
                    Debug.Assert(e._Lnext != e);
                    if (e._Lnext._Lnext == e) {
                        Geom.AddWinding(e._Onext, e);
                        this._mesh.Delete(e);
                    }
                }
            }
            ComputeInterior() {
                this.RemoveDegenerateEdges();
                this.InitPriorityQ();
                this.RemoveDegenerateFaces();
                this.InitEdgeDict();
                var v;
                var vNext;
                while ((v = this._pq.ExtractMin()) != null) {
                    while (true) {
                        vNext = this._pq.Minimum();
                        if (vNext == null || !Geom.VertEq(vNext, v)) {
                            break;
                        }
                        vNext = this._pq.ExtractMin();
                        this.SpliceMergeVertices(v._anEdge, vNext._anEdge);
                    }
                    this.SweepEvent(v);
                }
                this.DoneEdgeDict();
                this.DonePriorityQ();
                this.RemoveDegenerateFaces();
                this._mesh.Check();
            }
        }
        LibTess.Tess = Tess;
    })(LibTess = U1.LibTess || (U1.LibTess = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ViewBase {
            constructor() {
                this._workingPlane = U1.Plane.FromPointNormal(U1.Vector3.Zero, U1.Vector3.UnitZ);
                this._controlComponent = new Views.VcControlContainer(this);
                this._needZoomFit = false;
                this._afterUpdated = new U1.Event1();
                this._activeToolChanged = new U1.Event3();
                this._viewMode = ViewModes.None;
                this.IsInvalid = true;
                this.RenderingMode = Views.URenderingMode.Solid;
                this.ShowNavigater = true;
                this.CanPaning = true;
                this._oldw = 0;
                this._oldh = 0;
                this.ZomFitMinSize = 2;
                this.orbit_click = U1.Vector2.MinValue;
                this.picking_ray = new U1.Ray3();
                this._defaultTool = new Views.SelectionTool();
                this._pan_pos = U1.Vector2.Zero;
                this.CurMv = U1.Vector2.Zero;
                this.CurDn = U1.Vector2.Zero;
                this.CurUp = U1.Vector2.Zero;
                this.OldMv = U1.Vector2.Zero;
                this.OldDn = U1.Vector2.Zero;
                this.OldUp = U1.Vector2.Zero;
                this._onTouchStart = (ev) => this.OnTouchStart(ev);
                this._onTouchMove = (ev) => this.OnTouchMove(ev);
                this._onTouchEnd = (ev) => this.OnTouchEnd(ev);
                this._onMouseEnter = (ev) => this.OnMouseEnter(ev);
                this._onMouseLeave = (ev) => this.OnMouseLeave(ev);
                this._onMouseMove = (ev) => this.OnMouseMove(ev);
                this._onMouseUp = (ev) => this.OnMouseUp(ev);
                this._onMouseDown = (ev) => this.OnMouseDown(ev);
                this._onMouseWheel = (ev) => this.OnMouseWheel(ev);
                this._onDblClick = (ev) => this.OnDblClick(ev);
                this._isMouseDown = false;
                this._touchDown = false;
                this._touchDist = 0;
                this.panplane = new U1.Plane();
                document.addEventListener("keydown", (e_) => {
                    if (e_.ctrlKey) {
                        this.isCtrlDown = true;
                    }
                });
                document.addEventListener("keyup", (e_) => {
                    this.isCtrlDown = false;
                });
            }
            get Document() {
                return this.document;
            }
            set Document(value) {
                if (this.document == value)
                    return;
                if (this.document != null) {
                    this.document.Selection.SelectionChanged.Remove(this, this.OnSelectionChanged);
                }
                this.document = value;
                if (this.document != null) {
                    this.document.Selection.SelectionChanged.Add(this, this.OnSelectionChanged);
                }
            }
            get DocumentPresenter() {
                return this.documentPresenter;
            }
            set DocumentPresenter(value) {
                if (this.documentPresenter != null) {
                    this.documentPresenter.View = null;
                }
                this.documentPresenter = value;
                if (this.documentPresenter != null) {
                    this.documentPresenter.View = this;
                    this.documentPresenter.Document = this.Document;
                }
            }
            get Controls() {
                return this._controlComponent;
            }
            get Scene() {
                if (this._scene == null)
                    this._scene = this.CreateScene();
                return this._scene;
            }
            get Width() {
                if (this._board == null)
                    return 0;
                return this._board.clientWidth;
            }
            get Height() {
                if (this._board == null)
                    return 0;
                return this._board.clientHeight;
            }
            get Board() {
                return this._board;
            }
            set Board(value) {
                if (this._board == value)
                    return;
                this.DetachUIEventHandlers(this._board);
                this._board = value;
                this.AttachUIEventHandlers(this._board);
            }
            get WorkingPlane() {
                return this._workingPlane;
            }
            set WorkingPlane(value) {
                this._workingPlane.CopyFrom(value);
            }
            get ActiveControl() {
                return this.Controls.ActiveControl;
            }
            set ActiveControl(value) {
                if (this.Controls.ActiveControl == value)
                    return;
                this.Controls.ActiveControl = value;
                this.Invalidate();
            }
            Activate() {
                var _self = this;
                this._timerToken = setInterval(() => {
                    if (_self.IsInvalid || this._oldw !== this.Width || this._oldh !== this.Height) {
                        if (_self.Document != null && _self.Document.IsUndoRedo)
                            return;
                        _self.Update();
                        this._oldw = this.Width;
                        this._oldh = this.Height;
                    }
                }, 30);
                this.ActiveTool = this._defaultTool;
            }
            DeActive() {
                clearInterval(this._timerToken);
                this.ActiveTool = null;
            }
            Invalidate() {
                this.IsInvalid = true;
            }
            Update() {
                if (this.Width < 1 || this.Height < 1)
                    return;
                this.IsInvalid = false;
                this.OnBeginUpdate();
                if (this.DocumentPresenter != null) {
                    this.DocumentPresenter.Update();
                }
                if (this.Controls != null) {
                    this.Controls.Update();
                }
                this.Scene.Update();
                this.Scene.Draw();
                this.OnEndUpdate();
                if (this._needZoomFit) {
                    this.ZoomFit();
                }
                this.AfterUpdated.Invoke(this);
            }
            OnBeginUpdate() {
            }
            OnEndUpdate() {
            }
            ZoomFit(bbx) {
                var world = this.Scene.World;
                var overlay = this.Scene.Overlay;
                if (bbx == null) {
                    var box = world.BoundingBox;
                    var ovbox = this.Scene.Overlay.BoundingBox;
                    var a = box.Min.Clone().Transform(world.Transform);
                    var b = box.Max.Clone().Transform(world.Transform);
                    var min = U1.Vector3.Min(a, b);
                    var max = U1.Vector3.Max(a, b);
                    var minov = ovbox.Min.Clone().Transform(overlay.Transform);
                    var maxov = ovbox.Max.Clone().Transform(overlay.Transform);
                    if (!isNaN(minov.X) && !isNaN(maxov.X) && isFinite(minov.X) && isFinite(maxov.X)) {
                        min.SetMin(min, minov);
                        max.SetMax(max, maxov);
                    }
                }
                else {
                    min = bbx.Min;
                    max = bbx.Max;
                }
                if (min.Equals(U1.Vector3.MaxValue))
                    min = U1.Vector3.One.Scale(-this.ZomFitMinSize);
                if (max.Equals(U1.Vector3.MinValue))
                    max = U1.Vector3.One.Scale(this.ZomFitMinSize);
                if (!isFinite(min.X) || !isFinite(min.Y) || !isFinite(min.Z)) {
                    this._needZoomFit = true;
                    return;
                }
                this._needZoomFit = false;
                var cent = U1.Vector3.Add(min, max).Scale(0.5);
                var radius = U1.Vector3.Distance(min, max) / 2;
                radius = Math.max(this.ZomFitMinSize, radius);
                var orth_h = radius * 2;
                if (U1.Vector3.Dot(this.Scene.Camera.Up, U1.Vector3.UnitY) > 0.99) {
                    var rwh = this.Height / this.Width;
                    var oh = (max.Y - min.Y);
                    var ow = (max.X - min.X);
                    oh *= 1.1;
                    ow *= 1.1;
                    var sx = this.Width / ow;
                    var sy = this.Height / oh;
                    if (sx < sy) {
                        oh = oh * sy / sx;
                    }
                    orth_h = oh;
                }
                var dist = (radius * 2 / Math.tan(this.Scene.Camera.FOV));
                var lookAt = cent;
                var dir = U1.Vector3.Normalize(U1.Vector3.Subtract(this.Scene.Camera.Position, this.Scene.Camera.LookAt));
                var pos = U1.Vector3.ScaleAdd(cent, dist, dir);
                var up = this.Scene.Camera.Up;
                this.Scene.Camera.LookAt = lookAt;
                this.Scene.Camera.Position = pos;
                this.Scene.Camera.OrthoHeight = orth_h;
                this.Scene.Camera.Up = up;
                this.Invalidate();
            }
            HomeView(box) {
                if (box == null) {
                    box = this.DocumentPresenter.GetWorldBounding();
                }
                if (box == null) {
                    box = new U1.BoundingBox(new U1.Vector3(-10, -10, -10), new U1.Vector3(10, 10, 10));
                }
                var min = box.Min;
                var max = box.Max;
                if (min == U1.Vector3.MaxValue)
                    min = U1.Vector3.One.Scale(-10);
                if (max == U1.Vector3.MinValue)
                    max = U1.Vector3.One.Scale(10);
                var cent = U1.Vector3.Add(min, max).Scale(1 / 2);
                var radius = U1.Vector3.Distance(min, max) / 2;
                var dist = radius * 2 / Math.tan(this.Scene.Camera.FOV);
                var lookAt = cent;
                var pos = U1.Vector3.ScaleAdd(cent, dist, new U1.Vector3(0, -1, 1));
                var up = U1.Vector3.Normalize(new U1.Vector3(0, 1, 1));
                this.Scene.Camera.LookAt = lookAt;
                this.Scene.Camera.Position = pos;
                this.Scene.Camera.OrthoHeight = radius * 2 * 1.2;
                this.Scene.Camera.Up = up;
                if (this.PivotPoint == null) {
                    this.PivotPoint = cent;
                }
                this.Invalidate();
            }
            ZoomView(focus, delt, min, max) {
                var _a;
                var tv0 = ViewBase.tmp_v30;
                min = min !== null && min !== void 0 ? min : -0.3;
                max = max !== null && max !== void 0 ? max : 0.3;
                try {
                    delt *= 0.02;
                    delt = Math.min(max, delt);
                    delt = Math.max(min, delt);
                    var camera = this.Scene.Camera;
                    if (camera.ProjectionMode == U1.ProjectionTypeEnum.Perspective) {
                        var dir = ViewBase.tmp_v31.SetZero();
                        var ray = this.GetRay(focus);
                        dir = (_a = ray === null || ray === void 0 ? void 0 : ray.Direction) !== null && _a !== void 0 ? _a : camera.GetDirection(dir);
                        var isect;
                        if ((isect = this.PickOrbitPoint(focus)) != null) {
                            var dir = U1.Vector3.Subtract(isect.IsectPosition, camera.Position);
                            var len = Math.max(5, dir.Length() * 0.2);
                            dir.Normalize();
                            dir.Scale(len);
                        }
                        else {
                            dir.Normalize();
                            dir.Scale(50);
                        }
                        camera.Move(dir.Scale(delt));
                    }
                    else {
                        var p0 = ViewBase.tmp_v30;
                        var p1 = ViewBase.tmp_v31;
                        var v1 = ViewBase.tmp_v32;
                        camera.ScreenToPlane(focus, this._workingPlane, p0);
                        var orthHeight = camera.OrthoHeight - (delt * camera.OrthoHeight);
                        if (orthHeight >= 0.1) {
                            camera.OrthoHeight = orthHeight;
                        }
                        camera.ScreenToPlane(focus, this._workingPlane, p1);
                        v1.SetSubtract(p0, p1);
                        camera.Move(v1);
                    }
                    this.Invalidate();
                }
                catch (err) {
                    U1.LogService.WriteException(err);
                }
            }
            ScaleView(focus, scale) {
                var tv0 = ViewBase.tmp_v30;
                if (scale <= 0)
                    return;
                try {
                    var camera = this.Scene.Camera;
                    if (camera.ProjectionMode == U1.ProjectionTypeEnum.Perspective) {
                        var dir = ViewBase.tmp_v31.SetZero();
                        camera.GetDirection(dir);
                        camera.ScreenToPlane(new U1.Vector2(this.Width / 2, this.Height / 2), this._workingPlane, tv0);
                        if (tv0 != null) {
                            var len = U1.Vector3.Distance(tv0, camera.Position);
                            camera.Move(dir.Scale(len * scale));
                        }
                        else {
                            dir.Scale(scale);
                            camera.Move(dir);
                        }
                    }
                    else {
                        var p0 = ViewBase.tmp_v30;
                        var p1 = ViewBase.tmp_v31;
                        var v1 = ViewBase.tmp_v32;
                        camera.ScreenToPlane(focus, this._workingPlane, p0);
                        var orthHeight = (1 / scale * camera.OrthoHeight);
                        if (orthHeight >= 0.1) {
                            camera.OrthoHeight = orthHeight;
                        }
                        camera.ScreenToPlane(focus, this._workingPlane, p1);
                        v1.SetSubtract(p0, p1);
                        camera.Move(v1);
                    }
                    this.Invalidate();
                }
                catch (err) {
                    U1.LogService.WriteException(err);
                }
            }
            PanPlane(plane, sp0, sp1) {
                try {
                    var cent = this.Scene.Camera.LookAt;
                    var p0 = ViewBase.tmp_v30;
                    var p1 = ViewBase.tmp_v31;
                    var v0 = ViewBase.tmp_v32;
                    this.Scene.Camera.ScreenToPlane(sp0, plane, p0);
                    this.Scene.Camera.ScreenToPlane(sp1, plane, p1);
                    if (p0 != null && p1 != null) {
                        v0.SetSubtract(p0, p1);
                        if (v0.X != 0 || v0.Y != 0) {
                            this.Scene.Camera.Move(v0);
                        }
                    }
                    this.Invalidate();
                }
                catch (err) {
                    U1.LogService.WriteException(err);
                }
            }
            Pan(sp0, sp1) {
                var _a;
                this.UpdatePanPlane();
                let plane = (_a = this.panplane) !== null && _a !== void 0 ? _a : this.WorkingPlane;
                this.PanPlane(plane, sp0, sp1);
                this.Invalidate();
            }
            WorldToView(wp) {
                return this.Scene.Camera.WorldToScreen(wp);
            }
            WorldToScene2D(world) {
                var _a;
                var v = (_a = this.WorldToView(world)) !== null && _a !== void 0 ? _a : new U1.Vector3(-100, -100, 0);
                var cent_x = this.Width / 2;
                var cent_y = this.Height / 2;
                return new U1.Vector2(v.X - cent_x, -(v.Y - cent_y));
            }
            PickOrbitPoint(view) {
                var isectInfo = null;
                var ray = this.GetRay(view);
                var isectContext = new U1.ISectContext(view, ray, Number.MAX_VALUE);
                isectContext.WorldToScreenFunc = (wp) => {
                    return this.WorldToView(wp);
                };
                isectContext.PickingOrbitPoint = true;
                var isectPresenter = null;
                ;
                var pickResult = this.DocumentPresenter.Pick(isectContext);
                isectPresenter = pickResult === null || pickResult === void 0 ? void 0 : pickResult.Presenter;
                isectInfo = pickResult === null || pickResult === void 0 ? void 0 : pickResult.ISect;
                if (isectPresenter != null && isectPresenter.IsDisposed) {
                    isectPresenter = null;
                }
                return isectInfo;
            }
            UpdatePanPlane() {
                var curp = this.CurDn;
                if (!U1.Vector2.EpsilonEquals(this.orbit_click, curp, 0.1)) {
                    this.orbit_click = curp.Clone();
                    var isect;
                    if ((isect = this.PickOrbitPoint(curp)) != null) {
                        this.PivotPoint = isect.IsectPosition;
                    }
                    else if (this.PivotPoint == null) {
                        var bbx = this.DocumentPresenter.GetWorldBounding();
                        if (bbx.Min.X < bbx.Max.X) {
                            var cent = U1.Vector3.Add(bbx.Min, bbx.Max).Scale(0.5);
                            var sp = this.WorldToScene2D(cent);
                            if (sp.X >= 0 && sp.Y >= 0 && sp.X <= this.Width && sp.Y <= this.Height) {
                                this.PivotPoint = cent;
                            }
                        }
                    }
                }
                var pos = this.Scene.Camera.Position;
                var norm = this.Scene.Camera.GetDirection();
                var dist = 10.0;
                if (this.PivotPoint != null) {
                    dist = U1.Vector3.Dot(U1.Vector3.Subtract(this.PivotPoint, pos), norm);
                }
                else {
                    let isect = U1.Vector3.Zero;
                    this.WorkingPlane.IntersectsLine(pos, norm, isect);
                    if (isect != null)
                        dist = U1.Vector3.Dot(U1.Vector3.Subtract(isect, pos), norm);
                }
                dist = Math.min(1000, Math.max(10, dist));
                pos = U1.Vector3.ScaleAdd(pos, dist, norm);
                this.panplane.SetFromPointNormal(pos, norm);
            }
            GetClippingCorners(p1, p2) {
                var min = U1.Vector2.Min(p1, p2);
                var max = U1.Vector2.Max(p1, p2);
                var r1 = this.GetRay(min);
                var r2 = this.GetRay(new U1.Vector2(min.X, max.Y));
                var r3 = this.GetRay(new U1.Vector2(max.X, max.Y));
                var r4 = this.GetRay(new U1.Vector2(max.X, min.Y));
                var v1 = r1.Position;
                var v2 = U1.Vector3.Add(r1.Position, r1.Direction);
                var v3 = r2.Position;
                var v4 = U1.Vector3.Add(r2.Position, r2.Direction);
                var v5 = r3.Position;
                var v6 = U1.Vector3.Add(r3.Position, r3.Direction);
                var v7 = r4.Position;
                var v8 = U1.Vector3.Add(r4.Position, r4.Direction);
                return [v1, v2, v3, v4, v5, v6, v7, v8];
            }
            GetRay(screen, result = null) {
                if (result == null)
                    result = new U1.Ray3();
                return this.Scene.Camera.CalPickingRay(screen.X, screen.Y, result);
            }
            Pick(screen_pos) {
                var picking_ray = this.picking_ray;
                picking_ray.Position.Set(screen_pos.X, screen_pos.Y, 1000);
                picking_ray.Direction.Set(0, 0, -1);
                var isectContext = new U1.ISectContext(screen_pos, picking_ray, Number.MAX_VALUE);
                isectContext.WorldToScreenFunc =
                    (wpos, result) => {
                        if (result == null)
                            result = new U1.Vector3();
                        this.Scene.Camera.WorldToScreen(wpos, result);
                        return result;
                    };
                isectContext.IsScreenSpace = true;
                var isect = this.Scene.Screen.Pick(isectContext);
                if (isect == null || isect.ISect == null) {
                    this.GetRay(screen_pos, picking_ray);
                    isectContext.Ray = picking_ray;
                    isectContext.WorldToScreen =
                        (wpos, result) => {
                            if (result == null)
                                result = new U1.Vector3();
                            this.Scene.Camera.WorldToScreen(wpos, result);
                            return result;
                        };
                    isectContext.IsScreenSpace = false;
                    isect = this.Controls.Pick(isectContext);
                    if (isect == null || isect.ISect == null)
                        isect = this.DocumentPresenter.Pick(isectContext);
                }
                return isect;
            }
            SelectRegion(lt, rb, allowCross = false) {
                return this.DocumentPresenter.SelectRegion(lt, rb, allowCross);
            }
            get DefaultTool() {
                return this._defaultTool;
            }
            set DefaultTool(value) {
                if (this._defaultTool == value)
                    return;
                this._defaultTool = value;
            }
            get ActiveTool() {
                return this._activeTool;
            }
            set ActiveTool(value) {
                let old = this._activeTool;
                if (this._activeTool != null) {
                    this._activeTool.OnDetach(this);
                    delete this._activeTool.View;
                }
                this._activeTool = value;
                if (this._activeTool == null) {
                    this._activeTool = this._defaultTool;
                }
                if (this._activeTool != null) {
                    this._activeTool.View = this;
                    this._activeTool.OnAttach(this);
                }
                this.Invalidate();
                this.ActiveToolChanged.Invoke(this, old, this._activeTool);
            }
            get AfterUpdated() {
                return this._afterUpdated;
            }
            get ActiveToolChanged() {
                return this._activeToolChanged;
            }
            get Mode() {
                return this._viewMode;
            }
            set Mode(value) {
                this._viewMode = value;
            }
            AttachUIEventHandlers(board) {
                if (board != null) {
                    board.addEventListener("mousemove", this._onMouseMove);
                    board.addEventListener("mousedown", this._onMouseDown);
                    board.addEventListener("mouseup", this._onMouseUp);
                    board.addEventListener("mouseenter", this._onMouseEnter);
                    board.addEventListener("mouseleave", this._onMouseLeave);
                    board.addEventListener("dblclick", this._onDblClick);
                    var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
                    board.addEventListener(mousewheelevt, this._onMouseWheel);
                    board.addEventListener("touchstart", this._onTouchStart);
                    board.addEventListener("touchmove", this._onTouchMove);
                    board.addEventListener("touchend", this._onTouchEnd);
                }
            }
            DetachUIEventHandlers(board) {
                if (board != null) {
                    board.removeEventListener("mousemove", this._onMouseMove);
                    board.removeEventListener("mousedown", this._onMouseDown);
                    board.removeEventListener("mouseup", this._onMouseUp);
                    board.removeEventListener("mouseenter", this._onMouseEnter);
                    board.removeEventListener("mouseleave", this._onMouseLeave);
                    board.removeEventListener("dblclick", this._onDblClick);
                    var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
                    board.removeEventListener(mousewheelevt, this._onMouseWheel);
                    board.removeEventListener("touchstart", this._onTouchStart);
                    board.removeEventListener("touchmove", this._onTouchMove);
                    board.removeEventListener("touchend", this._onTouchEnd);
                }
            }
            get IsMouseDown() {
                return this._isMouseDown;
            }
            OnMouseEnter(ev) {
                this._isMouseDragging = false;
                this._isMouseDown = false;
                this.OldDn.Set(-1, -1);
                this.CurDn.Set(-1, -1);
                if (this.ActiveControl != null && this.ActiveControl.OnMouseEnter(ev)) {
                }
                else if (this.ActiveTool != null && this.ActiveTool.OnMouseEnter(ev)) {
                }
                else if (this.OnDefaultMouseEnter(ev)) {
                }
                else {
                }
            }
            OnMouseLeave(ev) {
                this._isMouseDragging = false;
                this._isMouseDown = false;
                this.HideSelectionBox();
                if (this.ActiveControl != null && this.ActiveControl.OnMouseLeave(ev)) {
                }
                else if (this.ActiveTool != null && this.ActiveTool.OnMouseLeave(ev)) {
                }
                else if (this.OnDefaultMouseLeave(ev)) {
                }
                else {
                }
            }
            OnMouseMove(ev) {
                if (ev.srcElement instanceof HTMLInputElement) {
                    return;
                }
                ev.preventDefault();
                this.OldMv.CopyFrom(this.CurMv);
                this.CurMv.Set(ev.offsetX, ev.offsetY);
                if (!this._isMouseDragging && U1.Vector2.Distance(this.CurMv, this.CurDn) > 4) {
                    if (this._isMouseDown) {
                        this._isMouseDragging = true;
                        this.OldMv.CopyFrom(this.CurMv);
                    }
                }
                if (this.ActiveControl != null && this.ActiveControl.OnMouseMove(ev)) {
                }
                else if (this.ActiveTool != null && this.ActiveTool.OnMouseMove(ev)) {
                }
                else if (this.OnDefaultMouseMove(ev)) {
                }
                else {
                }
            }
            OnMouseUp(ev) {
                this._isMouseDragging = false;
                if (ev.srcElement instanceof HTMLInputElement) {
                    return;
                }
                ev.preventDefault();
                this._isMouseDown = false;
                this.OldUp.CopyFrom(this.CurUp);
                this.CurUp.Set(ev.offsetX, ev.offsetY);
                this.CurMv.CopyFrom(this.CurUp);
                this.OldMv.CopyFrom(this.CurUp);
                if (this.ActiveControl != null
                    && this.ActiveControl.OnMouseUp(ev)) {
                }
                else if (this.ActiveTool != null && this.ActiveTool.OnMouseUp(ev)) {
                }
                else if (this.OnDefaultMouseUp(ev)) {
                }
                else {
                }
                this.OldUp.CopyFrom(this.CurUp);
            }
            OnMouseDown(ev) {
                this._isMouseDragging = false;
                if (ev.srcElement instanceof HTMLInputElement) {
                    return;
                }
                ev.preventDefault();
                this._isMouseDown = true;
                this.OldDn.CopyFrom(this.CurDn);
                this.CurDn.Set(ev.offsetX, ev.offsetY);
                this.CurMv.CopyFrom(this.CurDn);
                this.OldMv.CopyFrom(this.CurDn);
                if (this.ActiveControl != null && this.ActiveControl.OnMouseDown(ev)) {
                    return;
                }
                if (this.ActiveTool != null && this.ActiveTool.OnMouseDown(ev)) {
                }
                else if (this.OnDefaultMouseDown(ev)) {
                }
                else {
                }
                this.OldDn.CopyFrom(this.CurDn);
            }
            OnMouseWheel(ev) {
                if (ev.srcElement instanceof HTMLInputElement) {
                    return;
                }
                this.OldMv.CopyFrom(this.CurMv);
                this.CurMv.Set(ev.offsetX, ev.offsetY);
                if (this.ActiveControl != null
                    && this.ActiveControl.OnMouseWheel(ev)) {
                }
                else if (this.ActiveTool != null
                    && this.ActiveTool.OnMouseWheel(ev)) {
                }
                else if (this.OnDefaultMouseWheel(ev)) {
                }
                else {
                }
            }
            OnDblClick(ev) {
            }
            getTouchCenter(te) {
                var tc0 = te.touches[0];
                var tc1 = te.touches[1];
                if (tc0 == null)
                    return null;
                var cent = new U1.Vector2(tc0.clientX, tc0.clientY);
                if (tc1 != null) {
                    cent.X += tc0.clientX;
                    cent.Y += tc1.clientY;
                    cent.X /= 2;
                    cent.Y /= 2;
                }
                var rect = this.Board.getBoundingClientRect();
                cent.X -= rect.x;
                cent.Y -= rect.y;
                return cent;
            }
            getTouchDist(te) {
                if (te.touches.length != 2)
                    return 0;
                let tc0 = te.touches[0];
                let tc1 = te.touches[1];
                let dist = new U1.Vector2(tc0.clientX - tc1.clientX, tc0.clientY - tc1.clientY)
                    .Length();
                return dist;
            }
            OnTouchStart(te) {
                var _a, _b;
                this.OldMv = (_a = this.CurMv) === null || _a === void 0 ? void 0 : _a.Clone();
                this.OldDn = (_b = this.CurDn) === null || _b === void 0 ? void 0 : _b.Clone();
                this._touchDown = true;
                if (te.touches.length > 0) {
                    var cent = this.getTouchCenter(te);
                    this.CurMv.Set(cent.X, cent.Y);
                    this.CurDn.Set(cent.X, cent.Y);
                    if (te.touches.length > 1) {
                        this._touchDist = this.getTouchDist(te);
                    }
                    this.UpdatePanPlane();
                }
                if (this.ActiveControl != null
                    && this.ActiveControl.OnTouchStart(te)) {
                }
                else if (this.ActiveTool != null && this.ActiveTool.OnTouchStart(te)) {
                }
                else {
                }
                this.Invalidate();
            }
            OnTouchMove(ev) {
                if (ev.srcElement instanceof HTMLInputElement) {
                    return;
                }
                this.OldMv.CopyFrom(this.CurMv);
                if (ev.changedTouches.length > 0) {
                    var cent = this.getTouchCenter(ev);
                    this.CurMv.Set(cent.X, cent.Y);
                    this.CurDn.Set(cent.X, cent.Y);
                    this.Mode = ViewModes.Paning;
                    this.CurMv.Set(cent.X, cent.Y);
                    if (ev.touches.length == 1) {
                        if (U1.Vector2.Distance(this.OldMv, this.CurMv) < 100) {
                            var delt = U1.Vector2.Subtract(this.CurMv, this.OldMv);
                            this.Orbit(delt);
                        }
                    }
                    else if (ev.touches.length == 2) {
                        let prevDist = this._touchDist;
                        this._touchDist = this.getTouchDist(ev);
                        ev.preventDefault();
                        if (U1.Vector2.Distance(this.OldMv, this.CurMv) < 100) {
                            var delt = U1.Vector2.Subtract(this.CurMv, this.OldMv);
                            this.Pan(this.OldMv, this.CurMv);
                        }
                        this.ZoomView(cent, (this._touchDist - prevDist) / 3);
                    }
                }
                if (this.ActiveControl != null
                    && this.ActiveControl.OnTouchMove(ev)) {
                }
                else if (this.ActiveTool != null && this.ActiveTool.OnTouchMove(ev)) {
                    return true;
                }
                else {
                }
                this.Invalidate();
            }
            OnTouchEnd(te) {
                this._touchDown = false;
                this.Mode = ViewModes.None;
                this.OldMv.CopyFrom(this.CurMv);
                this.OldUp.CopyFrom(this.CurUp);
                if (te.touches.length > 0) {
                    var tc = te.touches[0];
                    this.CurMv.Set(tc.clientX, tc.clientY);
                    this.OldUp.CopyFrom(this.CurMv);
                }
                if (this.ActiveControl != null
                    && this.ActiveControl.OnTouchEnd(te)) {
                }
                else if (this.ActiveTool != null && this.ActiveTool.OnTouchEnd(te)) {
                    return true;
                }
                else {
                }
                this.Invalidate();
            }
            OnSelectionChanged(sel) {
            }
            CreateScene() {
                return new Views.Scene(this);
            }
            OnDefaultMouseEnter(ev) {
                return false;
            }
            OnDefaultMouseLeave(ev) {
                return false;
            }
            OnDefaultMouseMove(ev) {
                var delt = U1.Vector2.Subtract(this.CurMv, this.OldMv);
                if (U1.IsMiddleMouseDrag(ev) && this._isMouseDragging) {
                    if (ev.ctrlKey) {
                    }
                    else if (ev.shiftKey) {
                        this.Mode = ViewModes.Orbitting;
                        this.Orbit(delt);
                    }
                    else {
                        if (this.CanPaning) {
                            this.Mode = ViewModes.Paning;
                            this.Pan(this.OldMv, this.CurMv);
                            this.Invalidate();
                        }
                    }
                    return true;
                }
                else if (U1.IsRightMouseDrag(ev) && this._isMouseDragging) {
                    this.Mode = ViewModes.Orbitting;
                }
                else {
                    this.Mode = ViewModes.None;
                }
                return false;
            }
            OnDefaultMouseUp(ev) {
                return false;
            }
            OnDefaultMouseDown(ev) {
                return false;
            }
            OnDefaultMouseWheel(ev) {
                return false;
            }
            OnDefaultPress(ev) {
                return false;
            }
            OnDefaultPanMove(ev) {
                return false;
            }
            Orbit(delt) {
                var _a;
                try {
                    var tv20 = ViewBase[".orb.v20"] || (ViewBase[".orb.v20"] = new U1.Vector2());
                    var tv21 = ViewBase[".orb.v21"] || (ViewBase[".orb.v21"] = new U1.Vector2());
                    var tv30 = ViewBase[".orb.v30"] || (ViewBase[".orb.v30"] = new U1.Vector3());
                    var tv31 = ViewBase[".orb.v31"] || (ViewBase[".orb.v31"] = new U1.Vector3());
                    var tv32 = ViewBase[".orb.v32"] || (ViewBase[".orb.v32"] = new U1.Vector3());
                    var tv33 = ViewBase[".orb.v33"] || (ViewBase[".orb.v33"] = new U1.Vector3());
                    var camera = this.Scene.Camera;
                    this.UpdatePanPlane();
                    var _rotatefeeling = 0.01;
                    delt = tv20.SetScale(delt, _rotatefeeling);
                    var len = delt.Length();
                    var up = tv30.SetNormalize(camera.Up);
                    var scent = tv21.Set(this.Width / 2, this.Height / 2);
                    var epos = (_a = this.PivotPoint) !== null && _a !== void 0 ? _a : camera.ScreenToPlane(scent, this.panplane, tv31);
                    var sel_bbx = this.DocumentPresenter.GetWorldBoundingSelection();
                    if (sel_bbx != null) {
                        epos = tv32.SetAdd(sel_bbx.Min, sel_bbx.Max).Scale(1 / 2);
                    }
                    if (epos != null) {
                        var rt = camera.GetRight(tv33).Normalize();
                        if (Math.abs(delt.X) > Math.abs(delt.Y)) {
                            this.RotateView(epos, U1.Vector3.UnitZ, -delt.X);
                        }
                        else {
                            this.RotateView(epos, rt, -delt.Y);
                        }
                    }
                    this.Invalidate();
                }
                catch (ex) {
                    U1.LogService.WriteException(ex);
                }
            }
            RotateView(epos, axis, p) {
                try {
                    if (this.Document == null)
                        return;
                    var cam = this.Scene.Camera;
                    cam.Rotate(epos, axis, p);
                    this.Invalidate();
                }
                catch (ex) {
                    U1.LogService.WriteException(ex);
                }
            }
            newControlInstance(ctor) {
                return new ctor();
            }
            DrawSelectionBox(dn, mv, p, color) {
            }
            HideSelectionBox() {
            }
            ShowSelectionBox() {
            }
            ViewToPlane(screen, plane, result) {
                return this.Scene.Camera.ScreenToPlane(screen, plane, result);
            }
            ScreenToWorkingPlane(screen, result) {
                return this.Scene.Camera.ScreenToPlane(screen, this.WorkingPlane, result);
            }
        }
        ViewBase.tmp_v20 = U1.Vector2.Zero;
        ViewBase.tmp_v21 = U1.Vector2.Zero;
        ViewBase.tmp_v22 = U1.Vector2.Zero;
        ViewBase.tmp_v23 = U1.Vector2.Zero;
        ViewBase.tmp_v30 = U1.Vector3.Zero;
        ViewBase.tmp_v31 = U1.Vector3.Zero;
        ViewBase.tmp_v32 = U1.Vector3.Zero;
        ViewBase.tmp_v33 = U1.Vector3.Zero;
        Views.ViewBase = ViewBase;
        let ViewModes;
        (function (ViewModes) {
            ViewModes[ViewModes["None"] = 0] = "None";
            ViewModes[ViewModes["CaptureMouse"] = 1] = "CaptureMouse";
            ViewModes[ViewModes["Selecting"] = 2] = "Selecting";
            ViewModes[ViewModes["Paning"] = 3] = "Paning";
            ViewModes[ViewModes["Zooming"] = 4] = "Zooming";
            ViewModes[ViewModes["Orbitting"] = 5] = "Orbitting";
            ViewModes[ViewModes["Moving"] = 6] = "Moving";
            ViewModes[ViewModes["Rotating"] = 7] = "Rotating";
            ViewModes[ViewModes["Scaling"] = 8] = "Scaling";
        })(ViewModes = Views.ViewModes || (Views.ViewModes = {}));
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class VcTool {
            get View() {
                return this._view;
            }
            set View(value) {
                this._view = value;
            }
            get Document() {
                return this._view != null ? this._view.Document : null;
            }
            OnAttach(view) {
            }
            OnDetach(view) {
            }
            OnMouseMove(ev) {
                return false;
            }
            OnMouseUp(ev) {
                return false;
            }
            OnMouseDown(ev) {
                return false;
            }
            OnMouseWheel(ev) {
                return false;
            }
            OnMouseEnter(ev) {
                return false;
            }
            OnMouseLeave(ev) {
                return false;
            }
            OnPress(ev) {
                return false;
            }
            OnPanMove(ev) {
                return false;
            }
            OnPanStart(ev) {
                return false;
            }
            OnPanEnd(ev) {
                return false;
            }
            OnPinch(ev) {
                return false;
            }
            OnTouchStart(ev) {
                return false;
            }
            OnTouchMove(ev) {
                return false;
            }
            OnTouchEnd(ev) {
                return false;
            }
            GetOptions() {
                return [];
            }
        }
        Views.VcTool = VcTool;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class SelectionTool extends Views.VcTool {
            constructor() {
                super(...arguments);
                this.m_mode = SelectionTool.Modes.None;
            }
            get Mode() {
                return this.m_mode;
            }
            set Mode(value) {
                if (this.m_mode == value)
                    return;
                this.m_mode = value;
            }
            OnAttach(view) {
            }
            OnDetach(view) {
                if (this.Mode == SelectionTool.Modes.Move) {
                    if (this.View != null)
                        this.View.DocumentPresenter.CancelMove();
                    else {
                        var i = 0;
                    }
                }
                this.Mode = SelectionTool.Modes.None;
                this.HideSelectionBox();
                super.OnDetach(view);
            }
            ShowSelectionBox() {
                this.View.ShowSelectionBox();
            }
            UpdateSelectionBox() {
                var s_;
                s_ = SelectionTool[".usb."] || (SelectionTool[".usb."] = s_ =
                    {
                        blue: U1.Colors.Blue,
                        green: U1.Colors.Green
                    });
                var dn = this.View.OldDn;
                var mv = this.View.CurMv;
                var color = s_.blue;
                if (this.View.OldDn.X < this.View.CurMv.X) {
                }
                else {
                    color = s_.green;
                }
                this.View.DrawSelectionBox(dn, mv, 1, color);
            }
            HideSelectionBox() {
                this.View.HideSelectionBox();
            }
            OnMouseDown(ev) {
                super.OnMouseDown(ev);
                if (U1.IsLeftMouseDown(ev)) {
                    var isect = this.View.Pick(this.View.CurDn);
                    if (isect != null) {
                        var control = isect.Control;
                        var elmPresenter = isect.Presenter;
                        if (control != null) {
                            if (control.OnMouseDown(ev))
                                return true;
                        }
                        else if (elmPresenter instanceof Views.UElementPresenter3D) {
                            if (elmPresenter.OnMouseDown(ev))
                                return true;
                            if (elmPresenter.IsSelected) {
                                this.PrepareMove();
                                return true;
                            }
                        }
                    }
                    else {
                        return true;
                    }
                }
                return false;
            }
            PrepareMove() {
                this.Mode = SelectionTool.Modes.PrepareMove;
                this.View.DocumentPresenter.StartMove();
            }
            OnMouseMove(e) {
                if (U1.IsMiddleMouseDrag(e))
                    return false;
                var View = this.View;
                if (this.Mode === SelectionTool.Modes.Move) {
                    var p0 = View.ScreenToWorkingPlane(new U1.Vector3(View.CurDn)) || U1.Vector3.Zero;
                    var p1 = View.ScreenToWorkingPlane(new U1.Vector3(View.CurMv)) || U1.Vector3.Zero;
                    if (U1.IsLeftMouseDrag(e)) {
                        View.DocumentPresenter.Move(p0, p1);
                    }
                    else {
                        View.DocumentPresenter.EndMove(p0, p1);
                        this.Mode = SelectionTool.Modes.None;
                    }
                    return true;
                }
                var dist = U1.Vector2.Distance(View.OldDn, View.CurMv);
                if (U1.IsLeftMouseDrag(e) && this.Mode == SelectionTool.Modes.PrepareMove && dist > 4) {
                    this.Mode = SelectionTool.Modes.Move;
                    return true;
                }
                if (!U1.IsLeftMouseDrag(e)) {
                    this.HideSelectionBox();
                    return false;
                }
                if (View.OldDn.Length() > 4
                    && View.IsMouseDown
                    && dist > 4
                    && !this.m_isRegionSelecting) {
                    this.ShowSelectionBox();
                    this.m_isRegionSelecting = true;
                }
                if (this.m_isRegionSelecting)
                    this.UpdateSelectionBox();
                return true;
            }
            OnMouseUp(ev) {
                if (!U1.IsLeftMouseUp(ev)) {
                    this.m_isRegionSelecting = false;
                    return false;
                }
                var Modes = SelectionTool.Modes;
                var View = this.View;
                if (this.Mode == Modes.PrepareMove) {
                    this.Mode = Modes.None;
                    this.m_isRegionSelecting = false;
                    return true;
                }
                if (this.Mode == Modes.Move) {
                    var p0 = View.ScreenToWorkingPlane(new U1.Vector3(View.CurDn)) || U1.Vector3.Zero;
                    var p1 = View.ScreenToWorkingPlane(new U1.Vector3(View.CurUp)) || U1.Vector3.Zero;
                    View.DocumentPresenter.EndMove(p0, p1);
                    this.Mode = Modes.None;
                    this.m_isRegionSelecting = false;
                    return true;
                }
                var pkResult = View.Pick(View.CurUp);
                var control = pkResult === null || pkResult === void 0 ? void 0 : pkResult.Control;
                var presenter = pkResult === null || pkResult === void 0 ? void 0 : pkResult.Presenter;
                var Doc = this.Document;
                var Sel = Doc.Selection;
                if (this.m_isRegionSelecting) {
                    this.HideSelectionBox();
                    this.m_isRegionSelecting = false;
                    var selection = View.SelectRegion(View.OldDn, View.CurUp, View.CurUp.X < View.OldDn.X);
                    if (selection.length == 0 && presenter != null)
                        selection.push(presenter);
                    var isControlDown = ev.ctrlKey;
                    if (isControlDown) {
                        var old_items = selection
                            .map(o_ => o_.Element)
                            .filter(o_ => Sel.Contains(o_));
                        var new_items = selection
                            .map(o_ => o_.Element)
                            .filter(o_ => !Sel.Contains(o_));
                        Sel.RemoveRange(old_items);
                        Sel.AddRange(new_items);
                    }
                    else {
                        Doc.Selection.AddRange(selection.map(o_ => o_.Element), true);
                    }
                    return true;
                }
                if (presenter != null) {
                    var isControlDown = ev.ctrlKey;
                    var items = [presenter.Element];
                    if (this.CustomAddSelectionFunc == null || !this.CustomAddSelectionFunc(items, !isControlDown)) {
                        if (isControlDown) {
                            var old_items = items
                                .filter(o_ => Doc.Selection.Contains(o_));
                            var new_items = items
                                .filter(o_ => !Doc.Selection.Contains(o_));
                            Doc.Selection.RemoveRange(old_items);
                            Doc.Selection.AddRange(new_items);
                        }
                        else {
                            Doc.Selection.AddRange(items, true);
                        }
                    }
                }
                else {
                    var isClear = !ev.ctrlKey;
                    if (isClear) {
                        if (this.CustomClearSelectionFunc == null || !this.CustomClearSelectionFunc())
                            Doc.Selection.Clear();
                    }
                }
                return true;
            }
            OnMouseWheel(ev) {
                var delta = ev.wheelDelta ? ev.wheelDelta : -ev.detail;
                this.View.ZoomView(this.View.CurMv, delta);
                return true;
            }
            OnMouseLeave(e) {
                this.m_isRegionSelecting = false;
                return super.OnMouseLeave(e);
            }
            OnMouseEnter(e) {
                this.m_isRegionSelecting = false;
                return super.OnMouseEnter(e);
            }
        }
        SelectionTool.Modes = {
            None: 0,
            Select: 1,
            Drag: 2,
            PrepareMove: 3,
            Move: 4
        };
        Views.SelectionTool = SelectionTool;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiBase {
            constructor() {
                this.old_display = "";
                this.old_pointerEvents = "";
                this.IsEnable = true;
                this.IsVisible = true;
            }
            get Old_display() {
                return this.old_display;
            }
            set Old_display(value) {
                this.old_display = value;
            }
            Pause() {
                this.IsPasued = true;
                return this;
            }
            Resume() {
                this.IsPasued = false;
                this.Update();
                return this;
            }
            UnBind() {
                if (this.Source != null)
                    this.Source.PropertyChanged.Remove(this, this.OnPropertyChanged);
                return this;
            }
            Update() {
                this.isUpdating = true;
                this.OnUpdate();
                this.isUpdating = false;
                return this;
            }
            OnUpdate() {
                if (this.Source != null) {
                    if (this.IsEnabledSource != null) {
                        this.setIsEnable(this.Source[this.IsEnabledSource]);
                    }
                    else if (this.IsVisibleSource != null) {
                        this.setIsVisible(this.Source[this.IsVisibleSource]);
                    }
                }
            }
            setSource(source) {
                this.Source = source;
                if (this.Source != null) {
                    this.Source.PropertyChanged.Add(this, this.CallOnPropertyChanged);
                }
                return this;
            }
            setTarget(target) {
                this.Target = target;
                if (this.Target != null && this.Target.style.display != "none")
                    this.old_display = target.style.display;
                if (this.Target != null) {
                    this.old_pointerEvents = this.Target.style.pointerEvents;
                }
                return this;
            }
            setIsEnableSource(prop) {
                this.IsEnabledSource = prop;
                return this;
            }
            setIsVisibleSource(prop) {
                this.IsVisibleSource = prop;
                return this;
            }
            setIsEnable(isEnable) {
                this.IsEnable = isEnable;
                if (!this.IsEnable) {
                    this.Target.setAttribute("disabled", "true");
                    this.Target.style.pointerEvents = "none";
                }
                else {
                    this.Target.removeAttribute("disabled");
                    this.Target.style.pointerEvents = this.old_pointerEvents;
                }
                return this;
            }
            setIsVisible(isVisible) {
                this.IsVisible = isVisible;
                if (isVisible) {
                    this.Target.style.display = this.old_display;
                }
                else {
                    this.Target.style.display = "none";
                }
                return this;
            }
            CallOnPropertyChanged(sender, prop) {
                if (this.isUpdating)
                    return;
                this.isUpdating = true;
                this.OnPropertyChanged(sender, prop);
                this.isUpdating = false;
            }
            OnPropertyChanged(sender, prop) {
                if (this.IsPasued)
                    return;
                if (this.IsEnabledSource != null && prop == this.IsEnabledSource) {
                    this.setIsEnable(this.Source[this.IsEnabledSource]);
                }
                else if (this.IsVisibleSource != null && prop == this.IsVisibleSource) {
                    this.setIsVisible(this.Source[this.IsVisibleSource]);
                }
            }
            static GetOrSetChild(ctr, container, tag) {
                var result = $(container).find(tag).get(0);
                if (result instanceof ctr)
                    return result;
                if (result != null)
                    return null;
                result = document.createElement(tag);
                container.appendChild(result);
                return result;
            }
        }
        UIs.BiBase = BiBase;
        class BiCollection {
            constructor() {
                this.Children = [];
            }
            Pause() {
                for (var ch of this.Children)
                    ch.Pause();
            }
            Resume() {
                for (var ch of this.Children)
                    ch.Resume();
            }
            UnBind() {
                for (var ch of this.Children)
                    ch.UnBind();
                this.Children = [];
            }
            Update() {
                for (var ch of this.Children)
                    ch.Update();
            }
        }
        UIs.BiCollection = BiCollection;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiCommand extends UIs.BiBase {
            get Command() {
                return this._command;
            }
            set Command(value) {
                if (this._command != null)
                    this._command.PropertyChanged.Remove(this, this.OnPropertyChanged);
                this._command = value;
                if (this._command != null)
                    this._command.PropertyChanged.Add(this, this.OnPropertyChanged);
            }
            setTarget(target) {
                this.Target = target;
                this.Target.onmouseup = (ev) => {
                    if (this.Command != null) {
                        var cmdArg = this.CommandArgGetter != null ? this.CommandArgGetter(this) : this.CommandArg;
                        if (this.Command.CanExecute(cmdArg)) {
                            this.Command.Execute(cmdArg);
                        }
                    }
                    return false;
                };
                return this;
            }
            setContentRenderer(renderer) {
                this.ContentRenderer = renderer;
                return this;
            }
            setContentSource(content) {
                this.ContentSource = content;
                return this;
            }
            setCommandSource(source) {
                this.CommandSource = source;
                return this;
            }
            setCommand(command) {
                this.Command = command;
                return this;
            }
            setCommandArgumentGetter(argFunc) {
                this.CommandArgGetter = argFunc;
                return this;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (sender === this._command && prop === "CanExecute") {
                    var canExecute = this._command.CanExecute(this._command);
                    if (canExecute == true)
                        this.Target.disabled = false;
                    else
                        this.Target.disabled = true;
                }
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.CommandSource) {
                    this.Command = this.Source[this.CommandSource];
                }
                else if (prop === this.ContentSource) {
                    this.UpdateContent();
                }
            }
            OnUpdate() {
                this.UpdateCommand();
                this.UpdateContent();
            }
            UpdateCommand() {
                if (this.Source != null && this.CommandSource != null)
                    this.Command = this.Source[this.CommandSource];
            }
            UpdateContent() {
                var content = this.ContentSource != null ? this.Source[this.ContentSource] : null;
                if (this.Content == content)
                    return;
                this.Content = content;
                if (this.Target != null && this.ContentRenderer != null)
                    this.ContentRenderer(this.Target, this.Content);
            }
            UnBind() {
                super.UnBind();
                if (this.Target != null) {
                    this.Target.onchange = null;
                    this.Target.onclick = null;
                    this.Target.onmouseup = null;
                }
                if (this._command != null)
                    this._command.PropertyChanged.Remove(this, this.OnPropertyChanged);
                return this;
            }
        }
        UIs.BiCommand = BiCommand;
        class BiButton extends BiCommand {
        }
        UIs.BiButton = BiButton;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiCheckBox extends UIs.BiBase {
            setTarget(target) {
                this.Target = target;
                this.Target.onchange = (ev) => {
                    ev.preventDefault();
                    this.OnTargetChanged(target, ev);
                };
                return this;
            }
            setContentRenderer(renderer) {
                this.ContentRenderer = renderer;
                return this;
            }
            setIsChecked(value) {
                this.IsChecked = value;
                return this;
            }
            setIsCheckedSource(source) {
                this.IsCheckedSource = source;
                return this;
            }
            setIsVisible(isVisible) {
                this.IsVisible = isVisible;
                if (isVisible) {
                    if (this.Target.getAttribute('data-toggle') == 'toggle' && this.Target.parentElement != null) {
                        this.Target.parentElement.style.display = this.Old_display;
                    }
                    else {
                        this.Target.style.display = this.Old_display;
                    }
                }
                else {
                    if (this.Target.getAttribute('data-toggle') == 'toggle' && this.Target.parentElement != null) {
                        this.Target.parentElement.style.display = 'none';
                    }
                    else {
                        this.Target.style.display = "none";
                    }
                }
                return this;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.IsCheckedSource) {
                    this.UpdateIsChecked();
                }
            }
            OnTargetChanged(target, ev) {
                if (this.IsPasued)
                    return;
                if (this.Source != null && this.IsCheckedSource != null)
                    this.Source[this.IsCheckedSource] = target.checked;
                else
                    this.IsChecked = target.checked;
            }
            OnUpdate() {
                this.UpdateIsChecked();
            }
            UnBind() {
                if (this.Source != null)
                    this.Source.PropertyChanged.Remove(this, this.OnPropertyChanged);
                if (this.Target != null)
                    this.Target.onchange = null;
                return this;
            }
            UpdateIsChecked() {
                if (this.Source != null && this.IsCheckedSource != null) {
                    var selectedItem = this.Source[this.IsCheckedSource];
                    if (selectedItem === this.IsChecked)
                        return;
                    this.IsChecked = selectedItem;
                }
                if (this.ContentRenderer != null) {
                    this.ContentRenderer(this.Target, this.IsChecked);
                }
                this.Target.checked = this.IsChecked;
            }
        }
        UIs.BiCheckBox = BiCheckBox;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiColorPicker extends UIs.BiBase {
            setTarget(target) {
                this.Target = target;
                $(this.Target).colorpicker({
                    cancel: (arg) => {
                        console.log("colorpicker.cancel" + arg);
                    },
                    close: (arg) => {
                        console.log("colorpicker.close" + arg);
                    },
                    init: (arg) => {
                        console.log("colorpicker.init" + arg);
                    },
                    select: (arg) => {
                        console.log("colorpicker.select" + arg);
                    },
                    ok: (arg1, arg2) => {
                        this.OnColorChange(arg2.a, arg2.rgb.r, arg2.rgb.g, arg2.rgb.b);
                    },
                    alpha: this.UseAlpha,
                    open: null
                });
                return this;
            }
            setUserAlpha(useAlpha) {
                this.UseAlpha = useAlpha;
                return this;
            }
            setColorSource(content) {
                this.ColorSource = content;
                return this;
            }
            OnColorChange(a, r, g, b) {
                this.Color = new U1.Color(r * 255, g * 255, b * 255, a * 255);
                if (this.Source != null && this.ColorSource != null)
                    this.Source[this.ColorSource] = this.Color;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (this.IsPasued)
                    return;
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.ColorSource) {
                    this.UpdateColor();
                }
            }
            OnUpdate() {
                this.UpdateColor();
            }
            UpdateColor() {
                var color = this.ColorSource != null ? this.Source[this.ColorSource] : this.Color;
                if (color instanceof U1.Color) {
                    this.Color = color;
                    if (this.UseAlpha) {
                        this.Target.value = `${U1.decimalToHex(this.Color.R)}${U1.decimalToHex(this.Color.G)}${U1.decimalToHex(this.Color.B)}${U1.decimalToHex(this.Color.A)}`;
                    }
                    else {
                        this.Target.value = `${U1.decimalToHex(this.Color.R)}${U1.decimalToHex(this.Color.G)}${U1.decimalToHex(this.Color.B)}`;
                    }
                }
            }
            UnBind() {
                super.UnBind();
                if (this.Target != null) {
                    this.Target.onchange = null;
                    this.Target.onkeyup = null;
                }
                return this;
            }
        }
        UIs.BiColorPicker = BiColorPicker;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiComboBox extends UIs.BiBase {
            constructor() {
                super(...arguments);
                this._itemsMap = {};
                this._isItemsUpdated = false;
            }
            setTarget(target) {
                this.Target = target;
                this.Target.onchange = (ev) => {
                    this.OnTargetChanged(target, ev);
                };
                return this;
            }
            setItemRenderer(renderer) {
                this.ItemRenderer = renderer;
                return this;
            }
            setSelectedItemSource(source) {
                this.SelectedItemSource = source;
                return this;
            }
            setItemsSource(source) {
                this.ItemsSource = source;
                return this;
            }
            setItems(items) {
                this.Items = items;
                this._isItemsUpdated = false;
                return this;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.SelectedItemSource) {
                    if (!this._isItemsUpdated)
                        this.UpdateItems();
                    this.UpdateSelectedItem();
                }
                else if (prop === this.ItemsSource) {
                    this.UpdateItems();
                }
                else if (prop === "Reload") {
                    this.UpdateItems();
                    this.UpdateSelectedItem();
                }
            }
            OnTargetChanged(target, ev) {
                if (this.IsPasued)
                    return;
                var sel_item = this._itemsMap[target.value];
                this.Source[this.SelectedItemSource] = sel_item;
            }
            OnUpdate() {
                this.UpdateItems();
                this.UpdateSelectedItem();
            }
            UnBind() {
                super.UnBind();
                if (this.Target != null)
                    this.Target.onchange = null;
                return this;
            }
            UpdateSelectedItem() {
                this.SelectedItem = this.Source[this.SelectedItemSource];
                if (this.SelectedItem == null && this.Target.selectedIndex != -1) {
                    this.Target.selectedIndex = -1;
                    return;
                }
                if (this._oldSelectedItem == this.SelectedItem)
                    return;
                if (this.ItemRenderer != null) {
                    this.ItemRenderer(this.Target, this.SelectedItem);
                }
                else
                    this.Target.value = this.SelectedItem.toString();
            }
            UpdateItems() {
                var items = this.Items;
                if (this.ItemsSource != null)
                    items = this.Source[this.ItemsSource];
                if (items == null)
                    items = [];
                var isChanged = this.Items == null || !this._isItemsUpdated;
                if (!isChanged)
                    isChanged = items.length != this.Items.length;
                if (!isChanged) {
                    for (var i = 0; i < items.length; i++) {
                        isChanged = items[i] != this.Items[i];
                        if (isChanged)
                            break;
                    }
                }
                if (!isChanged)
                    return;
                while (this.Target.children.length > 0) {
                    this.Target.removeChild(this.Target.lastChild);
                }
                this.Items = items.slice();
                for (var i = 0; i < this.Items.length; i++) {
                    var item = this.Items[i];
                    var option = null;
                    if (i < this.Target.children.length) {
                        option = this.Target.children.item(0);
                    }
                    if (option == null) {
                        option = document.createElement("option");
                        this.Target.appendChild(option);
                    }
                    if (this.ItemRenderer != null) {
                        this.ItemRenderer(option, item);
                    }
                    else {
                        option.value = item.toString();
                        option.textContent = item.toString();
                    }
                    this._itemsMap[option.value] = item;
                }
                this._isItemsUpdated = true;
            }
        }
        UIs.BiComboBox = BiComboBox;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiContent extends UIs.BiBase {
            setContentRenderer(renderer) {
                this.ContentRenderer = renderer;
                return this;
            }
            setContentSource(content) {
                this.ContentSource = content;
                return this;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.ContentSource) {
                    this.UpdateContent();
                }
            }
            OnUpdate() {
                this.UpdateContent();
            }
            UpdateContent() {
                var content = this.ContentSource != null ? this.Source[this.ContentSource] : null;
                if (this.Content == content)
                    return;
                this.Content = content;
                if (this.Target != null && this.ContentRenderer != null)
                    this.ContentRenderer(this.Target, this.Content);
            }
            UnBind() {
                super.UnBind();
                return this;
            }
        }
        UIs.BiContent = BiContent;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiEnable extends UIs.BiBase {
        }
        UIs.BiEnable = BiEnable;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiItemsControl extends UIs.BiBase {
            constructor() {
                super(...arguments);
                this.item_edits = [];
            }
            setTarget(target) {
                this.Target = target;
                this.Target.onclick = (ev) => {
                    this.OnItemClick(ev);
                };
                return this;
            }
            setItemRenderer(renderer) {
                this.ItemRenderer = renderer;
                return this;
            }
            setItemsSource(source) {
                this.ItemsSource = source;
                return this;
            }
            setClickHandler(handler) {
                this.ItemClickHandler = handler;
                return this;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.ItemsSource) {
                    this.UpdateItems();
                }
            }
            OnItemClick(ev) {
                if (this.IsPasued)
                    return;
                var elm = (ev.srcElement || ev.target);
                ev.preventDefault();
                while (!(elm instanceof HTMLLIElement) && elm != null) {
                    elm = elm.parentElement;
                }
                if (elm instanceof HTMLLIElement) {
                    var index = -1;
                    for (var i = 0; i < this.Target.children.length; i++) {
                        if (this.Target.children.item(i) == elm) {
                            index = i;
                            break;
                        }
                    }
                    if (this.ItemClickHandler != null && index >= 0)
                        this.ItemClickHandler(this.Items[index]);
                }
            }
            OnUpdate() {
                this.UpdateItems();
            }
            UnBind() {
                super.UnBind();
                if (this.Target != null)
                    this.Target.onchange = null;
                return this;
            }
            UpdateItems() {
                var items = this.Source[this.ItemsSource];
                var isChanged = this.Items == null;
                if (!isChanged)
                    isChanged = items.length != this.Items.length;
                if (!isChanged) {
                    for (var i = 0; i < items.length; i++) {
                        isChanged = items[i] != this.Items[i];
                        if (isChanged)
                            break;
                    }
                }
                if (!isChanged)
                    return;
                while (this.Target.children.length > 0) {
                    this.Target.removeChild(this.Target.lastChild);
                }
                for (var item_edit of this.item_edits) {
                    if (item_edit != null)
                        item_edit.UnBind();
                }
                this.item_edits = [];
                this.Items = (items || []).slice();
                for (var i = 0; i < this.Items.length; i++) {
                    var item = this.Items[i];
                    var li = null;
                    if (i < this.Target.children.length) {
                        li = this.Target.children.item(0);
                    }
                    if (li == null) {
                        li = document.createElement("li");
                        this.Target.appendChild(li);
                    }
                    if (this.ItemRenderer != null) {
                        var child_edit = this.ItemRenderer(li, item);
                        if (child_edit instanceof UIs.BiBase) {
                            this.item_edits[i] = child_edit;
                        }
                    }
                    else {
                        li.textContent = item.toString();
                    }
                }
            }
        }
        UIs.BiItemsControl = BiItemsControl;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiLabel extends UIs.BiBase {
            setTarget(target) {
                this.Target = target;
                return this;
            }
            setContentRenderer(renderer) {
                this.ContentRenderer = renderer;
                return this;
            }
            setContentSource(content) {
                this.ContentSource = content;
                return this;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.ContentSource) {
                    this.UpdateContent();
                }
            }
            OnUpdate() {
                this.UpdateContent();
            }
            UpdateContent() {
                var content = this.ContentSource != null ? this.Source[this.ContentSource] : null;
                if (this.Content == content)
                    return;
                this.Content = content;
                if (this.Target != null && this.ContentRenderer != null)
                    this.ContentRenderer(this.Target, this.Content);
            }
            UnBind() {
                super.UnBind();
                return this;
            }
        }
        UIs.BiLabel = BiLabel;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiListBox extends UIs.BiBase {
            constructor() {
                super(...arguments);
                this.lielements = [];
            }
            setTarget(target) {
                this.Target = target;
                this.Target.onclick = (ev) => {
                    this.OnItemClick(ev);
                };
                return this;
            }
            setItemRenderer(renderer) {
                this.ItemRenderer = renderer;
                return this;
            }
            setSelectedItemSource(source) {
                this.SelectedItemSource = source;
                return this;
            }
            setItemsSource(source) {
                this.ItemsSource = source;
                return this;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.SelectedItemSource) {
                    this.UpdateSelectedItem();
                }
                else if (prop === this.ItemsSource) {
                    this.UpdateItems();
                }
            }
            OnItemClick(ev) {
                if (this.IsPasued)
                    return;
                var elm = (ev.srcElement || ev.target);
                ev.preventDefault();
                while (!(elm instanceof HTMLLIElement) && elm != null) {
                    elm = elm.parentElement;
                }
                if (elm instanceof HTMLLIElement) {
                    var index = -1;
                    for (var i = 0; i < this.Target.children.length; i++) {
                        if (this.Target.children.item(i) == elm) {
                            index = i;
                            break;
                        }
                    }
                    if (index >= 0)
                        this.Source[this.SelectedItemSource] = this.Items[index];
                }
            }
            OnUpdate() {
                this.UpdateItems();
                this.UpdateSelectedItem();
            }
            UnBind() {
                super.UnBind();
                if (this.Target != null)
                    this.Target.onclick = null;
                return this;
            }
            UpdateSelectedItem() {
                var curSelectedItem = this.Source[this.SelectedItemSource];
                if (curSelectedItem == this.SelectedItem)
                    return;
                this.SelectedItem = curSelectedItem;
                if (this.lielements == null)
                    this.UpdateItems();
                if (this.lielements == null)
                    return;
                for (var i = 0; i < this.lielements.length; i++) {
                    var li = this.lielements[i];
                    var isSelected = this.SelectedItem == li.item;
                    if (this.ItemRenderer != null) {
                        if (li.isSelected != isSelected) {
                            li.isSelected = isSelected;
                            var child_edit = this.ItemRenderer(li.li, this.Items[i], isSelected);
                            if (li.edit != null)
                                li.edit.UnBind();
                            li.edit = null;
                            if (child_edit instanceof UIs.BiBase) {
                                li.edit = child_edit;
                            }
                        }
                    }
                }
            }
            UpdateItems() {
                var items = this.Source[this.ItemsSource];
                var selectedItem = this.Source[this.SelectedItemSource];
                var isChanged = this.Items == null;
                if (!isChanged)
                    isChanged = items.length != this.Items.length;
                if (!isChanged) {
                    for (var i = 0; i < items.length; i++) {
                        isChanged = items[i] != this.Items[i];
                        if (isChanged)
                            break;
                    }
                }
                if (!isChanged)
                    return;
                while (this.Target.children.length > 0) {
                    this.Target.removeChild(this.Target.lastChild);
                }
                this.Items = (items || []).slice();
                this.SelectedItem = selectedItem;
                for (var le of this.lielements) {
                    if (le.edit != null)
                        le.edit.UnBind();
                }
                this.lielements = [];
                for (var i = 0; i < this.Items.length; i++) {
                    var item = this.Items[i];
                    var edit = null;
                    var isSelected = this.SelectedItem == item;
                    var li = document.createElement("li");
                    this.Target.appendChild(li);
                    if (this.ItemRenderer != null) {
                        var child_edit = this.ItemRenderer(li, item, isSelected);
                        if (child_edit instanceof UIs.BiBase) {
                            edit = child_edit;
                        }
                    }
                    else {
                        li.textContent = item.toString();
                    }
                    this.lielements[i] = { li: li, item: item, edit: edit, isSelected: isSelected };
                }
            }
        }
        UIs.BiListBox = BiListBox;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiNumber extends UIs.BiBase {
            constructor() {
                super(...arguments);
                this.ChangeAfterEnter = true;
            }
            setTarget(target) {
                this.Target = target;
                this.Target.onkeyup = (ev) => this.OnKeyUp(ev);
                target.onchange = (ev) => {
                    this.OnTextChange(this.Target.value);
                };
                return this;
            }
            setValueSource(content) {
                this.ValueSource = content;
                return this;
            }
            setChangeAfterEnter(value) {
                this.ChangeAfterEnter = value;
                return this;
            }
            OnKeyUp(event) {
                if (!this.ChangeAfterEnter || event.keyCode == 13) {
                    var input = event.target;
                    this.OnTextChange(input.value);
                    event.preventDefault();
                }
            }
            OnTextChange(text) {
                var value = parseInt(text);
                if (this.ValueSource != null && !isNaN(value) && value != this.Value) {
                    this.Source[this.ValueSource] = value;
                }
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (this.IsPasued)
                    return;
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.ValueSource) {
                    this.UpdateValue();
                }
            }
            OnUpdate() {
                this.UpdateValue();
            }
            UpdateValue() {
                var value = this.ValueSource != null ? this.Source[this.ValueSource] : this.Value;
                if (this.Value == value)
                    return;
                this.Value = value;
                this.Target.value = this.Value.toString();
            }
            UnBind() {
                super.UnBind();
                if (this.Target != null) {
                    this.Target.onkeyup = null;
                    this.Target.onchange = null;
                }
                return this;
            }
        }
        UIs.BiNumber = BiNumber;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiPropertyEdit extends UIs.BiBase {
            get Property() {
                return this.Source;
            }
            setContentRenderer(renderer) {
                this.ContentRenderer = renderer;
                return this;
            }
            setSource(source) {
                super.setSource(source);
                return this;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop == "ValueText") {
                    this.input.value = this.Property.ValueText;
                    this.text = null;
                }
            }
            OnUpdate() {
                if (this.ContentRenderer != null) {
                    while (this.Target.children.length > 0) {
                        this.Target.removeChild(this.Target.lastChild);
                    }
                    this.ContentRenderer(this.Target);
                    return this;
                }
                if (this.label == null) {
                    this.label = document.createElement("label");
                    this.label.textContent = this.Property.Label;
                    this.label.setAttribute("class", "PropLabel");
                    var td = document.createElement("td");
                    td.appendChild(this.label);
                    this.Target.appendChild(td);
                }
                if (this.input == null) {
                    this.input = document.createElement("input");
                    this.input.type = "text";
                    this.input.value = this.Property.ValueText;
                    this.input.setAttribute("type", "number");
                    this.input.onkeyup = (ev) => this.OnKeyUp(ev);
                    this.input.onchange = (ev) => this.OnChange(ev);
                    var td = document.createElement("td");
                    td.appendChild(this.input);
                    this.Target.appendChild(td);
                }
            }
            UnBind() {
                super.UnBind();
                if (this.input != null) {
                    this.input.onkeyup = null;
                    this.input.onchange = null;
                }
                return this;
            }
            OnChange(event) {
                var input = event.target;
                this.OnTextChange(input.value);
            }
            OnKeyUp(event) {
                if (event.keyCode == 13) {
                    var input = event.target;
                    event.preventDefault();
                    this.OnTextChange(input.value);
                }
            }
            OnTextChange(text) {
                this.text = text;
                if (this.text != null && this.text != this.Property.ValueText)
                    this.Property.ValueText = this.text;
                this.text = null;
            }
        }
        UIs.BiPropertyEdit = BiPropertyEdit;
        class BiPropertyEditSelection extends BiPropertyEdit {
            OnUpdate() {
                return this;
            }
        }
        UIs.BiPropertyEditSelection = BiPropertyEditSelection;
        class BiPropertyEditCategory extends BiPropertyEdit {
            OnUpdate() {
                return this;
            }
        }
        UIs.BiPropertyEditCategory = BiPropertyEditCategory;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiPropertyGrid extends UIs.BiBase {
            setItemsSource(source) {
                this.ItemsSource = source;
                return this;
            }
            setEditCreater(creater) {
                this.editCreater = creater;
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (sender != this.Source || this.IsPasued)
                    return;
                if (sender === this.Source) {
                    if (prop === this.ItemsSource) {
                        this.UpdateItems();
                    }
                }
            }
            OnUpdate() {
                this.UpdateItems();
            }
            UnBind() {
                super.UnBind();
                if (this.PropertyEdits != null) {
                    for (var prop of this.PropertyEdits) {
                        prop.UnBind();
                    }
                }
                if (this.Target != null)
                    this.Target.onchange = null;
                return this;
            }
            UpdateItems() {
                var items = this.Source[this.ItemsSource] || [];
                var isChanged = this.Items == null;
                if (!isChanged)
                    isChanged = items.length != this.Items.length;
                if (!isChanged) {
                    for (var i = 0; i < items.length; i++) {
                        isChanged = items[i] != this.Items[i];
                        if (isChanged)
                            break;
                    }
                }
                if (!isChanged)
                    return;
                while (this.Target.children.length > 0) {
                    this.Target.removeChild(this.Target.lastChild);
                }
                var tbody = document.createElement("tbody");
                this.Target.appendChild(tbody);
                if (this.PropertyEdits != null) {
                    for (var prop of this.PropertyEdits) {
                        prop.UnBind();
                    }
                }
                this.Items = items;
                this.PropertyEdits = [];
                if (this.Items != null) {
                    for (var i = 0; i < this.Items.length; i++) {
                        var item = this.Items[i];
                        var tr = document.createElement("tr");
                        tbody.appendChild(tr);
                        var editor = this.editCreater != null ? this.editCreater(item, tr) : null;
                        if (editor == null) {
                            editor = new UIs.BiPropertyEdit()
                                .setSource(item)
                                .setTarget(tr);
                        }
                        editor.Update();
                        this.PropertyEdits.push(editor);
                    }
                }
            }
            Pause() {
                super.Pause();
                if (this.PropertyEdits != null) {
                    for (var prop of this.PropertyEdits) {
                        prop.Pause();
                    }
                }
                return this;
            }
            Resume() {
                super.Resume();
                if (this.PropertyEdits != null) {
                    for (var prop of this.PropertyEdits) {
                        prop.Resume();
                    }
                }
                return this;
            }
        }
        UIs.BiPropertyGrid = BiPropertyGrid;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiTextArea extends UIs.BiBase {
            setTarget(target) {
                this.Target = target;
                this.Target.onchange = (ev) => {
                    ev.preventDefault();
                    this.OnTargetChanged(target, ev);
                };
                return this;
            }
            setTextSource(content) {
                this.TextSource = content;
                return this;
            }
            setAfterTextChangedFunc(func) {
                this.AfterTextChangedFunc = func;
                return this;
            }
            OnTargetChanged(target, ev) {
                if (this.IsPasued)
                    return;
                if (this.isUpdating)
                    return;
                if (this.AfterTextChangedFunc != null)
                    this.AfterTextChangedFunc(this, target.value);
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (this.IsPasued)
                    return;
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.TextSource) {
                    this.UpdateText();
                }
            }
            OnUpdate() {
                this.UpdateText();
            }
            UpdateText() {
                var text = this.TextSource != null ? this.Source[this.TextSource] : this.Text;
                if (this.Text == text)
                    return;
                this.Text = text;
                this.Target.value = this.Text;
            }
            UnBind() {
                super.UnBind();
                if (this.Target != null) {
                    this.Target.onchange = null;
                    this.Target.onkeyup = null;
                }
                return this;
            }
        }
        UIs.BiTextArea = BiTextArea;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiTextBox extends UIs.BiBase {
            setTarget(target) {
                if (target != null) {
                    this.Target = target;
                    this.Target.onkeyup = (ev) => this.OnKeyUp(ev);
                    target.onchange = (ev) => {
                        this.OnTextChange(this.Target.value);
                    };
                }
                else {
                    if (this.Target != null) {
                        this.Target.onchange = null;
                        this.Target.onkeyup = null;
                        this.Target = null;
                    }
                }
                return this;
            }
            setTextSource(content) {
                this.TextSource = content;
                return this;
            }
            setText(value) {
                this.Text = value;
                return this;
            }
            setAfterTextChangedFunc(func) {
                this.AfterTextChangedFunc = func;
                return this;
            }
            OnKeyUp(event) {
                if (event.keyCode == 13) {
                    var input = event.target;
                    var text = input.value;
                    event.preventDefault();
                    this.OnTextChange(text);
                }
            }
            OnTextChange(text) {
                if (this.AfterTextChangedFunc != null) {
                    this.AfterTextChangedFunc(this, this.Target.value);
                }
                else {
                    if (this.Source != null && this.TextSource != null) {
                        if (text != null && text != this.Text) {
                            this.Source[this.TextSource] = text;
                        }
                    }
                    else {
                        this.Text = text;
                    }
                }
            }
            OnPropertyChanged(sender, prop) {
                super.OnPropertyChanged(sender, prop);
                if (this.IsPasued)
                    return;
                if (sender != this.Source || this.IsPasued)
                    return;
                if (prop === this.TextSource) {
                    this.UpdateText();
                }
            }
            OnUpdate() {
                this.UpdateText();
            }
            UpdateText() {
                var text = this.TextSource != null ? this.Source[this.TextSource] : this.Text;
                this.Text = text;
                if (this.Target.value == this.Text)
                    return;
                this.Target.value = this.Text;
            }
            UnBind() {
                super.UnBind();
                if (this.Target != null) {
                    this.Target.onchange = null;
                    this.Target.onkeyup = null;
                }
                return this;
            }
        }
        UIs.BiTextBox = BiTextBox;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class BiVisibility extends UIs.BiBase {
        }
        UIs.BiVisibility = BiVisibility;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class DialogBase {
            constructor() {
                this._isActive = true;
                this.binders = {};
                this.commands = {};
                this.AfterClosed = new U1.Event1();
            }
            Init() {
                if (this._isInit || this._isIniting)
                    return;
                if (this._root == null) {
                    this._isIniting = true;
                    this._root = document.createElement("div");
                    $(this._root).load(this.HtmlPage, "", (txt_, state_) => {
                        if (state_ != "success")
                            return;
                        this._isIniting = false;
                        this._isInit = true;
                        this.InitBinders();
                        this.UpdateBinders();
                        this.OnLoaded();
                    });
                }
            }
            InitBinders() {
            }
            UnBinde() {
                for (var idx in this.binders) {
                    this.binders[idx].UnBind();
                }
                for (var idx in this.commands) {
                    this.commands[idx].Dispose();
                }
                this.binders = {};
                this.commands = {};
            }
            UpdateBinders() {
                for (var key in this.binders) {
                    this.binders[key].Update();
                }
            }
            Accept() {
            }
            ShowDialog() {
                this.Init();
            }
            OnClose(ev) {
                this.UnBinde();
                if (this._root != null) {
                    $("body").get(0).removeChild(this._root);
                }
                this._root = null;
                if (this.AfterClosed != null) {
                    this.AfterClosed.Invoke(this);
                    this.AfterClosed.Clear();
                    this.AfterClosed = null;
                }
            }
            OnLoaded() {
                $("body").get(0).appendChild(this._root);
                $(this._root.firstElementChild)
                    .modal()
                    .on('hidden.bs.modal', (ev) => this.OnClose(ev));
            }
        }
        UIs.DialogBase = DialogBase;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var UIs;
    (function (UIs) {
        class PanelBase {
            constructor() {
                this._isActive = true;
                this.binders = {};
            }
            Init() {
                if (this._isInit || this._isIniting)
                    return;
                if (this._root == null) {
                    this._isIniting = true;
                    this._root = document.createElement("div");
                    $(this._root).load(this.HtmlPage, "", (txt_, state_) => {
                        if (state_ != "success")
                            return;
                        this._isIniting = false;
                        this._isInit = true;
                        this.InitBinders();
                        this.UpdateBinders();
                    });
                }
            }
            get Root() {
                return this._root;
            }
            get IsActive() {
                return this._isActive;
            }
            set IsActive(value) {
                this._isActive = value;
            }
            InitBinders() {
            }
            UpdateBinders() {
                for (var key in this.binders) {
                    this.binders[key].Update();
                }
            }
            PauseBinders() {
                for (var key in this.binders) {
                    this.binders[key].Pause();
                }
            }
            ResumeBinders() {
                for (var key in this.binders) {
                    this.binders[key].Resume();
                }
            }
            ClearBinders() {
                for (var key in this.binders) {
                    this.binders[key].UnBind();
                }
                this.binders = {};
            }
            ClearChildren(parent) {
                while (parent.hasChildNodes()) {
                    parent.removeChild(parent.lastChild);
                }
            }
            get PropertyChanged() {
                if (this._propertyChanged == null)
                    this._propertyChanged = new U1.PropertyChangedEvent();
                return this._propertyChanged;
            }
            OnPropertyChanged(prop) {
            }
            InvokePropertyChanged(prop) {
                this.OnPropertyChanged(prop);
                if (this._propertyChanged != null) {
                    this.PropertyChanged.Invoke(this, prop);
                }
            }
        }
        UIs.PanelBase = PanelBase;
    })(UIs = U1.UIs || (U1.UIs = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class VcControlContainer {
            constructor(view) {
                this._orderedItems = null;
                this.Controls = new Array();
                this._controlAdded = new U1.Event2();
                this._controlRemoving = new U1.Event2();
                this._view = view;
            }
            get View() {
                return this._view;
            }
            get ActiveControl() {
                return this._activeControl;
            }
            set ActiveControl(value) {
                if (this._activeControl == value)
                    return;
                this._activeControl = value;
            }
            get OrderedControls() {
                if (this._orderedItems == null) {
                    this._orderedItems = this.Controls.sort((a_, b_) => {
                        if (a_.Order < b_.Order)
                            return -1;
                        if (a_.Order > b_.Order)
                            return 1;
                        return 0;
                    });
                }
                return this._orderedItems;
            }
            AddControl(ctor) {
                var ch = this.View.newControlInstance(ctor);
                ch.Container = this;
                if (this.Controls == null) {
                    this.Controls = new Array();
                }
                this.Controls.push(ch);
                this.InvokeControlAdded(ch);
                this._orderedItems = null;
                return ch;
            }
            RemoveControl(item) {
                if (item == null)
                    return;
                this.InvokeControlRemoving(item);
                if (this.Controls == null)
                    return;
                if (this.ActiveControl == item)
                    this.ActiveControl = null;
                var idx = this.Controls.indexOf(item);
                this.Controls.splice(idx, 1);
                this._orderedItems = null;
                if (!item.IsDisposed) {
                    item.Clear();
                }
            }
            get ControlAdded() {
                return this._controlAdded;
            }
            get ControlRemoving() {
                return this._controlRemoving;
            }
            InvokeControlAdded(entity) {
                this._controlAdded.Invoke(this, entity);
            }
            InvokeControlRemoving(item) {
                this._controlRemoving.Invoke(this, item);
            }
            Pick(isectContext) {
                var res_isect = null;
                var res_node = null;
                var orderedNodes = this.OrderedControls;
                for (var i = orderedNodes.length - 1; i >= 0; i--) {
                    var node = orderedNodes[i];
                    if (node.IsPickable === false)
                        continue;
                    var isect = node.CheckIntersect(isectContext);
                    if (isect == null)
                        continue;
                    if (res_isect == null || isect.Distance < res_isect.Distance) {
                        isectContext.MaxDistance = isect.Distance;
                        res_node = node;
                        res_isect = isect;
                    }
                }
                var result = new Views.PickResult();
                result.ISect = res_isect;
                result.Control = res_node;
                return result;
            }
            Update() {
                var orderedItems = this.OrderedControls;
                for (var p of orderedItems) {
                    p.Update();
                }
            }
        }
        Views.VcControlContainer = VcControlContainer;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class UpdateContext extends Views.ScRenderContext {
            constructor() {
                super(...arguments);
                this.IsScreenSpace = false;
                this.IsOveraySpace = false;
            }
        }
        Views.UpdateContext = UpdateContext;
        class DrawContext extends Views.ScRenderContext {
            constructor() {
                super(...arguments);
                this.IsScreenSpace = false;
                this.IsOveraySpace = false;
            }
            get ViewMatrix() {
                return this.getViewM();
            }
            set ViewMatrix(value) {
                this.setViewM(value);
            }
            get ProjMatrix() {
                return this.getProjM();
            }
            set ProjMatrix(value) {
                this.setProjM(value);
            }
        }
        Views.DrawContext = DrawContext;
        class PickResult {
            get Presenter() {
                if (this._presenter == null && this.Node != null)
                    return this.Node.Presenter;
                return this._presenter;
            }
            set Presenter(value) {
                this._presenter = value;
            }
        }
        Views.PickResult = PickResult;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScPolyLine extends Views.ScEntity {
            constructor() {
                super();
                this._style = new Views.ScStyle();
            }
            get Style() {
                return this._style;
            }
            set Style(value) {
                this._style = value;
                this.Invalidate();
            }
            get Points() {
                return this._points;
            }
            set Points(value) {
                this._points = value;
                this._triangles = null;
                this.InvalidateBounding();
            }
            get Triangles() {
                if (this._triangles == null) {
                    this._triangles = ScPolyLine.Tesselate(this._points);
                }
                return this._triangles;
            }
            UpdateGeometryBounding() {
                this._geometryBBx.SetCreateFromPoints(this.Points);
            }
            SetChanged() {
                super.SetChanged();
                this._triangles = null;
            }
            OnCheckIntersect(context, result) {
                var ray = Views.ScEntity.tmp_r30;
                var invm = Views.ScEntity.tmp_m0;
                var bbx = Views.ScEntity.tmp_bx0;
                var size = Views.ScEntity.tmp_v30;
                var d1 = Views.ScEntity.tmp_v31;
                var d2 = Views.ScEntity.tmp_v32;
                var pointOnRay = Views.ScEntity.tmp_v33;
                var pointOnPath = Views.ScEntity.tmp_v34;
                var wm = this.WorldTransform;
                invm.SetInvert(wm);
                ray.CopyFrom(context.Ray).Transform(invm);
                bbx.CopyFrom(this.BoundingBox);
                size.SetSubtract(bbx.Max, bbx.Min);
                size.Scale(0.1);
                bbx.Max.Add(size);
                bbx.Min.Subtract(size);
                if (bbx.IntersectsRay(ray) == null)
                    return null;
                ScPolyLine.GetNearestPoint(ray, this.Points, false, context.MaxDistance, pointOnRay, pointOnPath);
                pointOnRay.Transform(wm);
                pointOnPath.Transform(wm);
                if (context.IsLineIsect(pointOnRay, pointOnPath, this.Style.StrokeThickness)) {
                    var isect = result || new U1.ISectInfo();
                    isect.Source = this;
                    isect.IsectNormal = ray.Direction;
                    isect.IsectPosition = pointOnPath;
                    return isect;
                }
                if (this.Style.Filled) {
                    if (ScPolyLine.CheckPolygonInside(context.Ray, pointOnRay, this.Points)) {
                        var isect = new U1.ISectInfo();
                        isect.Source = this;
                        isect.IsectNormal = ray.Direction;
                        isect.IsectPosition = pointOnRay;
                        return isect;
                    }
                }
                return null;
            }
            static GetNearestPoint(ray, points, isClosed, min_dist, result_ptRay, result_ptPath) {
                var p_ray = U1.Vector3.Zero;
                var p_path = U1.Vector3.Zero;
                var p0 = U1.Vector3.Zero;
                var p1 = U1.Vector3.Zero;
                var d1 = U1.Vector3.Zero;
                var st = ScPolyLine.tmp_st;
                var pi = points.length - 1;
                var ci = 0;
                if (!isClosed) {
                    pi = 0;
                    ci = 1;
                }
                for (; ci < points.length; pi = ci, ci++) {
                    var pp = points[pi];
                    var cp = points[ci];
                    d1.SetSubtract(cp, pp);
                    var dist = U1.Line3.SquardDistance1(ray.Position, ray.Direction, pp, d1, st);
                    if (min_dist < dist)
                        continue;
                    if (st.t < 0)
                        st.t = 0;
                    if (st.t > 1)
                        st.t = 1;
                    p0.SetScaleAdd(ray.Position, st.s, ray.Direction);
                    p1.SetScaleAdd(pp, st.t, d1);
                    dist = U1.Vector3.DistanceSquared(p0, p1);
                    if (min_dist < dist)
                        continue;
                    min_dist = dist;
                    p_ray.CopyFrom(p0);
                    p_path.CopyFrom(p1);
                }
                result_ptRay.CopyFrom(p_ray);
                result_ptPath.CopyFrom(p_path);
            }
            static Tesselate(points) {
                var tess = new U1.LibTess.Tess();
                var contour = new Array(points.length);
                points.forEach((v_, i_) => {
                    var cv = new U1.LibTess.ContourVertex();
                    cv.Position.SetValues(v_.X, v_.Y, v_.Z);
                    contour[i_] = cv;
                });
                tess.AddContour(contour);
                tess.Tessellate(U1.LibTess.WindingRule.EvenOdd, U1.LibTess.ElementType.Polygons, 3, null);
                var result = new Array();
                for (var i = 0; i < tess.ElementCount; i++) {
                    for (var j = 0; j < 3; j++) {
                        var index = tess.Elements[i * 3 + j];
                        if (index == -1)
                            continue;
                        var v = new U1.Vector3(tess.Vertices[index].Position.X, tess.Vertices[index].Position.Y, tess.Vertices[index].Position.Z);
                        result.push(v);
                    }
                }
                return result;
            }
            static CheckPolygonInside(ray, point, points) {
                var u = ScPolyLine[".cpi.1"] || (ScPolyLine[".cpi.1"] = new U1.Vector3());
                var v = ScPolyLine[".cpi.2"] || (ScPolyLine[".cpi.2"] = new U1.Vector3());
                var d1 = ScPolyLine[".cpi.3"] || (ScPolyLine[".cpi.3"] = new U1.Vector3());
                var mp = ScPolyLine[".cpi.4"] || (ScPolyLine[".cpi.4"] = new U1.Vector3());
                var plane = ScPolyLine[".cpi.5"] || (ScPolyLine[".cpi.5"] = new U1.Plane());
                U1.GeometryHelper3.GetArbitraryAxis(ray.Direction, u, v);
                plane.SetFromPointNormal(point, v);
                var pi = points.length - 1;
                var ci = 0;
                var front = 0;
                var back = 0;
                for (; ci < points.length; pi = ci, ci++) {
                    var pp = points[pi];
                    var cp = points[ci];
                    if (plane.DotCoordinate(pp) * plane.DotCoordinate(cp) >= 0) {
                        continue;
                    }
                    d1.SetSubtract(cp, pp);
                    var t = plane.IntersectsLine(pp, d1);
                    if (t == null)
                        continue;
                    mp.SetScaleAdd(pp, t, d1);
                    d1.SetSubtract(mp, point);
                    t = U1.Vector3.Dot(d1, u);
                    if (t > 0)
                        front++;
                    else
                        back++;
                }
                if (front % 2 === back % 2)
                    return front % 2 == 1;
                return false;
            }
        }
        ScPolyLine.tmp_st = { s: -1, t: -1 };
        Views.ScPolyLine = ScPolyLine;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScPolygon extends Views.ScPolyLine {
            constructor() {
                super();
            }
            OnCheckIntersect(context, result) {
                var ray = Views.ScEntity.tmp_r30;
                var invm = Views.ScEntity.tmp_m0;
                var bbx = Views.ScEntity.tmp_bx0;
                var size = Views.ScEntity.tmp_v30;
                var d1 = Views.ScEntity.tmp_v31;
                var d2 = Views.ScEntity.tmp_v32;
                var pointOnRay = Views.ScEntity.tmp_v33;
                var pointOnPath = Views.ScEntity.tmp_v34;
                var wm = this.WorldTransform;
                invm.SetInvert(wm);
                ray.CopyFrom(context.Ray).Transform(invm);
                bbx.CopyFrom(this.BoundingBox);
                size.SetSubtract(bbx.Max, bbx.Min);
                size.Scale(0.1);
                bbx.Max.Add(size);
                bbx.Min.Subtract(size);
                if (bbx.IntersectsRay(ray) == null)
                    return null;
                ScPolygon.GetNearestPoint(ray, this.Points, true, context.MaxDistance, pointOnRay, pointOnPath);
                pointOnRay.Transform(wm);
                pointOnPath.Transform(wm);
                if (context.IsLineIsect(pointOnRay, pointOnPath, this.Style.StrokeThickness)) {
                    var isect = result || new U1.ISectInfo();
                    isect.Source = this;
                    isect.IsectNormal = context.Ray.Direction;
                    isect.IsectPosition = pointOnPath;
                    return isect;
                }
                if (this.Style.Filled) {
                    pointOnRay.Transform(invm);
                    if (Views.ScPolyLine.CheckPolygonInside(ray, pointOnRay, this.Points)) {
                        var isect = result || new U1.ISectInfo();
                        isect.Source = this;
                        isect.IsectNormal = context.Ray.Direction;
                        isect.IsectPosition = pointOnRay.Transform(wm);
                        return isect;
                    }
                }
                return null;
            }
        }
        Views.ScPolygon = ScPolygon;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScEllipse extends Views.ScPolygon {
            constructor() {
                super(...arguments);
                this._width = 10;
                this._height = 10;
            }
            get Width() {
                return this._width;
            }
            set Width(value) {
                this._width = value;
                this._points = null;
                this._triangles = null;
                this.InvalidateBounding();
            }
            get Height() {
                return this._height;
            }
            set Height(value) {
                this._height = value;
                this._points = null;
                this._triangles = null;
                this.InvalidateBounding();
            }
            get Points() {
                if (this._points == null) {
                    this._points = [];
                    var rx = this.Width / 2;
                    var ry = this.Height / 2;
                    var side = ScEllipse._ellipse_side;
                    var delt = Math.PI * 2 / side;
                    var ang = 0.0;
                    for (var i = 0; i < side; i++) {
                        ang = delt * i;
                        var p = new U1.Vector3();
                        p.X = Math.cos(ang) * rx;
                        p.Y = Math.sin(ang) * ry;
                        this._points.push(p);
                    }
                }
                return this._points;
            }
            Invalidate() {
                this._points = null;
                this._triangles = null;
                this.Ver++;
                super.Invalidate();
            }
        }
        ScEllipse._ellipse_side = 32;
        Views.ScEllipse = ScEllipse;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScGrid extends Views.ScEntity {
            constructor() {
                super(...arguments);
                this.m_isInitialized = false;
                this.m_distanceUnit = U1.UDistanceUnit.Meter;
            }
            get Unit() {
                return this.m_distanceUnit;
            }
            set Unit(value) {
                this.m_distanceUnit = value;
            }
            get GridScale() {
                return this.m_gridScale;
            }
            OnUpdate(context) {
                if (!this.Visible)
                    return;
                if (!this.m_isInitialized) {
                    this.Initialize();
                    this.m_isInitialized = true;
                }
                var p1 = ScGrid[".ou.1"] || (ScGrid[".ou.1"] = new U1.Vector3());
                var p2 = ScGrid[".ou.2"] || (ScGrid[".ou.2"] = new U1.Vector3());
                var p3 = ScGrid[".ou.3"] || (ScGrid[".ou.3"] = new U1.Vector3());
                var p4 = ScGrid[".ou.4"] || (ScGrid[".ou.4"] = new U1.Vector3());
                var p5 = ScGrid[".ou.5"] || (ScGrid[".ou.5"] = new U1.Vector3());
                var center = ScGrid[".ou.6"] || (ScGrid[".ou.6"] = new U1.Vector3());
                var cp2 = ScGrid[".ou.7"] || (ScGrid[".ou.7"] = new U1.Vector2());
                var sm = ScGrid[".ou.8"] || (ScGrid[".ou.8"] = new U1.Matrix4());
                var rm = ScGrid[".ou.9"] || (ScGrid[".ou.9"] = new U1.Matrix4());
                var tm = ScGrid[".ou.10"] || (ScGrid[".ou.10"] = new U1.Matrix4());
                var camera = context.Scene.Camera;
                var workingplane = context.Scene.View.WorkingPlane;
                cp2.Set(camera.ViewportWidth / 2, camera.ViewportHeight / 2);
                center = camera.ScreenToPlane(cp2, workingplane, center);
                if (center != null) {
                    var lenWorld = 1.0;
                    this.m_gridScale = 1;
                    if (this.m_distanceUnit == U1.UDistanceUnit.Feet) {
                        lenWorld = 0.3048;
                    }
                    p1.Set(lenWorld, 0, 0).Add(center);
                    p2.Set(0, lenWorld, 0).Add(center);
                    var sc = camera.WorldToScreen(center, p3);
                    var s1 = camera.WorldToScreen(p1, p4);
                    var s2 = camera.WorldToScreen(p2, p5);
                    var lenScreen = Math.max(U1.Vector3.Distance(sc, s1), U1.Vector3.Distance(sc, s2));
                    var rpt = 0;
                    while (lenScreen < 1.0 && (rpt++) < 4) {
                        lenWorld *= 2;
                        this.m_gridScale *= 2;
                        p1.Set(lenWorld, 0, 0).Add(center);
                        p2.Set(0, lenWorld, 0).Add(center);
                        sc = camera.WorldToScreen(center, p3);
                        s1 = camera.WorldToScreen(p1, p4);
                        s2 = camera.WorldToScreen(p2, p5);
                        lenScreen = Math.max(U1.Vector3.Distance(sc, s1), U1.Vector3.Distance(sc, s2));
                    }
                    if (((lenScreen >= 0.00001) && !isNaN(lenScreen)) && isFinite(lenScreen)) {
                        while (lenScreen > 60) {
                            lenScreen /= 10;
                            lenWorld /= 10;
                            this.m_gridScale /= 10;
                        }
                        while (lenScreen < 2) {
                            var scale = 10;
                            lenScreen *= scale;
                            lenWorld *= scale;
                            this.m_gridScale *= scale;
                        }
                        if (2 <= lenScreen && lenScreen <= 10) {
                            lenScreen *= 5;
                            lenWorld *= 5;
                            this.m_gridScale *= 5;
                        }
                        if (10 < lenScreen && lenScreen < 20) {
                            lenScreen *= 2;
                            lenWorld *= 2;
                            this.m_gridScale *= 2;
                        }
                        var idist = lenWorld;
                        var gridPos = center;
                        gridPos.X = (Math.floor(gridPos.X / idist) * idist);
                        gridPos.Y = (Math.floor(gridPos.Y / idist) * idist);
                        if (Math.abs(U1.Vector3.Dot(U1.Vector3.UnitZ, workingplane.Normal)) < 0.99) {
                            gridPos.Z = (Math.floor(gridPos.Z / idist) * idist);
                            var zAxis = workingplane.Normal;
                            var xAxis, yAxis;
                            U1.GeometryHelper3.GetArbitraryAxis(zAxis, xAxis, yAxis);
                            rm = U1.Matrix4.CreateFromAxes(xAxis, yAxis, zAxis, rm);
                            sm = U1.Matrix4.CreateScaleByFloats(lenWorld, lenWorld, lenWorld, sm);
                            tm = U1.Matrix4.CreateTranslation(gridPos, tm);
                            this._transform
                                .SetMultiply(sm, rm)
                                .Multiply(tm);
                        }
                        else {
                            sm = U1.Matrix4.CreateScaleByFloats(lenWorld, lenWorld, lenWorld, sm);
                            tm = U1.Matrix4.CreateTranslation(gridPos, tm);
                            this._transform.SetMultiply(sm, tm);
                        }
                    }
                    else {
                        var br = 1;
                    }
                }
                super.OnUpdate(context);
            }
            OnDraw(context) {
                if (!this.Visible)
                    return;
            }
            GetLineData() {
                if (this.m_lineData != null)
                    return this.m_lineData;
                var vlist = [];
                var ilist = [];
                var color = U1.Colors.LightGray;
                var gridCount = ScGrid.GridCount;
                var min = -gridCount / 2.0;
                var max = gridCount / 2.0;
                for (var i = 0; i <= gridCount; i++) {
                    var vmin = new U1.Vector3(min + i, min);
                    var vmax = new U1.Vector3(min + i, max);
                    var hmin = new U1.Vector3(min, min + i);
                    var hmax = new U1.Vector3(max, min + i);
                    var idx = vlist.length;
                    vlist.push(new U1.LineVertex(vmin, color));
                    vlist.push(new U1.LineVertex(vmax, color));
                    vlist.push(new U1.LineVertex(hmin, color));
                    vlist.push(new U1.LineVertex(hmax, color));
                    ilist.push(idx);
                    ilist.push(idx + 1);
                    ilist.push(idx + 2);
                    ilist.push(idx + 3);
                }
                this.m_lineData = new U1.LineGeometry();
                this.m_lineData.Points = vlist;
                this.m_lineData.Indexes = ilist;
                return this.m_lineData;
            }
            Initialize() {
            }
        }
        ScGrid.GridCount = 60;
        Views.ScGrid = ScGrid;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScModel extends Views.ScEntity {
            constructor() {
                super();
            }
            get Geometry() {
                return this._geometry;
            }
            set Geometry(value) {
                this._geometry = value;
                this.SetChanged();
            }
            get EdgeGeometry() {
                return this._edgeGeometry;
            }
            set EdgeGeometry(value) {
                this._edgeGeometry = value;
                this.SetChanged();
            }
            UpdateGeometryBounding() {
                this._geometryBBx.CopyFrom(this.Geometry.BoundingBox);
            }
            OnCheckIntersect(isectContext, result) {
                var wm = this.WorldTransform;
                var isect_info = this._geometry.IntersectW(isectContext.Ray, wm);
                return isect_info;
            }
            OnCheckInsideLocal(lplanes, checkCross) {
                var isInside = this._geometry.IsInside(lplanes, checkCross);
                return isInside;
            }
        }
        Views.ScModel = ScModel;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScPoint extends Views.ScEntity {
            constructor() {
                super();
                this._position = U1.Vector3.Zero;
                this._radius = 3;
                this._points = [];
                this._consDivID = null;
                this._style = new Views.ScStyle();
                this._side = 16;
            }
            get ConsDivID() {
                return this._consDivID;
            }
            set ConsDivID(value) {
                this._consDivID = value;
            }
            get Side() {
                return this._side;
            }
            set Side(value) {
                this._side = value;
                this._points.length = 0;
            }
            get Style() {
                return this._style;
            }
            set Style(value) {
                if (value == this._style)
                    return;
                this._style = value;
                this.Invalidate();
            }
            get Position() {
                return this._position;
            }
            set Position(value) {
                if (value != null && !this._position.Equals(value)) {
                    this._position.CopyFrom(value);
                    this.Invalidate();
                }
            }
            get Radius() {
                return this._radius;
            }
            set Radius(value) {
                if (this._radius == value)
                    return;
                this._radius = value;
                this.Invalidate();
            }
            get Points() {
                if (this._points.length == 0) {
                    var x = 0.0;
                    var y = 0.0;
                    var side = this._side;
                    var delt = Math.PI * 2 / side;
                    var ang = 0.0;
                    for (var i = 0; i < side; i++) {
                        ang = delt * i;
                        var p = new U1.Vector3();
                        p.X = Math.cos(ang) * this._radius;
                        p.Y = Math.sin(ang) * this._radius;
                        p.Add(this._position);
                        this._points.push(p);
                    }
                }
                return this._points;
            }
            get Triangles() {
                if (this._triangles == null) {
                    this._triangles = Views.ScPolyLine.Tesselate(this.Points);
                }
                return this._triangles;
            }
            OnCheckIntersect(context, result) {
                let s_;
                s_ = ScPoint[".oci."] || (ScPoint[".oci."] =
                    s_ =
                        {
                            m0: U1.Matrix4.Identity, p0: new U1.Vector3(), p1: new U1.Vector3()
                        });
                var lay = context.Ray;
                var inv_mat = s_.m0;
                var wp = s_.p0.SetTransform(this.Position, this.WorldTransform);
                var wm = this.WorldTransform;
                var ray_point = ScPoint.GetNearestPoint(lay, wp, s_.p1);
                if (context.IsLineIsect(wp, ray_point, this.Radius * 2)) {
                    var isect = result || new U1.ISectInfo();
                    isect.Source = this;
                    isect.IsectNormal = lay.Direction.Clone().Scale(-1);
                    isect.IsectPosition = wp.Clone();
                    return isect;
                }
                return null;
            }
            Invalidate() {
                this._points.length = 0;
                this._triangles = null;
                this.Ver++;
                super.Invalidate();
            }
            static GetNearestPoint(ray, point, res) {
                res = res || new U1.Vector3();
                var v0 = Views.ScEntity.tmp_v30.SetNormalize(ray.Direction);
                var v1 = Views.ScEntity.tmp_v31.SetSubtract(point, ray.Position);
                var t = U1.Vector3.Dot(v0, v1);
                if (t < 0)
                    t = 0;
                var p = res.SetScaleAdd(ray.Position, t, v0);
                return p;
            }
        }
        Views.ScPoint = ScPoint;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScStyle {
            constructor() {
                this._stroke = U1.Colors.Black;
                this._alpha = 1;
                this._strokeThickness = 1;
                this._ver = 0;
                this._id = ScStyle.s_id++;
            }
            get Id() {
                return this._id;
            }
            get Ver() {
                return this._ver;
            }
            get Stroke() {
                return this._stroke;
            }
            set Stroke(value) {
                if (value == null)
                    this._stroke = null;
                else {
                    if (this._stroke == null)
                        this._stroke = value.Clone();
                    else
                        this._stroke.CopyFrom(value);
                }
                this._strokeStr = null;
                this.Invalidate();
            }
            get StrokeStr() {
                if (this._strokeStr == null) {
                    this._strokeStr = this.Stroke.toString();
                }
                return this._strokeStr;
            }
            get Fill() {
                return this._fill;
            }
            set Fill(value) {
                if (value == null)
                    this._fill = null;
                else {
                    if (this._fill == null)
                        this._fill = value.Clone();
                    else
                        this._fill.CopyFrom(value);
                }
                this._fillStr = null;
                this.Invalidate();
            }
            get FillStr() {
                if (this._fillStr == null) {
                    if (this._fill != null)
                        this._fillStr = this._fill.toString();
                    else
                        this._fillStr = "black";
                }
                return this._fillStr;
            }
            get Filled() {
                return this.Fill != null;
            }
            get Alpha() {
                return this._alpha;
            }
            set Alpha(value) {
                this._alpha = value;
                this.Invalidate();
            }
            get StrokeThickness() {
                return this._strokeThickness;
            }
            set StrokeThickness(val) {
                if (this._strokeThickness == val)
                    return;
                this._strokeThickness = val;
            }
            get StrokeDash() {
                return this._strokeDash;
            }
            set StrokeDash(value) {
                this._strokeDash = value;
            }
            Invalidate() {
                this._ver++;
            }
        }
        ScStyle.s_id = 1;
        Views.ScStyle = ScStyle;
        class ScTextStyle extends ScStyle {
            get Background() {
                return this._background;
            }
            set Background(value) {
                if (value == null)
                    this._background = null;
                else {
                    if (this._background == null)
                        this._background = value.Clone();
                    else
                        this._background.CopyFrom(value);
                }
                this._backgroundStr = null;
                this.Invalidate();
            }
            get BackgroundStr() {
                if (this._backgroundStr == null) {
                    if (this._background != null)
                        this._backgroundStr = this._background.toString();
                    else
                        this._backgroundStr = "white";
                }
                return this._backgroundStr;
            }
        }
        Views.ScTextStyle = ScTextStyle;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScText extends Views.ScEntity {
            constructor() {
                super();
                this._fontSize = 1;
                this._height = 1;
                this._width = 10;
                this._style = new Views.ScTextStyle();
                this.IsSingeLine = false;
            }
            get Style() {
                return this._style;
            }
            set Style(value) {
                this._style = value;
            }
            get Text() {
                return this._text;
            }
            set Text(value) {
                this._text = value;
                this._lines = this._text != null ? this._text.split("\n") : [];
                this._max_line_index = 0;
                this._lines.forEach((o_, i_) => {
                    if (this._lines[this._max_line_index].length < o_.length) {
                        this._max_line_index = i_;
                    }
                });
                this.SetChanged();
            }
            get Lines() {
                return this._lines;
            }
            get Width() {
                return this._width;
            }
            set Width(value) {
                if (this._width == value)
                    return;
                this._width = value;
                this.InvalidateBounding();
            }
            get Height() {
                return this._height;
            }
            set Height(value) {
                if (this._height == value)
                    return;
                this._height = value;
                this.InvalidateBounding();
            }
            get ActualWidth() {
                if (this._actualWidth == null) {
                    if (ScText.MeasureTextureWidthFunc != null) {
                        this._actualWidth = 0;
                        this.Lines.forEach(o_ => {
                            var w = ScText.MeasureTextureWidthFunc(o_, this.FontSize);
                            if (w > this._actualWidth) {
                                this._actualWidth = w;
                            }
                        });
                    }
                    else if (this.Container != null && this.Container.Scene != null) {
                        this._actualWidth = 0;
                        this.Lines.forEach(o_ => {
                            var w = this.Container.Scene.MeasureTextureWidth(o_, this.FontSize);
                            if (w > this._actualWidth) {
                                this._actualWidth = w;
                            }
                        });
                    }
                }
                return this._actualWidth;
            }
            get FontSize() {
                return this._fontSize;
            }
            set FontSize(value) {
                if (this._fontSize == value)
                    return;
                this._fontSize = value;
                this.InvalidateBounding();
            }
            SetChanged() {
                super.SetChanged();
                this._actualWidth = null;
            }
            UpdateGeometryBounding() {
                var char_count = 0;
                this.Lines.forEach(o_ => {
                    if (char_count < o_.length)
                        char_count = o_.length;
                });
                var w = this.Height * char_count;
                if (this.ActualWidth != null)
                    w = this.ActualWidth;
                var miny = 0;
                var maxy = miny + this.Height * this.Lines.length;
                this._geometryBBx.Min.Set(0, miny, -1);
                this._geometryBBx.Max.Set(w, maxy, 1);
                this.m_xFormedPath = undefined;
                this.m_wbsphere = undefined;
            }
            Intersect(context) {
                var ray = Views.ScEntity.tmp_r30;
                var invm = Views.ScEntity.tmp_m0;
                var bbx = Views.ScEntity.tmp_bx0;
                var isectp = Views.ScEntity.tmp_v30;
                var v1 = Views.ScEntity.tmp_v31;
                var wm = this.WorldTransform;
                invm.SetInvert(wm);
                ray.CopyFrom(context.Ray).Transform(invm);
                var t = this.BoundingBox.IntersectsRay(ray);
                if (t == null)
                    return null;
                isectp.SetScaleAdd(ray.Position, t, ray.Direction);
                isectp.Transform(wm);
                var isect = new U1.ISectInfo();
                isect.Source = this;
                isect.IsectNormal.SetUnitZ().TransformNormal(wm);
                isect.IsectPosition = isectp;
                isect.Distance = U1.Vector3.Distance(isectp, context.Ray.Position);
                return isect;
            }
            Contains(planes, fCross) {
                if (this.m_xFormedPath == null) {
                    var wm = this.WorldTransform;
                    this.m_xFormedPath = this.BoundingBox.GetCorners()
                        .map(o_ => {
                        return U1.Vector3.Transform(o_, wm);
                    });
                    this.m_xFormedPath.push(this.m_xFormedPath[0]);
                }
                if (this.m_wbsphere == null) {
                    this.m_wbsphere = U1.BoundingSphere.CreateFromPoints(this.m_xFormedPath);
                }
                return U1.LineGeometry.IsInside1(planes, this.m_wbsphere, this.m_xFormedPath, fCross);
            }
        }
        Views.ScText = ScText;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScCamera {
            constructor() {
                this.position = new U1.Vector3(0, 0, 10);
                this.lookat = U1.Vector3.Zero;
                this.up = U1.Vector3.UnitY;
                this.fov = (Math.PI / 4);
                this.near = 0.1;
                this.far = 10000;
                this.orthoheight = 100;
                this.projectionmode = U1.ProjectionTypeEnum.Perspective;
                this.viewport = new Views.Viewport(0, 0, 100, 100, 0, 1);
                this.ver = 0;
                this.ViewProj = U1.Matrix4.Identity;
                this.vpVer = 0;
            }
            GetPosition(result) {
                if (result == null)
                    result = U1.Vector3.Zero;
                result.CopyFrom(this.position);
                return result;
            }
            get Position() {
                return this.position;
            }
            set Position(value) {
                if (isNaN(value.X))
                    return;
                this.position.CopyFrom(value);
                this.ver++;
            }
            GetLookAt(result) {
                if (result == null)
                    result = U1.Vector3.Zero;
                result.CopyFrom(this.lookat);
                return result;
            }
            get LookAt() {
                return this.lookat;
            }
            set LookAt(value) {
                if (isNaN(value.X))
                    return;
                this.lookat.CopyFrom(value);
                this.ver++;
            }
            GetUp(result) {
                if (result == null)
                    result = U1.Vector3.Zero;
                result.CopyFrom(this.up);
                return result;
            }
            get Up() {
                return this.up;
            }
            set Up(value) {
                this.up.CopyFrom(value);
                this.ver++;
            }
            get FOV() {
                return this.fov;
            }
            set FOV(value) {
                this.fov = value;
                this.ver++;
            }
            get Near() {
                return this.near;
            }
            set Near(value) {
                this.near = value;
                this.ver++;
            }
            get Far() {
                return this.far;
            }
            set Far(value) {
                this.far = value;
                this.ver++;
            }
            get OrthoHeight() {
                return this.orthoheight;
            }
            set OrthoHeight(value) {
                this.orthoheight = value;
                this.ver++;
            }
            get ProjectionMode() {
                return this.projectionmode;
            }
            set ProjectionMode(value) {
                this.projectionmode = value;
                this.ver++;
            }
            get ViewportWidth() {
                return this.viewport.Width;
            }
            set ViewportWidth(value) {
                if (this.viewport.Width === value)
                    return;
                this.viewport.Width = value;
                this.ver++;
            }
            get ViewportHeight() {
                return this.viewport.Height;
            }
            set ViewportHeight(value) {
                if (this.viewport.Height === value)
                    return;
                this.viewport.Height = value;
                this.ver++;
            }
            get ViewportX() {
                return this.viewport.X;
            }
            set ViewportX(value) {
                this.viewport.X = value;
                this.ver++;
            }
            get ViewportY() {
                return this.viewport.Y;
            }
            set ViewportY(value) {
                this.viewport.Y = value;
                this.ver++;
            }
            GetFrustum(result = null) {
                if (result == null)
                    result = new U1.BoundingFrustum();
                var m0 = ScCamera[".gfr.m0"] || (ScCamera[".gfr.m0"] = new U1.Matrix4());
                var m1 = ScCamera[".gfr.m1"] || (ScCamera[".gfr.m1"] = new U1.Matrix4());
                var matrix = result.Matrix;
                matrix.SetMultiply(this.GetViewMatrix(m0), this.GetProjMatrix(m1));
                result.Matrix = matrix;
                return result;
            }
            GetRight(result = null) {
                if (result == null)
                    result = U1.Vector3.Zero;
                var dir = ScCamera[".gr.dir"] || (ScCamera[".gr.dir"] = new U1.Vector3());
                dir = this.GetDirection(dir);
                result.SetCross(dir, this.up).Normalize();
                return result;
            }
            GetDirection(result) {
                if (result == null)
                    result = U1.Vector3.Zero;
                result.SetSubtract(this.LookAt, this.Position).Normalize();
                return result;
            }
            get Aspect() {
                if (this.ViewportHeight <= 0)
                    return 1;
                else
                    return this.ViewportWidth / this.ViewportHeight;
            }
            GetViewMatrix(result = null) {
                if (result == null)
                    result = U1.Matrix4.Identity;
                return result.SetCreateLookAt(this.Position, this.LookAt, this.Up);
            }
            GetProjMatrix(result = null) {
                if (result == null)
                    result = U1.Matrix4.Identity;
                if (this.ProjectionMode == U1.ProjectionTypeEnum.Perspective)
                    return result.SetCreatePerspectiveFieldOfView(this.FOV, this.Aspect, this.Near, this.Far);
                else
                    return result.SetCreateOrthographic(this.Aspect * this.OrthoHeight, this.OrthoHeight, this.Near, this.Far);
            }
            static get Default() {
                return new ScCamera();
            }
            CalPickingRay(x, y, result = null) {
                if (result == null)
                    result = new U1.Ray3();
                var m0 = ScCamera[".cpr.m0"] || (ScCamera[".cpr.m0"] = new U1.Matrix4());
                var m1 = ScCamera[".cpr.m1"] || (ScCamera[".cpr.m1"] = new U1.Matrix4());
                var vm = this.GetViewMatrix(m0);
                var pm = this.GetProjMatrix(m1);
                var tv0 = ScCamera[".cpr.tv0"] || (ScCamera[".cpr.tv0"] = new U1.Vector3());
                var tv1 = ScCamera[".cpr.tv1"] || (ScCamera[".cpr.tv1"] = new U1.Vector3());
                var tv2 = ScCamera[".cpr.tv2"] || (ScCamera[".cpr.tv2"] = new U1.Vector3());
                tv0.Set(x, y, 0);
                tv1.Set(x, y, 1);
                tv0 = this.viewport.UnprojectRef(tv0, pm, vm, null, tv0);
                tv1 = this.viewport.UnprojectRef(tv1, pm, vm, null, tv1);
                tv2.SetSubtract(tv1, tv0).Normalize();
                result.Position.CopyFrom(tv0);
                result.Direction.CopyFrom(tv2);
                return result;
            }
            WorldToScreen(wp, result) {
                if (this.vpVer != this.ver) {
                    var vm = ScCamera[".wts.vm"] || (ScCamera[".wts.vm"] = new U1.Matrix4());
                    var pm = ScCamera[".wts.pm"] || (ScCamera[".wts.pm"] = new U1.Matrix4());
                    this.vpVer = this.ver;
                    this.ViewProj.SetMultiply(this.GetViewMatrix(vm), this.GetProjMatrix(pm));
                }
                result = this.viewport.ProjectM(wp, this.ViewProj, result);
                return result;
            }
            ScreenToWorld(sp, result = null) {
                if (result == null)
                    result = U1.Vector3.Zero;
                var m0 = ScCamera[".stw.m0"] || (ScCamera[".stw.m0"] = new U1.Matrix4());
                var m1 = ScCamera[".stw.m1"] || (ScCamera[".stw.m1"] = new U1.Matrix4());
                var vm = this.GetViewMatrix(m0);
                var pm = this.GetProjMatrix(m1);
                result = this.viewport.UnprojectRef(sp, pm, vm, null, result);
                return result;
            }
            GetRotation(targetCamera) {
                var tmp_v0 = ScCamera[".grt.v0"] || (ScCamera[".grt.v0"] = new U1.Vector3());
                var tgt = ScCamera[".grt.tgt"] || (ScCamera[".grt.tgt"] = new U1.Matrix4());
                var src = ScCamera[".grt.src"] || (ScCamera[".grt.src"] = new U1.Matrix4());
                tgt.SetIdentity();
                src.SetIdentity();
                src.Right = this.GetRight(tmp_v0);
                src.Up = this.GetUp(tmp_v0);
                src.Forward = this.GetDirection(tmp_v0);
                tgt.Right = targetCamera.GetRight(tmp_v0);
                tgt.Up = targetCamera.GetUp(tmp_v0);
                tgt.Forward = targetCamera.GetDirection(tmp_v0);
                return ScCamera.GetRotation(src, tgt);
            }
            static GetRotation(src, target) {
                var result = { axis: U1.Vector3.UnitZ, angle: 0, roll: 0 };
                var srcv = src.Backward;
                var tgtv = target.Backward;
                if (Math.abs(src.Backward.Z - target.Backward.Z) < 0.0001) {
                    srcv.Z = tgtv.Z = 0;
                    srcv.Normalize();
                    tgtv.Normalize();
                }
                result.axis.SetCross(srcv, tgtv).Normalize();
                var dt = U1.Vector3.Dot(srcv, tgtv);
                if (dt > 0.999 || dt < -0.999)
                    result.axis = U1.Vector3.UnitZ;
                result.angle = Math.acos(dt);
                src.Multiply(U1.Matrix4.CreateFromAxisAngle(result.axis, result.angle));
                var sr = src.Right;
                var tr = target.Right;
                var n = src.Backward;
                result.roll = U1.GeometryHelper3.AngleCCW(sr, n, tr);
                if (result.roll > Math.PI)
                    result.roll = -(Math.PI * 2 - result.roll);
                return result;
            }
            Roll(roll) {
                var v0 = ScCamera[".rol.v0"] || (ScCamera[".rol.v0"] = new U1.Vector3());
                var v1 = ScCamera[".rol.v1"] || (ScCamera[".rol.v1"] = new U1.Vector3());
                this.Rotate(this.GetPosition(v0), this.GetDirection(v1).Negate(), roll);
            }
            Rotate(pos, axis, ang) {
                if (isNaN(ang)
                    || isNaN(pos.X) || isNaN(pos.Y) || isNaN(pos.Z)
                    || isNaN(axis.X) || isNaN(axis.Y) || isNaN(axis.Z))
                    return;
                axis.Normalize();
                var opp = ScCamera[".rot.opp"] || (ScCamera[".rot.opp"] = new U1.Vector3());
                var m0 = ScCamera[".rot.m0"] || (ScCamera[".rot.m0"] = new U1.Matrix4());
                var m1 = ScCamera[".rot.m1"] || (ScCamera[".rot.m1"] = new U1.Matrix4());
                var m2 = ScCamera[".rot.m2"] || (ScCamera[".rot.m2"] = new U1.Matrix4());
                opp.SetNegate(pos);
                var mat = m0.SetCreateTranslation(opp);
                mat.Multiply(m1.SetCreateFromAxisAngle(axis, ang));
                mat.Multiply(m2.SetCreateTranslation(pos));
                this.position.Transform(mat);
                this.up.TransformNormal(mat);
                this.lookat.Transform(mat);
                this.ver++;
            }
            ScreenToPlane(pt, plane, result) {
                var t_ray = ScCamera[".stp.ray"] || (ScCamera[".stp.ray"] = new U1.Ray3());
                this.CalPickingRay(pt.X, pt.Y, t_ray);
                var t = plane.IntersectsLine(t_ray.Position, t_ray.Direction);
                if (t != null) {
                    if (result == null)
                        result = new U1.Vector3();
                    result.SetScaleAdd(t_ray.Position, t, t_ray.Direction);
                    return result;
                }
                return null;
            }
            Move(offset) {
                this.position.Add(offset);
                this.lookat.Add(offset);
                this.ver++;
            }
            Clone() {
                var camera = new ScCamera();
                camera.position.CopyFrom(this.position);
                camera.lookat.CopyFrom(this.lookat);
                camera.up.CopyFrom(this.up);
                camera.FOV = this.FOV;
                camera.Near = this.Near;
                camera.Far = this.Far;
                camera.OrthoHeight = this.OrthoHeight;
                camera.ProjectionMode = this.ProjectionMode;
                camera.viewport.MaxDepth = this.viewport.MaxDepth;
                camera.viewport.MinDepth = this.viewport.MinDepth;
                camera.viewport.Width = this.viewport.Width;
                camera.viewport.Height = this.viewport.Height;
                camera.viewport.X = this.viewport.X;
                camera.viewport.Y = this.viewport.Y;
                return camera;
            }
            GetCamera(result) {
                result = result || new U1.Camera();
                result.Position.CopyFrom(this.position);
                result.LookAt.CopyFrom(this.lookat);
                result.Up.CopyFrom(this.up);
                result.FOV = this.fov;
                result.Near = this.near;
                result.Far = this.far;
                result.OrthoHeight = this.orthoheight;
                result.ProjectionMode = this.projectionmode;
                result.Viewport.X = this.viewport.X;
                result.Viewport.Y = this.viewport.Y;
                result.Viewport.Width = this.viewport.Width;
                result.Viewport.Height = this.viewport.Height;
                result.Viewport.MaxDepth = this.viewport.MaxDepth;
                result.Viewport.MinDepth = this.viewport.MinDepth;
                return result;
            }
            SetCamera(camera) {
                this.position.CopyFrom(camera.Position);
                this.lookat.CopyFrom(camera.LookAt);
                this.up.CopyFrom(camera.Up);
                this.fov = camera.FOV;
                this.near = camera.Near;
                this.far = camera.Far;
                this.orthoheight = camera.OrthoHeight;
                this.projectionmode = camera.ProjectionMode;
                this.viewport.X = camera.Viewport.X;
                this.viewport.Y = camera.Viewport.Y;
                this.viewport.Width = camera.Viewport.Width;
                this.viewport.Height = camera.Viewport.Height;
                this.viewport.MaxDepth = camera.Viewport.MaxDepth;
                this.viewport.MinDepth = camera.Viewport.MinDepth;
                return this;
            }
        }
        Views.ScCamera = ScCamera;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScResource {
            constructor() {
                this.Ver = 0;
                this.UpdateVer = -1;
            }
            get Container() {
                return this._container;
            }
            get Name() {
                return this._name;
            }
            set Name(value) {
                if (this._name !== undefined)
                    throw "name is not null";
                this._name = value;
            }
            get Scene() {
                return this.Container.Scene;
            }
            get IsDisposed() {
                return this._isDisposed;
            }
            OnUpdate(context) {
            }
            Dispose() {
                if (this._isDisposed)
                    return;
                this.OnDisposing();
                if (this._container != null) {
                    this._container.Remove(this);
                    this._container = undefined;
                }
            }
            OnDisposing() {
            }
        }
        Views.ScResource = ScResource;
        class ScResourceContainer {
            constructor(scene) {
                this._scene = scene;
            }
            get Scene() {
                return this._scene;
            }
            Remove(res) {
            }
        }
        Views.ScResourceContainer = ScResourceContainer;
        class ScResourceContainerTyped extends ScResourceContainer {
            GetOrAdd(c, name) {
                if (this.Resources == null) {
                    this.Resources = {};
                }
                if (this.Resources[name] == null) {
                    return this.Add(c, name);
                }
                return this.Resources[name];
            }
            Get(c, name) {
                if (this.Resources != null && this.Resources[name] instanceof c)
                    return this.Resources[name];
                return null;
            }
            Add(c, name) {
                if (this.Resources != null && this.Resources[name] !== undefined)
                    throw "Same name exists";
                var ch = this.Scene.newResource(c);
                if (ch == null)
                    return null;
                ch.Name = name;
                ch["_container"] = this;
                if (this.Resources == null) {
                    this.Resources = {};
                }
                this.Resources[name] = ch;
                return ch;
            }
            Remove(entity) {
                if (this.Resources == null)
                    return;
                delete this.Resources[entity.Name];
            }
            Clear() {
                this.Resources = null;
            }
            Update(context) {
                if (this.Resources == null)
                    return;
                for (var id in this.Resources) {
                    this.Resources[id].OnUpdate(context);
                }
            }
        }
        Views.ScResourceContainerTyped = ScResourceContainerTyped;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScMaterial extends Views.ScResource {
            constructor() {
                super(...arguments);
                this.Diffuse = U1.Colors.Gray;
                this.DiffuseTexture = new Views.ScTexture();
                this.Alpha = 1;
            }
        }
        Views.ScMaterial = ScMaterial;
        class ScMultiMaterial extends ScMaterial {
            constructor(materials) {
                super();
                this.Materials = materials instanceof Array ? materials : [];
            }
        }
        Views.ScMultiMaterial = ScMultiMaterial;
        class ScMaterialContainer extends Views.ScResourceContainerTyped {
            constructor(scene) {
                super(scene);
            }
        }
        Views.ScMaterialContainer = ScMaterialContainer;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class ScTexture extends Views.ScResource {
        }
        Views.ScTexture = ScTexture;
        class ScTextureContainer extends Views.ScResourceContainerTyped {
            constructor(scene) {
                super(scene);
            }
        }
        Views.ScTextureContainer = ScTextureContainer;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class UElementPresenter {
            constructor() {
                this.Invalid = true;
                this._isDisposed = false;
                this._isSelected = false;
            }
            Visible() {
                return true;
            }
            get Element() {
                return this._element;
            }
            set Element(value) {
                this._element = value;
            }
            get IsSelected() {
                return this._isSelected;
            }
            set IsSelected(value) {
                if (this._isSelected == value)
                    return;
                this._isSelected = value;
                if (this._isSelected)
                    this.OnSelected();
                else
                    this.OnDeselected();
            }
            get ShowBoundingBox() {
                return true;
            }
            get CanMove() {
                return false;
            }
            OnSelected() {
            }
            OnDeselected() {
            }
            get View() {
                if (this.DocumentPresesnter != null)
                    return this.DocumentPresesnter.View;
                return null;
            }
            get Scene() {
                return this.View.Scene;
            }
            get IsDisposed() {
                return this._isDisposed;
            }
            Update() {
                this.LastVisible = this.Visible();
                this.OnUpdate();
            }
            OnUpdate() {
            }
            Dispose() {
                if (this._isDisposed)
                    return;
                if (this.Element == null)
                    return;
                this.OnClear();
                this.Element = null;
                this._isDisposed = true;
            }
            OnClear() {
            }
            OnElementPropertyChanged(sender, prop) {
                this.Invalid = true;
                this.View.Invalidate();
            }
            CheckIntersect(isectContext) {
                return null;
            }
            CheckContains(containContext) {
                return false;
            }
        }
        UElementPresenter.SelectStrokeColor = U1.Colors.Red;
        UElementPresenter.SelectFillColor = new U1.Color(255, 200, 200, 100);
        Views.UElementPresenter = UElementPresenter;
        class UElementPresenter3D extends UElementPresenter {
            constructor() {
                super(...arguments);
                this._obb = new U1.OrientedBox3();
                this._lbb = new U1.BoundingBox();
                this._wsp = new U1.BoundingSphere();
                this._obbInvalid = true;
                this._lbbInvalid = true;
                this._wspInvalid = true;
                this._xform = U1.Matrix4.Identity;
            }
            get Transform() {
                return this._xform;
            }
            set Transform(value) {
                this._xform = value;
                this._obbInvalid = true;
                this.InvalidateWorldBounding();
            }
            get LBB() {
                if (this._lbb == null || this._lbbInvalid) {
                    this.UpdateBoundingBox();
                    this._lbbInvalid = false;
                }
                return this._lbb;
            }
            get WSP() {
                if (this._wsp == null || this._wspInvalid) {
                    this.UpdateBoundingBox();
                    this._wspInvalid = false;
                }
                return this._wsp;
            }
            get OBB() {
                if (this._obb == null || this._obbInvalid) {
                    var obb = this._obb || new U1.OrientedBox3();
                    var tm = this.Transform;
                    var bbx = this.LBB;
                    var hsize = U1.Vector3.Subtract(bbx.Max, bbx.Min).Scale(1.0 / 2.0);
                    var xAxis = obb.Axes[0].SetUnitX().TransformNormal(tm).Normalize();
                    var yAxis = obb.Axes[1].SetUnitY().TransformNormal(tm).Normalize();
                    var zAxis = obb.Axes[2].SetUnitZ().TransformNormal(tm).Normalize();
                    var cent = U1.Vector3.Add(bbx.Max, bbx.Min, obb.Center).Scale(1.0 / 2.0);
                    var xp = new U1.Vector3(hsize.X, 0, 0).Add(cent).Transform(tm);
                    var yp = new U1.Vector3(0, hsize.Y, 0).Add(cent).Transform(tm);
                    var zp = new U1.Vector3(0, 0, hsize.Z).Add(cent).Transform(tm);
                    cent.Transform(tm);
                    obb.Extents = [
                        U1.Vector3.Distance(xp, cent),
                        U1.Vector3.Distance(yp, cent),
                        U1.Vector3.Distance(zp, cent)
                    ];
                    this._obb = obb;
                    this._obbInvalid = undefined;
                }
                return this._obb;
            }
            AddTransform(matrix) {
            }
            UpdateBoundingBox() {
            }
            Visible() {
                return true;
            }
            get CanMove() {
                if (this.IsFreezed)
                    return false;
                return true;
            }
            get CanMovePivot() {
                if (this.IsFreezed)
                    return false;
                return false;
            }
            get CanRotate() {
                if (this.IsFreezed)
                    return false;
                return false;
            }
            get CanScale() {
                if (this.IsFreezed)
                    return false;
                return false;
            }
            BeginTransform() {
                this.m_isTransforming = true;
                this.m_baseOBB = this.OBB.Clone();
            }
            EndTransform() {
                this.m_isTransforming = false;
                this.m_baseOBB = null;
                this._obbInvalid = true;
                this._wspInvalid = true;
                this._obbInvalid = true;
            }
            OnStartMove() {
                this.BeginTransform();
            }
            OnMove(tc) {
                if (this.m_baseOBB != null)
                    this._obb = U1.OrientedBox3.Translate(this.m_baseOBB, tc.Offset);
            }
            OnEndMove(tc) {
                this.EndTransform();
            }
            OnCancelMove() {
                this.EndTransform();
            }
            OnStartRotate() {
                this.BeginTransform();
            }
            OnRotate(rc) {
                if (this.m_baseOBB != null)
                    this._obb.SetTransform(this.m_baseOBB, rc.RM);
            }
            OnEndRotate(rc) {
                this.EndTransform();
            }
            OnCancelRotate() {
                this.EndTransform();
            }
            OnStartScale() {
                this.BeginTransform();
            }
            OnScale(sc) {
                if (this.m_baseOBB != null)
                    this._obb = U1.OrientedBox3.Scale(this.m_baseOBB, sc.Base, sc.From, sc.To);
            }
            OnEndScale(sc) {
                this.EndTransform();
            }
            OnCancelScale() {
                this.EndTransform();
            }
            OnMouseMove(ev) {
                return false;
            }
            OnMouseUp(ev) {
                return false;
            }
            OnMouseDown(ev) {
                return false;
            }
            OnMouseWheel(ev) {
                return false;
            }
            InvalidateBounding() {
                this._lbbInvalid = true;
                this._wspInvalid = true;
                this._obbInvalid = true;
            }
            InvalidateWorldBounding() {
                this._wspInvalid = true;
                this._obbInvalid = true;
            }
            OnElementPropertyChanged(sender, prop) {
                super.OnElementPropertyChanged(sender, prop);
                this.InvalidateBounding();
            }
        }
        Views.UElementPresenter3D = UElementPresenter3D;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class Scene {
            constructor(view) {
                this._camera = new Views.ScCamera();
                this.Light1 = new U1.Light();
                this.Light2 = new U1.Light();
                this.Light3 = new U1.Light();
                this.World = new Views.ScWorld(this);
                this.Overlay = new Views.ScOverlayWorld(this);
                this.Screen = new Views.ScScreenWorld(this);
                this.QualityLevel = 0;
                this.MinimumVolumnVisibleSize = 4;
                this.Textures = new Views.ScTextureContainer(this);
                this.Materials = new Views.ScMaterialContainer(this);
                this.ClearColor = U1.Colors.White;
                this._view = view;
                this._camera.OrthoHeight = 4000;
                this._camera.Position = new U1.Vector3(0, -10, 10);
                this._camera.LookAt = U1.Vector3.Zero;
                this._camera.Up = new U1.Vector3(0, 1, 1).Normalize();
                this.Light1.Diffuse = new U1.Color(200, 200, 200);
                this.Light1.Direction.Set(-1, 1, -1);
                this.Light2.Diffuse = new U1.Color(200, 200, 200);
                this.Light2.Direction.Set(1, 1, -1);
                this.Light3.Diffuse = new U1.Color(100, 100, 100);
            }
            get View() {
                return this._view;
            }
            get Camera() {
                return this._camera;
            }
            Update() {
                this.OnBeginUpdate();
                this.Camera.ViewportWidth = this.View.Width;
                this.Camera.ViewportHeight = this.View.Height;
                this.Camera.GetDirection(this.Light3.Direction);
                var context = this.CreateUpdateContext();
                context.WorldCamera = this.Camera;
                context.setProjM(this.Camera.GetProjMatrix());
                context.setViewM(this.Camera.GetViewMatrix());
                context.setWorldM(U1.Matrix4.Identity);
                context.ViewFrustum = this.Camera.GetFrustum();
                context.setViewProjM(U1.Matrix4.Multiply(context.getViewM(), context.getProjM()));
                context.setView(this.View);
                this.Textures.Update(context);
                this.Materials.Update(context);
                context.IsScreenSpace = false;
                context.IsOveraySpace = false;
                this.World.Update(context);
                context.IsOveraySpace = true;
                this.Overlay.Update(context);
                context.IsScreenSpace = true;
                this.Screen.Update(context);
                this.OnEndUpdate();
            }
            Draw() {
                this.Camera.ViewportWidth = this.View.Width;
                this.Camera.ViewportHeight = this.View.Height;
                this.OnBeginDraw(context);
                var context = this.CreateDrawContext();
                context.Scene = this;
                context.IsScreenSpace = false;
                context.IsOveraySpace = false;
                context.WorldCamera = this.Camera;
                context.setProjM(this.Camera.GetProjMatrix());
                context.setViewM(this.Camera.GetViewMatrix());
                context.setWorldM(U1.Matrix4.Identity);
                context.ViewFrustum = this.Camera.GetFrustum();
                context.setViewProjM(U1.Matrix4.Multiply(context.getViewM(), context.getProjM()));
                context.setView(this.View);
                this.World.Draw(context);
                context.IsOveraySpace = true;
                this.Overlay.Draw(context);
                context.IsScreenSpace = true;
                this.Screen.Draw(context);
                this.OnEndDraw(context);
            }
            Clear() {
                this.World.Clear();
                this.Overlay.Clear();
                this.Screen.Clear();
                this.Textures.Clear();
                this.Materials.Clear();
            }
            CreateDrawContext() {
                var ctx = new Views.DrawContext();
                ctx.Scene = this;
                return ctx;
            }
            CreateUpdateContext() {
                var ctx = new Views.UpdateContext();
                ctx.Scene = this;
                return ctx;
            }
            OnBeginUpdate() {
            }
            OnEndUpdate() {
            }
            OnBeginDraw(context) {
            }
            OnEndDraw(context) {
            }
            MeasureTextureWidth(text, fontsize) {
                return text.length * fontsize;
            }
            newEntity(ctor) {
                return new ctor();
            }
            newResource(ctor) {
                return new ctor();
            }
        }
        Views.Scene = Scene;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class DefaultTool extends Views.VcTool {
            constructor() {
                super();
                this.isPanning = false;
            }
            OnAttach(view) {
                super.OnAttach(view);
            }
            OnDetach(view) {
                super.OnDetach(view);
            }
            OnMouseMove(ev) {
                if (this.View.IsMouseDown) {
                    if (!this.isPanning) {
                        var dist = U1.Vector2.Distance(this.View.OldDn, this.View.CurMv);
                        if (dist > 4) {
                            this.isPanning = true;
                        }
                    }
                    if (this.isPanning)
                        this.View.PanPlane(this.View.WorkingPlane, this.View.OldMv, this.View.CurMv);
                    return true;
                }
                else {
                    this.isPanning = false;
                }
                return super.OnMouseMove(ev);
            }
            OnMouseUp(ev) {
                this.isPanning = false;
                if (ev.button === 0 || ev.buttons === 1) {
                    var res = this.View.Pick(this.View.CurDn);
                    this.View.ActiveControl = null;
                    if (res != null && res.Node != null && res.Node.Control != null) {
                        var vc = res.Node.Control;
                        vc.OnMouseUp(ev);
                    }
                    else if (res != null && res.Control != null) {
                        var vc = res.Control;
                        vc.OnMouseUp(ev);
                    }
                    return true;
                }
                return super.OnMouseUp(ev);
            }
            OnMouseDown(ev) {
                if (ev.button === 0 || ev.buttons === 1) {
                    var res = this.View.Pick(this.View.CurDn);
                    this.View.ActiveControl = null;
                    if (res != null && res.Node != null && res.Node.Presenter != null) {
                        this.View.Document.Selection.Add(res.Node.Presenter.Element, true);
                    }
                    else if (res != null && res.Node != null && res.Node.Control != null) {
                        var vc = res.Node.Control;
                        vc.OnMouseDown(ev);
                    }
                    else if (res != null && res.Control != null) {
                        var vc = res.Control;
                        vc.OnMouseDown(ev);
                    }
                    else {
                        this.View.Document.Selection.Clear();
                    }
                    return true;
                }
                return super.OnMouseDown(ev);
            }
            OnMouseWheel(ev) {
                var delta = ev.wheelDelta ? ev.wheelDelta : -ev.detail;
                this.View.ZoomView(this.View.CurMv, delta);
                return true;
            }
            OnPanMove(ev) {
                this.View.PanPlane(this.View.WorkingPlane, this.View.OldMv, this.View.CurMv);
                return true;
            }
            OnPanStart(ev) {
                return false;
            }
            OnPanEnd(ev) {
                return false;
            }
            OnPinch(ev) {
                return false;
            }
            OnTouchStart(ev) {
                return false;
            }
            OnTouchMove(ev) {
                this.View.PanPlane(this.View.WorkingPlane, this.View.OldMv, this.View.CurMv);
                return true;
            }
            OnTouchEnd(ev) {
                return false;
            }
            Finish() {
                this.View.ActiveTool = null;
            }
        }
        Views.DefaultTool = DefaultTool;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class USectionView extends Views.ViewBase {
            constructor() {
                super(...arguments);
                this._viewInfo = new Views.SectionViewInfo();
                this._viewVersion = -1;
                this._viewportHeight = 0;
                this._viewportCent = U1.Vector2.Zero;
            }
            USectionView() {
                this.RenderingMode = Views.URenderingMode.RemoveHiddenLine;
                this.ShowNavigater = false;
            }
            get ViewInfo() {
                return this._viewInfo;
            }
            set ViewInfo(value) {
                this._viewInfo = value;
                this._viewVersion = -1;
                this.Invalidate();
            }
            HomeView(wbbx) {
                this.ZoomFit(wbbx);
                return;
            }
            OnBeginUpdate() {
                var scnCamera = this.Scene.Camera;
                var viewinfo = this.ViewInfo;
                this.UpdateViewport2D();
                scnCamera.Up = viewinfo.Up;
                scnCamera.Position = U1.Vector3.Add(viewinfo.Position, viewinfo.Direction);
                scnCamera.LookAt = U1.Vector3.ScaleAdd(viewinfo.Position, 1000, viewinfo.Direction);
                scnCamera.ProjectionMode = U1.ProjectionTypeEnum.Orthographic;
                this._viewVersion = viewinfo.Version;
                var offset = U1.Vector3.Scale(viewinfo.AXIS_X, this._viewportCent.X);
                offset = U1.Vector3.Add(offset, U1.Vector3.Scale(viewinfo.AXIS_Y, this._viewportCent.Y));
                scnCamera.Position.Add(offset);
                scnCamera.LookAt.Add(offset);
                if (this.old_z != null && U1.Vector3.Dot(scnCamera.Up, U1.Vector3.UnitZ) > 0.99) {
                    var pos = scnCamera.Position;
                    var lookat = scnCamera.LookAt;
                    pos.Z = this.old_z;
                    lookat.Z = this.old_z;
                    scnCamera.Position = pos;
                    scnCamera.LookAt = lookat;
                }
                this.WorkingPlane = U1.Plane.FromPointNormal(U1.Vector3.ScaleAdd(viewinfo.Position, viewinfo.Depth, viewinfo.Direction), U1.Vector3.Scale(viewinfo.Direction, -1));
                this.old_z = scnCamera.Position.Z;
                super.OnBeginUpdate();
            }
            Orbit(delt) {
            }
            RotateView(epos, axis, p) {
            }
            UpdateViewport2D() {
                var scnCamera = this.Scene.Camera;
                var c_x = U1.Vector3.Dot(this.ViewInfo.AXIS_X, scnCamera.LookAt);
                var c_y = U1.Vector3.Dot(this.ViewInfo.AXIS_Y, scnCamera.LookAt);
                this._viewportHeight = this.Scene.Camera.OrthoHeight;
                this._viewportCent = new U1.Vector2(c_x, c_y);
            }
        }
        Views.USectionView = USectionView;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class Viewport {
            constructor(x = 0, y = 0, w = 0, h = 0, min = 0, max = 1) {
                this.X = x;
                this.Y = y;
                this.Width = w,
                    this.Height = h;
                this.MinDepth = min;
                this.MaxDepth = max;
            }
            ConvertFromStr(value) {
                if (value == null)
                    return;
                var items = value.split(",");
                this.X = items.length > 0 ? parseFloat(items[0]) : 0;
                this.Y = items.length > 1 ? parseFloat(items[1]) : 0;
                this.Width = items.length > 2 ? parseFloat(items[2]) : 0;
                this.Height = items.length > 3 ? parseFloat(items[3]) : 0;
                this.MinDepth = items.length > 4 ? parseFloat(items[4]) : 0;
                this.MaxDepth = items.length > 5 ? parseFloat(items[5]) : 0;
            }
            ConvertToStr() {
                return "" + this.X + "," + this.Y + "," + this.Width + "," + this.Height + "," + this.MinDepth + "," + this.MaxDepth;
            }
            Equals(other) {
                return this.X == other.X &&
                    this.Y == other.Y &&
                    this.MinDepth == other.MinDepth &&
                    this.MaxDepth == other.MaxDepth &&
                    this.Width == other.Width &&
                    this.Height == other.Height;
            }
            Project(source, projection, view, world) {
                var matrix = Viewport.tmp_m0.SetMultiply(world, view).Multiply(projection);
                var vector = U1.Vector3.Transform(source, matrix);
                var a = (((source.X * matrix.M14) + (source.Y * matrix.M24)) + (source.Z * matrix.M34)) + matrix.M44;
                if (!U1.WithinEpsilon(a, 1)) {
                    vector.Scale(1 / a);
                }
                vector.X = (((vector.X + 1) * 0.5) * this.Width) + this.X;
                vector.Y = (((-vector.Y + 1) * 0.5) * this.Height) + this.Y;
                vector.Z = (vector.Z * (this.MaxDepth - this.MinDepth)) + this.MinDepth;
                return vector;
            }
            ProjectRef(source, projection, view, world, ref) {
                Viewport.tmp_m0.SetMultiply(world, view).Multiply(projection);
                var a = source.X * Viewport.tmp_m0.M14
                    + source.Y * Viewport.tmp_m0.M24
                    + source.Z * Viewport.tmp_m0.M34
                    + Viewport.tmp_m0.M44;
                ref.SetTransform(source, Viewport.tmp_m0);
                if (!U1.WithinEpsilon(a, 1)) {
                    ref.Scale(1 / a);
                }
                ref.X = (((ref.X + 1) * 0.5) * this.Width) + this.X;
                ref.Y = (((-ref.Y + 1) * 0.5) * this.Height) + this.Y;
                ref.Z = (ref.Z * (this.MaxDepth - this.MinDepth)) + this.MinDepth;
                return ref;
            }
            ProjectM(source, matrix, result) {
                result = result || new U1.Vector3();
                var a = (((source.X * matrix.M14) + (source.Y * matrix.M24)) + (source.Z * matrix.M34)) + matrix.M44;
                result = U1.Vector3.Transform(source, matrix, result);
                if (!U1.WithinEpsilon(a, 1)) {
                    result.Scale(1 / a);
                }
                result.X = ((((result.X + 1) * 0.5) * this.Width) + this.X);
                result.Y = ((((-result.Y + 1) * 0.5) * this.Height) + this.Y);
                result.Z = (result.Z * (this.MaxDepth - this.MinDepth)) + this.MinDepth;
                return result;
            }
            Unproject(source, projection, view, world) {
                var matrix = Viewport.tmp_m0.SetMultiply(world, view).Multiply(projection).Invert();
                var srcr = Viewport.tmp_v30.CopyFrom(source);
                srcr.X = (((srcr.X - this.X) / (this.Width)) * 2) - 1;
                srcr.Y = -((((srcr.Y - this.Y) / (this.Height)) * 2) - 1);
                srcr.Z = (srcr.Z - this.MinDepth) / (this.MaxDepth - this.MinDepth);
                var a = (((srcr.X * matrix.M14) + (srcr.Y * matrix.M24)) + (srcr.Z * matrix.M34)) + matrix.M44;
                var vector = U1.Vector3.Transform(source, matrix);
                if (!U1.WithinEpsilon(a, 1)) {
                    vector.Scale(1 / a);
                }
                return vector.Clone();
            }
            UnprojectRef(source, projection, view, world, ref) {
                var matrix = Viewport.tmp_m0
                    .SetMultiply(world, view)
                    .Multiply(projection)
                    .Invert();
                var srcr = Viewport.tmp_v30.CopyFrom(source);
                srcr.X = (((srcr.X - this.X) / (this.Width)) * 2) - 1;
                srcr.Y = -((((srcr.Y - this.Y) / (this.Height)) * 2) - 1);
                srcr.Z = (srcr.Z - this.MinDepth) / (this.MaxDepth - this.MinDepth);
                var a = (((srcr.X * matrix.M14) + (srcr.Y * matrix.M24)) + (srcr.Z * matrix.M34)) + matrix.M44;
                ref.SetTransform(srcr, matrix);
                if (!U1.WithinEpsilon(a, 1)) {
                    ref.Scale(1 / a);
                }
                return ref;
            }
            get AspectRatio() {
                if ((this.Height != 0) && (this.Width != 0)) {
                    return ((this.Width) / (this.Height));
                }
                return 0;
            }
        }
        Viewport.tmp_v30 = U1.Vector3.Zero;
        Viewport.tmp_v31 = U1.Vector3.Zero;
        Viewport.tmp_v32 = U1.Vector3.Zero;
        Viewport.tmp_v33 = U1.Vector3.Zero;
        Viewport.tmp_m0 = U1.Matrix4.Identity;
        Viewport.tmp_m1 = U1.Matrix4.Identity;
        Viewport.tmp_m2 = U1.Matrix4.Identity;
        Viewport.tmp_m3 = U1.Matrix4.Identity;
        Viewport.tmp_m4 = U1.Matrix4.Identity;
        Views.Viewport = Viewport;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class SectionViewInfo {
            constructor() {
                this._isPlaneInvalid = true;
                this._planes = [
                    new U1.Plane(),
                    new U1.Plane(),
                    new U1.Plane(),
                    new U1.Plane(),
                    new U1.Plane(),
                    new U1.Plane(),
                ];
                this._position = new U1.Vector3(0, 0, 100);
                this._direction = new U1.Vector3(0, 0, -1);
                this._up = U1.Vector3.UnitY;
                this._width = 100;
                this._height = 100;
                this._depth = 1000;
                this._version = 0;
            }
            get Position() {
                return this._position;
            }
            set Position(value) {
                this._position = value;
                this._isPlaneInvalid = true;
                this._version++;
            }
            get Direction() { return this._direction; }
            set Direction(value) {
                this._direction = value;
                this._isPlaneInvalid = true;
                this._version++;
            }
            get Up() { return this._up; }
            set Up(value) {
                this._up = value;
                this._isPlaneInvalid = true;
                this._version++;
            }
            get Width() { return this._width; }
            set Width(value) {
                this._width = value;
                this._isPlaneInvalid = true;
                this._version++;
            }
            get Height() { return this._height; }
            set Height(value) {
                this._height = value;
                this._isPlaneInvalid = true;
                this._version++;
            }
            get Depth() { return this._depth; }
            set Depth(value) {
                this._depth = value;
                this._isPlaneInvalid = true;
                this._version++;
            }
            get Planes() {
                if (this._isPlaneInvalid) {
                    this.UpdatePlanes();
                }
                return this._planes;
            }
            get NearPlane() {
                if (this._isPlaneInvalid)
                    this.UpdatePlanes();
                return this._planes[0];
            }
            get FarPlane() {
                if (this._isPlaneInvalid)
                    this.UpdatePlanes();
                return this._planes[1];
            }
            get LeftPlane() {
                if (this._isPlaneInvalid)
                    this.UpdatePlanes();
                return this._planes[2];
            }
            get RightPlane() {
                if (this._isPlaneInvalid)
                    this.UpdatePlanes();
                return this._planes[3];
            }
            get TopPlane() {
                if (this._isPlaneInvalid)
                    this.UpdatePlanes();
                return this._planes[4];
            }
            get DownPlane() {
                if (this._isPlaneInvalid)
                    this.UpdatePlanes();
                return this._planes[5];
            }
            get AXIS_Z() {
                return U1.Vector3.Scale(this.Direction, -1).Normalize();
            }
            get AXIS_X() {
                var right = U1.Vector3.Normalize(U1.Vector3.Cross(this.Up, this.AXIS_Z));
                return right;
            }
            get AXIS_Y() {
                return U1.Vector3.Normalize(U1.Vector3.Cross(this.AXIS_Z, this.AXIS_X));
            }
            get Matrix() {
                return U1.Matrix4.CreateFromAxes(this.AXIS_X, this.AXIS_Y, this.AXIS_Z);
            }
            get Version() {
                return this._version;
            }
            Clone() {
                var result = new SectionViewInfo();
                result._isPlaneInvalid = this._isPlaneInvalid;
                result._planes = this._planes != null ? this._planes : null;
                result._position = this._position;
                result._direction = this._direction;
                result._up = this._up;
                result._width = this._width;
                result._height = this._height;
                result._depth = this._depth;
                result._version = this._version;
                return result;
            }
            UpdatePlanes() {
                this._isPlaneInvalid = false;
                var front = U1.Vector3.Scale(this.AXIS_Z, -1);
                var back = this.AXIS_Z;
                var up = this.AXIS_Y;
                var down = U1.Vector3.Scale(this.AXIS_Y, -1);
                var left = U1.Vector3.Scale(this.AXIS_X, -1);
                var right = this.AXIS_X;
                this._planes[0] = U1.Plane.FromPointNormal(this.Position, back);
                this._planes[1] = U1.Plane.FromPointNormal(U1.Vector3.ScaleAdd(this.Position, this.Depth, front), front);
                this._planes[2] = U1.Plane.FromPointNormal(U1.Vector3.ScaleAdd(this.Position, this.Width / 2, left), left);
                this._planes[3] = U1.Plane.FromPointNormal(U1.Vector3.ScaleAdd(this.Position, this.Width / 2, right), right);
                this._planes[4] = U1.Plane.FromPointNormal(U1.Vector3.ScaleAdd(this.Position, this.Height / 2, up), up);
                this._planes[5] = U1.Plane.FromPointNormal(U1.Vector3.ScaleAdd(this.Position, this.Height / 2, down), down);
            }
            Contains(sphere) {
                var center = sphere.Center;
                var radius = sphere.Radius;
                var num2 = 0;
                var planes = [
                    this.NearPlane,
                    this.FarPlane,
                    this.LeftPlane,
                    this.RightPlane,
                    this.TopPlane,
                    this.DownPlane
                ];
                var result = U1.ContainmentType.Contains;
                for (var plane of planes) {
                    var doot_coord = ((plane.Normal.X * center.X) + (plane.Normal.Y * center.Y)) + (plane.Normal.Z * center.Z);
                    var num3 = doot_coord + plane.D;
                    if (num3 > radius) {
                        return U1.ContainmentType.Disjoint;
                    }
                    if (num3 < -radius) {
                        num2++;
                    }
                }
                result = (num2 == 6) ? U1.ContainmentType.Contains : U1.ContainmentType.Intersects;
                return result;
            }
        }
        Views.SectionViewInfo = SectionViewInfo;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    let UVariantTypes;
    (function (UVariantTypes) {
        UVariantTypes[UVariantTypes["Number"] = 0] = "Number";
        UVariantTypes[UVariantTypes["Bool"] = 1] = "Bool";
        UVariantTypes[UVariantTypes["String"] = 2] = "String";
        UVariantTypes[UVariantTypes["Vector"] = 3] = "Vector";
        UVariantTypes[UVariantTypes["Matrix"] = 4] = "Matrix";
    })(UVariantTypes = U1.UVariantTypes || (U1.UVariantTypes = {}));
    let UOperationType;
    (function (UOperationType) {
        UOperationType[UOperationType["None"] = 0] = "None";
        UOperationType[UOperationType["Logical_Or"] = 1] = "Logical_Or";
        UOperationType[UOperationType["Logical_And"] = 2] = "Logical_And";
        UOperationType[UOperationType["Equal"] = 3] = "Equal";
        UOperationType[UOperationType["NotEqual"] = 4] = "NotEqual";
        UOperationType[UOperationType["Less"] = 5] = "Less";
        UOperationType[UOperationType["Great"] = 6] = "Great";
        UOperationType[UOperationType["LessEqual"] = 7] = "LessEqual";
        UOperationType[UOperationType["GreatEqual"] = 8] = "GreatEqual";
        UOperationType[UOperationType["Add"] = 9] = "Add";
        UOperationType[UOperationType["Sub"] = 10] = "Sub";
        UOperationType[UOperationType["Multiply"] = 11] = "Multiply";
        UOperationType[UOperationType["Divide"] = 12] = "Divide";
        UOperationType[UOperationType["Parenthesis"] = 13] = "Parenthesis";
        UOperationType[UOperationType["Dot"] = 14] = "Dot";
        UOperationType[UOperationType["Index"] = 15] = "Index";
    })(UOperationType = U1.UOperationType || (U1.UOperationType = {}));
    class UVariant {
        constructor() {
            this.VariantType = UVariantTypes.Number;
            this._value = 0.0;
        }
        get Value() {
            return this._value;
        }
        set Value(val) {
            this._value = val;
        }
        static get Zero() {
            var expvar = new UVariant();
            expvar.VariantType = UVariantTypes.Number;
            expvar.Value = 0.0;
            return expvar;
        }
        SetNumber(value) {
            this.VariantType = UVariantTypes.Number;
            this._value = value;
            return this;
        }
        SetBool(value) {
            this.VariantType = UVariantTypes.Bool;
            this._value = value;
            return this;
        }
        SetString(value) {
            this.VariantType = UVariantTypes.String;
            this._value = value;
            return this;
        }
        SetVector(value) {
            this.VariantType = UVariantTypes.Vector;
            this._value = value;
            return this;
        }
        SetMatrix(value) {
            this.VariantType = UVariantTypes.Matrix;
            this._value = value;
            return this;
        }
        CopyFrom(src) {
            this.VariantType = src.VariantType;
            if (this.VariantType == UVariantTypes.Vector)
                this._value = src.Value.slice();
            else
                this._value = src.Value;
            return this;
        }
        SetColor(color) {
            this.VariantType = UVariantTypes.Vector;
            this._value = [
                color.R,
                color.G,
                color.B,
                color.A
            ];
            return this;
        }
        SetVector2(vector) {
            this.VariantType = UVariantTypes.Vector;
            this._value = [
                vector.X,
                vector.Y
            ];
            return this;
        }
        SetVector3(vector) {
            this.VariantType = UVariantTypes.Vector;
            this._value = [
                vector.X,
                vector.Y,
                vector.Z
            ];
            return this;
        }
        SetVector4(vector) {
            this.VariantType = UVariantTypes.Vector;
            this._value = [
                vector.X,
                vector.Y,
                vector.Z,
                vector.W
            ];
            return this;
        }
        get ItemCount() {
            if (this.VariantType == UVariantTypes.Vector)
                return this.Value.length;
            return 0;
        }
        GetNumber() {
            if (this.VariantType == UVariantTypes.Number)
                return this.Value;
            if (this.VariantType == UVariantTypes.Bool)
                return this.Value ? 1 : 0;
            if (this.VariantType == UVariantTypes.String)
                return this.Value.length > 0 ? 1 : 0;
            return 0;
        }
        GetBool() {
            if (this.VariantType == UVariantTypes.Number)
                return this.Value != 0;
            if (this.VariantType == UVariantTypes.Bool)
                return this.Value;
            if (this.VariantType == UVariantTypes.String)
                return this.Value.length > 0;
            return false;
        }
        GetString() {
            if (this.Value == null)
                return "";
            return this.Value.toString();
        }
        GetNumberAt(idx) {
            if (this.VariantType == UVariantTypes.Vector) {
                var arr = this.Value;
                if (arr != null && arr.length > idx)
                    return arr[idx];
            }
            return null;
        }
        toString() {
            var valueString = "" + this.Value;
            if (this.VariantType == UVariantTypes.String) {
                valueString = "\"" + this.Value + "\"";
            }
            else if (this.VariantType == UVariantTypes.Vector) {
                var values = this.Value;
                var sb = "";
                for (var val of values) {
                    if (sb.length != 0)
                        sb += ',';
                    sb += (val.toString());
                }
                valueString = "(" + sb + ")";
            }
            else if (this.VariantType == UVariantTypes.Matrix) {
                var arrarr = this.Value;
                var sb = "";
                for (let val of arrarr) {
                    var sbb = "";
                    for (var val1 of val) {
                        if (sbb.length != 0)
                            sbb += (',');
                        sbb += val1;
                    }
                    sb += "(" + sbb + ")";
                }
                valueString = "(" + sb + ")";
            }
            return valueString;
        }
        GetNumbers() {
            if (this.VariantType == UVariantTypes.Vector) {
                return this.Value.slice();
            }
            return [this.GetNumber()];
        }
        GetNumber2() {
            var result = [0, 0];
            if (this.VariantType == UVariantTypes.Vector) {
                var idx = 0;
                var numbers = this.Value;
                for (var d of numbers) {
                    if (idx >= 2)
                        break;
                    result[idx++] = d;
                }
            }
            else
                result[0] = result[1] = this.GetNumber();
            return result;
        }
        GetNumber3() {
            var result = [0, 0, 0];
            if (this.VariantType == UVariantTypes.Vector) {
                var idx = 0;
                var numbers = this.Value;
                for (var d of numbers) {
                    if (idx >= 3)
                        break;
                    result[idx++] = d;
                }
            }
            else
                result[0] = result[1] = result[2] = this.GetNumber();
            return result;
        }
        GetNumber4() {
            var result = [0, 0, 0, 0];
            if (this.VariantType == UVariantTypes.Vector) {
                var idx = 0;
                var numbers = this.Value;
                for (var d of numbers) {
                    if (idx >= 4)
                        break;
                    result[idx++] = d;
                }
            }
            else
                result[0] = result[1] = result[2] = result[3] = this.GetNumber();
            return result;
        }
        GetMatrix() {
            var matrix = [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ];
            if (this.VariantType == UVariantTypes.Matrix) {
                var values = this.Value;
                for (var row = 0; row < values.length; row++) {
                    for (var col = 0; col < values[row].length; col++) {
                        matrix[row][col] = values[row][col];
                    }
                }
            }
            else if (this.VariantType == UVariantTypes.Vector) {
                let values = this.Value;
                for (var i = 0; i < values.length; i++) {
                    var row = Math.floor(i / 4.0);
                    var col = (i % 4);
                    matrix[row][col] = values[i];
                }
            }
            else {
                var val = this.GetNumber();
                for (var i = 0; i < 4; i++) {
                    for (var j = 0; j < 4; j++) {
                        matrix[i][j] = val;
                    }
                }
            }
            return matrix;
        }
        GetVector2() {
            return UVariant.ToVector2(this);
        }
        GetVector3() {
            return UVariant.ToVector3(this);
        }
        GetVector4() {
            return UVariant.ToVector4(this);
        }
        GetColor() {
            return UVariant.ToColor(this);
        }
        static ToString(expVar) {
            var valueString = "V:" + expVar.Value;
            var result = "";
            result += "T:" + expVar.VariantType;
            if (expVar.VariantType == UVariantTypes.Vector) {
                var values = expVar.Value;
                var sb = "";
                for (var val of values) {
                    if (sb.length != 0)
                        sb += (',');
                    sb += val;
                }
                valueString = "V:{" + sb + "}";
            }
            else if (expVar.VariantType == UVariantTypes.Matrix) {
                var arrarr = expVar.Value;
                var sb = "";
                for (let val of arrarr) {
                    var sbb = "";
                    for (var val1 of val) {
                        if (sbb.length != 0)
                            sbb += (',');
                        sbb += val1;
                    }
                    sb += "{" + sbb + "}";
                }
                valueString = "V:{" + sb + "}";
            }
            result += valueString;
            return result;
        }
        static FromString(variantString) {
            if (variantString == "" || variantString == null) {
                return new UVariant();
            }
            try {
                var typStr = variantString.slice(2, 3);
                var idx = variantString.indexOf("V:");
                var valStr = variantString.slice(idx + 2, variantString.length);
                var valtyp = parseInt(typStr);
                var value = null;
                if (valtyp == UVariantTypes.Bool) {
                    value = (valStr.toLowerCase() == "true");
                }
                else if (valtyp == UVariantTypes.Number) {
                    value = parseFloat(valStr);
                }
                else if (valtyp == UVariantTypes.String) {
                    value = valStr;
                }
                else if (valtyp == UVariantTypes.Vector) {
                    var begin = valStr.indexOf('{') + 1;
                    var end = valStr.lastIndexOf('}');
                    valStr = valStr.slice(begin, end);
                    var dbls = valStr.split(',');
                    var vect = new Array(dbls.length);
                    for (var i = 0; i < dbls.length; i++) {
                        vect[i] = parseFloat(dbls[i]);
                    }
                    value = vect;
                }
                else if (valtyp == UVariantTypes.Matrix) {
                    var begin = valStr.indexOf('{') + 1;
                    var end = valStr.lastIndexOf('}');
                    valStr = valStr.slice(begin, end);
                    var vectStrList = valStr.split('}');
                    var arrVector = new Array(vectStrList.length - 1);
                    for (var i = 0; i < vectStrList.length - 1; i++) {
                        var vectStr = vectStrList[i];
                        idx = vectStr.indexOf('{');
                        vectStr = vectStr.slice(idx + 1, vectStr.length);
                        var dbls = vectStr.split(',');
                        var vect = new Array(dbls.length);
                        for (var j = 0; j < dbls.length; j++) {
                            vect[j] = parseFloat(dbls[j]);
                        }
                        arrVector[i] = vect;
                    }
                    value = arrVector;
                }
                var result = new UVariant();
                result.VariantType = valtyp;
                result.Value = value;
                return result;
            }
            catch (e) {
                return new UVariant();
            }
        }
        static Negate(value) {
            if (value.VariantType == UVariantTypes.Vector) {
                var value2 = new UVariant();
                value2.SetNumber(-1.0);
                return UVariant.VectorOperation(UOperationType.Multiply, value, value2);
            }
            else if (value.VariantType == UVariantTypes.Matrix) {
                var values = value.Value;
                for (var i = 0; i < values.length; i++) {
                    for (var j = 0; j < values[i].length; j++) {
                        values[i][j] *= -1;
                    }
                }
                return new UVariant().SetMatrix(values);
            }
            else {
                return new UVariant().SetNumber(value.GetNumber() * -1.0);
            }
        }
        static Add(value1, value2) {
            if (value1.VariantType == UVariantTypes.Matrix || value2.VariantType == UVariantTypes.Matrix) {
                return UVariant.MatrixOperation(UOperationType.Add, value1, value2);
            }
            else if (value1.VariantType == UVariantTypes.Vector || value2.VariantType == UVariantTypes.Vector) {
                return UVariant.VectorOperation(UOperationType.Add, value1, value2);
            }
            else {
                return new UVariant().SetNumber(value1.GetNumber() + value2.GetNumber());
            }
        }
        static Sub(value1, value2) {
            if (value1.VariantType == UVariantTypes.Matrix || value2.VariantType == UVariantTypes.Matrix) {
                return UVariant.MatrixOperation(UOperationType.Sub, value1, value2);
            }
            else if (value1.VariantType == UVariantTypes.Vector || value2.VariantType == UVariantTypes.Vector) {
                return UVariant.VectorOperation(UOperationType.Sub, value1, value2);
            }
            else {
                return new UVariant().SetNumber(value1.GetNumber() - value2.GetNumber());
            }
        }
        static Multiply(value1, value2) {
            if (value1.VariantType == UVariantTypes.Matrix || value2.VariantType == UVariantTypes.Matrix) {
                return UVariant.MatrixOperation(UOperationType.Multiply, value1, value2);
            }
            else if (value1.VariantType == UVariantTypes.Vector || value2.VariantType == UVariantTypes.Vector) {
                return UVariant.VectorOperation(UOperationType.Multiply, value1, value2);
            }
            else {
                return new UVariant().SetNumber(value1.GetNumber() * value2.GetNumber());
            }
        }
        static Divide(value1, value2) {
            if (value1.VariantType == UVariantTypes.Matrix || value2.VariantType == UVariantTypes.Matrix) {
                return UVariant.MatrixOperation(UOperationType.Divide, value1, value2);
            }
            else if (value1.VariantType == UVariantTypes.Vector || value2.VariantType == UVariantTypes.Vector) {
                return UVariant.VectorOperation(UOperationType.Divide, value1, value2);
            }
            else {
                return new UVariant().SetNumber(value1.GetNumber() / value2.GetNumber());
            }
        }
        static VectorOperation(op, value1, value2) {
            var itemcount = Math.max(value1.ItemCount, value2.ItemCount);
            var arr = new Array(itemcount);
            for (var i = 0; i < itemcount; i++) {
                var num0 = value1.GetNumberAt(i);
                var num1 = value2.GetNumberAt(i);
                if (op == UOperationType.Multiply)
                    arr[i] = num0 * num1;
                else if (op == UOperationType.Sub)
                    arr[i] = num0 - num1;
                else if (op == UOperationType.Add)
                    arr[i] = num0 + num1;
                else if (op == UOperationType.Divide) {
                    if (num1 == 0)
                        num1 = 1;
                    arr[i] = num0 / num1;
                }
            }
            return new UVariant().SetVector(arr);
        }
        static MatrixOperation(op, value1, value2) {
            var m1 = value1.GetMatrix();
            var m2 = value2.GetMatrix();
            var result = [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ];
            for (var i = 0; i < 4; i++) {
                for (var j = 0; j < 4; j++) {
                    var num0 = m1[i][j];
                    var num1 = m2[i][j];
                    if (op == UOperationType.Multiply)
                        result[i][j] = num0 * num1;
                    else if (op == UOperationType.Sub)
                        result[i][j] = num0 - num1;
                    else if (op == UOperationType.Add)
                        result[i][j] = num0 + num1;
                    else if (op == UOperationType.Divide) {
                        if (num1 == 0)
                            num1 = 1;
                        result[i][j] = num0 / num1;
                    }
                }
            }
            return new UVariant().SetMatrix(result);
        }
        static Transform(expValue, func) {
            if (expValue.VariantType == UVariantTypes.Vector) {
                var arr = new Array(expValue.ItemCount);
                for (var i = 0; i < expValue.ItemCount; i++) {
                    arr[i] = func(expValue.GetNumberAt(i));
                }
                return new UVariant().SetVector(arr);
            }
            else if (expValue.VariantType == UVariantTypes.Matrix) {
                var src = expValue.Value;
                var arrarr = new Array(src.length);
                for (var i = 0; i < arrarr.length; i++) {
                    var arr = new Array(src[i].length);
                    for (var j = 0; j < src[i].length; j++)
                        arr[j] = func(src[i][j]);
                    arrarr[i] = arr;
                }
                return new UVariant().SetMatrix(arrarr);
            }
            else {
                return new UVariant().SetNumber(func(expValue.GetNumber()));
            }
        }
        static Transform2(expValue1, expValue2, func) {
            if (expValue1.VariantType == UVariantTypes.Vector || expValue2.VariantType == UVariantTypes.Vector) {
                var icount = Math.max(expValue1.ItemCount, expValue2.ItemCount);
                var arr = new Array(icount);
                for (var i = 0; i < icount; i++) {
                    arr[i] = func(expValue1.GetNumberAt(i), expValue2.GetNumberAt(i));
                }
                return new UVariant().SetVector(arr);
            }
            else {
                return new UVariant().SetNumber(func(expValue1.GetNumber(), expValue2.GetNumber()));
            }
        }
        static ToColor(expVariant) {
            if (expVariant.VariantType == UVariantTypes.Vector) {
                var doubles = expVariant.Value;
                var r = doubles.length > 0 ? doubles[0] : 0;
                var g = doubles.length > 1 ? doubles[1] : r;
                var b = doubles.length > 2 ? doubles[2] : g;
                var a = doubles.length > 3 ? doubles[3] : 0;
                var color = new U1.Color();
                color.R = (Math.max(0, Math.min(255, r)));
                color.G = (Math.max(0, Math.min(255, g)));
                color.B = (Math.max(0, Math.min(255, b)));
                color.A = (Math.max(0, Math.min(255, a)));
            }
            return U1.Colors.Black;
        }
        static ToVector3(expVariant) {
            if (expVariant.VariantType == UVariantTypes.Vector) {
                var doubles = expVariant.Value;
                var x = doubles.length > 0 ? doubles[0] : 0;
                var y = doubles.length > 1 ? doubles[1] : 0;
                var z = doubles.length > 2 ? doubles[2] : 0;
                return new U1.Vector3(x, y, z);
            }
            return U1.Vector3.Zero;
        }
        static ToVector2(expVariant) {
            if (expVariant.VariantType == UVariantTypes.Vector) {
                var doubles = expVariant.Value;
                var x = doubles.length > 0 ? doubles[0] : 0;
                var y = doubles.length > 1 ? doubles[1] : 0;
                return new U1.Vector2(x, y);
            }
            return U1.Vector2.Zero;
        }
        static ToVector4(expVariant) {
            if (expVariant.VariantType == UVariantTypes.Vector) {
                var doubles = expVariant.Value;
                var x = doubles.length > 0 ? doubles[0] : 0;
                var y = doubles.length > 1 ? doubles[1] : 0;
                var z = doubles.length > 2 ? doubles[2] : 0;
                var w = doubles.length > 3 ? doubles[3] : 0;
                return new U1.Vector4(x, y, z, w);
            }
            return U1.Vector4.Zero;
        }
        Equals(other) {
            if (this.VariantType != other.VariantType)
                return false;
            if (this._value == null && other._value == null)
                return true;
            if (this._value != null && this._value == other._value)
                return true;
            return false;
        }
    }
    U1.UVariant = UVariant;
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Graphics;
    (function (Graphics) {
        let FontStyleEnum;
        (function (FontStyleEnum) {
            FontStyleEnum[FontStyleEnum["Normal"] = 0] = "Normal";
            FontStyleEnum[FontStyleEnum["Italic"] = 1] = "Italic";
            FontStyleEnum[FontStyleEnum["Oblique"] = 2] = "Oblique";
        })(FontStyleEnum = Graphics.FontStyleEnum || (Graphics.FontStyleEnum = {}));
        let FontWeightEnum;
        (function (FontWeightEnum) {
            FontWeightEnum[FontWeightEnum["Normal"] = 0] = "Normal";
            FontWeightEnum[FontWeightEnum["Black"] = 1] = "Black";
            FontWeightEnum[FontWeightEnum["Bold"] = 2] = "Bold";
            FontWeightEnum[FontWeightEnum["DemiBold"] = 3] = "DemiBold";
            FontWeightEnum[FontWeightEnum["ExtraBlack"] = 4] = "ExtraBlack";
            FontWeightEnum[FontWeightEnum["ExtraBold"] = 5] = "ExtraBold";
            FontWeightEnum[FontWeightEnum["ExtraLight"] = 6] = "ExtraLight";
            FontWeightEnum[FontWeightEnum["Heavy"] = 7] = "Heavy";
            FontWeightEnum[FontWeightEnum["Light"] = 8] = "Light";
            FontWeightEnum[FontWeightEnum["Medium"] = 9] = "Medium";
            FontWeightEnum[FontWeightEnum["Regular"] = 10] = "Regular";
            FontWeightEnum[FontWeightEnum["SemiBold"] = 11] = "SemiBold";
            FontWeightEnum[FontWeightEnum["Thin"] = 12] = "Thin";
            FontWeightEnum[FontWeightEnum["UltraBlack"] = 13] = "UltraBlack";
            FontWeightEnum[FontWeightEnum["UltraBold"] = 14] = "UltraBold";
            FontWeightEnum[FontWeightEnum["UltraLight"] = 15] = "UltraLight";
        })(FontWeightEnum = Graphics.FontWeightEnum || (Graphics.FontWeightEnum = {}));
        class MeshChar {
            get Faces() {
                if (this._faces == null) {
                    this._faces = this.Tessellate();
                }
                return this._faces;
            }
            Tessellate() {
                if (this.Outlines == null)
                    return;
                var trian = new U1.Triangulations.PolygonTriangulation2();
                for (var i = 0; i < this.Outlines.length; i++) {
                    trian.Fill(this.Outlines[i]);
                }
                var mesh = trian.GetMesh();
                var faces = new Array();
                for (var i = 0; i < mesh.FList.length; i++) {
                    var face = mesh.FList[i];
                    faces.push(mesh.VList[face.V0]);
                    faces.push(mesh.VList[face.V1]);
                    faces.push(mesh.VList[face.V2]);
                }
                return faces;
            }
            Read(data) {
                this.Outlines = new Array();
                var idx = 0;
                this.Width = data[idx++];
                this.Height = data[idx++];
                var min_x = data[idx++];
                var min_y = data[idx++];
                var max_x = data[idx++];
                var max_y = data[idx++];
                var size_x = max_x - min_x;
                var size_y = max_y - min_y;
                var num_polygon = data[idx++];
                for (var i = 0; i < num_polygon; i++) {
                    var pgon = new Array();
                    while (true) {
                        var bx = data[idx++];
                        var by = data[idx++];
                        if (bx >= 255 && by >= 255) {
                            this.Outlines.push(pgon);
                            break;
                        }
                        var x = (bx / 250 * size_x) + min_x;
                        var y = (by / 250 * size_y) + min_y;
                        pgon.push(new U1.Vector2(x, y));
                    }
                }
            }
        }
        MeshChar.tMin = U1.Vector2.Zero;
        MeshChar.tMax = U1.Vector2.Zero;
        Graphics.MeshChar = MeshChar;
        class MeshFont {
            constructor() {
                this.Chars = {};
            }
            GetChar(c) {
                return this.Chars[c];
            }
            GetMesh(text, fontSize, width, height, isMultiline) {
                var trifaces = new Array();
                var ch_num = text.length;
                var x = 0.0;
                var y = 0.0;
                var scale = fontSize / 100;
                for (var i = 0; i < ch_num; i++) {
                    var c = text.charCodeAt(i);
                    var mc = this.GetChar(c);
                    if (mc == null)
                        continue;
                    var lt = new U1.Vector2(x, y);
                    var faces = mc.Faces;
                    for (var j = 0; j < faces.length; j++) {
                        var np = U1.Vector2.ScaleAdd(faces[j], scale, lt);
                        trifaces.push(np);
                    }
                    x += mc.Width * scale;
                    if (isMultiline && x > width) {
                        x = 0;
                        y += height;
                    }
                }
                return trifaces;
            }
            GetOutlines(text, fontSize, width, height, isMultiline) {
                var result = new Array();
                var ch_num = text.length;
                var x = 0.0;
                var y = 0.0;
                var scale = fontSize / 100;
                for (var i = 0; i < ch_num; i++) {
                    var c = text.charCodeAt(c);
                    var mc = this.GetChar(c);
                    if (mc == null)
                        continue;
                    var lt = new U1.Vector2(x, y);
                    var polygons = mc.Outlines;
                    for (var j = 0; j < polygons.length; j++) {
                        var polygon = polygons[j];
                        var n_polygon = new Array(polygon.length);
                        for (var k = 0; k < polygon.length; k++) {
                            n_polygon[k] = U1.Vector2.ScaleAdd(polygon[k], scale, lt);
                        }
                        result.push(n_polygon);
                    }
                    x += mc.Width * scale;
                    if (isMultiline && x > width) {
                        x = 0;
                        y += height;
                    }
                }
                return result;
            }
            Read(charsData) {
                for (var i = 0; i <= 65535; i++) {
                    var key = "" + i;
                    var charData = charsData[key];
                    if (charData != null) {
                        var char = new MeshChar();
                        char.Read(charData);
                        this.Chars[i] = char;
                    }
                }
            }
            static get Default() {
                if (MeshFont._default == null) {
                    MeshFont._default = new MeshFont();
                    MeshFont._default.Read(default_font_data);
                }
                return MeshFont._default;
            }
        }
        Graphics.MeshFont = MeshFont;
    })(Graphics = U1.Graphics || (U1.Graphics = {}));
})(U1 || (U1 = {}));
var U1;
(function (U1) {
    var Views;
    (function (Views) {
        class VcXForm2_Node {
            constructor(node) {
                this.Node = node;
                this.Transform = new U1.Matrix4();
                this.Transform.CopyFrom(node.Transform);
            }
        }
        class VcXForm2_HP {
            constructor(name) {
                this.m_pos = U1.Vector3.Zero;
                this.Opp = U1.Vector3.Zero;
                this.Dir = U1.Vector3.Zero;
                this.DragStart = U1.Vector3.Zero;
                this.PrevPos = U1.Vector3.Zero;
                this.CurPos = U1.Vector3.Zero;
                this.Name = name;
            }
            Update(xform, pos, opp) {
                if (this.m_node == null) {
                    var point = this.m_node = xform.Scene.Overlay.AddEntity(Views.ScPoint);
                    point.Radius = VcXForm2_HP._radius;
                    point.Style.Fill = U1.Colors.Gray;
                }
                this.Opp.CopyFrom(opp);
                this.Dir.SetSubtract(pos, opp).Normalize();
                this.m_pos.CopyFrom(pos);
                this.m_node.Transform.SetCreateTranslation(this.m_pos);
            }
            CheckIntersect(isectContext) {
                return this.m_node.CheckIntersect(isectContext);
            }
            IsInterSect(xform, screen_pos) {
                var sp = VcXForm2_HP._tmp_v30;
                var dist_sp = VcXForm2_HP._radius * VcXForm2_HP._radius;
                var cam = xform.Scene.Camera;
                cam.WorldToScreen(this.m_pos, sp);
                sp.Z = screen_pos.Z;
                if (U1.Vector3.DistanceSquared(sp, screen_pos) <= dist_sp)
                    return true;
                return false;
            }
            Clear() {
                if (this.m_node != null)
                    this.m_node.Dispose();
                this.m_node = null;
            }
            OnMouseMove(xform, ev) {
                this.Move(xform);
                return true;
            }
            OnMouseUp(xform, ev) {
                xform.EndTransform();
                return true;
            }
            OnMouseDown(view, ev) {
                return false;
            }
            OnPanMove(xform, ev) {
                this.Move(xform);
                return true;
            }
            BeginTransform(xform) {
                xform.View.Scene.Camera.ScreenToPlane(xform.View.CurDn, xform.View.WorkingPlane, this.CurPos);
                var v = VcXForm2[".bt.1"] || (VcXForm2[".bt.1"] = new U1.Vector3());
                v.SetSubtract(this.CurPos, this.Opp);
                var t = U1.Vector3.Dot(this.Dir, v);
                this.CurPos.SetScaleAdd(this.Opp, t, this.Dir);
                this.DragStart.CopyFrom(this.CurPos);
                return true;
            }
            Move(xform) {
                this.PrevPos.CopyFrom(this.CurPos);
                xform.View.Scene.Camera.ScreenToPlane(xform.View.CurMv, xform.View.WorkingPlane, this.CurPos);
                var v = VcXForm2[".mv.1"] || (VcXForm2[".mv.1"] = new U1.Vector3());
                v.SetSubtract(this.CurPos, this.Opp);
                var t = U1.Vector3.Dot(this.Dir, v);
                this.CurPos.SetScaleAdd(this.Opp, t, this.Dir);
                xform.Scale(this.Opp, this.PrevPos, this.CurPos);
            }
        }
        VcXForm2_HP._radius = 8;
        VcXForm2_HP._tmp_v30 = U1.Vector3.Zero;
        class VcXForm2_Rotate extends VcXForm2_HP {
            constructor(name) {
                super(name);
                this.Center = U1.Vector3.Zero;
                this.Angle = 0;
            }
            UpdateRot(xform, front, back) {
                if (this.m_node == null) {
                    var pt = this.m_node = xform.Scene.Overlay.AddEntity(Views.ScPoint);
                    pt.Radius = VcXForm2_HP._radius;
                    pt.Style.Fill = U1.Colors.Gray;
                }
                var dir = VcXForm2[".ur.1"] || (VcXForm2[".ur.1"] = new U1.Vector3());
                var p1 = VcXForm2[".ur.2"] || (VcXForm2[".ur.2"] = new U1.Vector3());
                dir.SetSubtract(back, front).Normalize();
                p1.CopyFrom(back);
                this.m_pos.SetAdd(dir, back);
                xform.Scene.Camera.WorldToScreen(p1, p1);
                xform.Scene.Camera.WorldToScreen(this.m_pos, this.m_pos);
                p1.Z = this.m_pos.Z;
                var dist = U1.Vector3.Distance(p1, this.m_pos);
                this.m_pos.SetScaleAdd(back, 40 / dist, dir);
                this.m_node.Transform.SetCreateTranslation(this.m_pos);
            }
            BeginTransform(xform) {
                this.Angle = 0;
                this.Center.CopyFrom(xform.CurOBB.Center);
                xform.View.Scene.Camera.ScreenToPlane(xform.View.CurDn, xform.View.WorkingPlane, this.PrevPos);
                xform.View.Scene.Camera.ScreenToPlane(xform.View.CurDn, xform.View.WorkingPlane, this.CurPos);
                return true;
            }
            OnMouseDn(xform, ev) {
                return true;
            }
            OnMouseMove(xform, ev) {
                this.Move(xform);
                return true;
            }
            OnPanMove(view, ev) {
                this.Move(view);
                return true;
            }
            Move(xform) {
                var v1 = VcXForm2_Rotate[".mv.1"] || (VcXForm2_Rotate[".mv.1"] = new U1.Vector3());
                var v2 = VcXForm2_Rotate[".mv.2"] || (VcXForm2_Rotate[".mv.2"] = new U1.Vector3());
                var v3 = VcXForm2_Rotate[".mv.3"] || (VcXForm2_Rotate[".mv.3"] = new U1.Vector3());
                var m0 = VcXForm2_Rotate[".mv.4"] || (VcXForm2_Rotate[".mv.4"] = new U1.Matrix4());
                var m1 = VcXForm2_Rotate[".mv.5"] || (VcXForm2_Rotate[".mv.5"] = new U1.Matrix4());
                var m2 = VcXForm2_Rotate[".mv.6"] || (VcXForm2_Rotate[".mv.6"] = new U1.Matrix4());
                this.PrevPos.CopyFrom(this.CurPos);
                xform.View.Scene.Camera.ScreenToPlane(xform.View.CurMv, xform.View.WorkingPlane, this.CurPos);
                var norm = xform.View.WorkingPlane.Normal;
                v1.SetSubtract(this.PrevPos, this.Center).Normalize();
                v2.SetSubtract(this.CurPos, this.Center).Normalize();
                var ang = U1.GeometryHelper3.AngleCCW(v1, norm, v2);
                this.Angle += ang;
                var neg_cent = U1.Vector3.Negate(this.Center, v3);
                m0.SetCreateTranslation(neg_cent);
                m1.SetCreateFromAxisAngle(norm, ang);
                m2.SetCreateTranslation(this.Center);
                m0.Multiply(m1).Multiply(m2);
                xform.Translate(m0);
            }
            OnMouseUp(view, ev) {
                view.EndTransform();
                return true;
            }
        }
        class VcXForm2_Box extends VcXForm2_HP {
            constructor(name) {
                super(name);
            }
            UpdateBox(xform, lf, lk, rk, rf) {
                if (this.m_node == null) {
                    var pgon = this.m_node = xform.Scene.Overlay.AddEntity(Views.ScPolygon);
                    this.m_node.Order = -1;
                    pgon.Style.StrokeDash = [1];
                    pgon.Style.Fill = new U1.Color(0, 0, 255);
                    pgon.Style.Alpha = 0.3;
                    pgon.IsPickable = false;
                    pgon.Points = [
                        U1.Vector3.Zero,
                        U1.Vector3.Zero,
                        U1.Vector3.Zero,
                        U1.Vector3.Zero
                    ];
                    pgon.Style.Stroke = U1.Colors.Blue;
                    pgon.Style.StrokeThickness = 4;
                }
                var polygon = this.m_node;
                polygon.Points[0].CopyFrom(lf);
                polygon.Points[1].CopyFrom(lk);
                polygon.Points[2].CopyFrom(rk);
                polygon.Points[3].CopyFrom(rf);
            }
        }
        class VcXForm2 extends Views.VcControl {
            constructor() {
                super(...arguments);
                this.m_curObb = new U1.OrientedBox3();
                this.m_oldObb = new U1.OrientedBox3();
                this.m_mode = 0;
                this.m_prev_loc = U1.Vector3.Zero;
                this.m_cur_loc = U1.Vector3.Zero;
                this.m_points = {
                    "Front": new VcXForm2_HP("Front"),
                    "Back": new VcXForm2_HP("Back"),
                    "Left": new VcXForm2_HP("Left"),
                    "Right": new VcXForm2_HP("Right"),
                    "LeftFront": new VcXForm2_HP("LeftFront"),
                    "RightFront": new VcXForm2_HP("RightFront"),
                    "LeftBack": new VcXForm2_HP("LeftBack"),
                    "RightBack": new VcXForm2_HP("RightBack"),
                    "Rotate": new VcXForm2_Rotate("Rotate"),
                    "Box": new VcXForm2_Box("Box")
                };
            }
            get CurOBB() {
                return this.m_curObb;
            }
            CheckIntersect(isectContext) {
                for (var idx in this.m_points) {
                    var node = this.m_points[idx];
                    var isect = node.CheckIntersect(isectContext);
                    if (isect != null)
                        return isect;
                }
                return null;
            }
            GetIntersectNode(screen_pos) {
                for (var idx in this.m_points) {
                    var node = this.m_points[idx];
                    if (node.IsInterSect(this, screen_pos))
                        return node;
                }
                return null;
            }
            Init(nodes) {
                var tmp_1 = VcXForm2[".ini.1"] || (VcXForm2[".ini.1"] = new U1.Vector3());
                var tmp_2 = VcXForm2[".ini.2"] || (VcXForm2[".ini.2"] = new U1.Vector3());
                var tmp_3 = VcXForm2[".ini.3"] || (VcXForm2[".ini.3"] = new U1.Vector3());
                var tmp_m1 = VcXForm2[".ini.4"] || (VcXForm2[".ini.4"] = new U1.Matrix4());
                this.m_selected_nodes = {};
                var min = tmp_1.SetMaxValue();
                var max = tmp_2.SetMinValue();
                var p = tmp_3;
                var tm = tmp_m1;
                for (var node of nodes) {
                    this.m_selected_nodes[node.Handle] = new VcXForm2_Node(node);
                    var wm = node.WorldTransform;
                    tm.CopyFrom(wm);
                    node.BoundingBox.GetCorners()
                        .forEach((v_, i_) => {
                        p.SetTransform(v_, tm);
                        min.Minimize(p);
                        max.Maximize(p);
                    });
                }
                this.m_curObb.Center.SetAdd(min, max).Scale(0.5);
                this.m_curObb.Axes[0].Set(1, 0, 0);
                this.m_curObb.Axes[1].Set(0, 1, 0);
                this.m_curObb.Axes[2].Set(0, 0, 1);
                this.m_curObb.Extents[0] = (max.X - min.X) * 0.5;
                this.m_curObb.Extents[1] = (max.Y - min.Y) * 0.5;
                this.m_curObb.Extents[2] = (max.Z - min.Z) * 0.5;
            }
            Update() {
                var lft = VcXForm2[".up.1"] || (VcXForm2[".up.1"] = new U1.Vector3());
                var rft = VcXForm2[".up.2"] || (VcXForm2[".up.2"] = new U1.Vector3());
                var lkt = VcXForm2[".up.3"] || (VcXForm2[".up.3"] = new U1.Vector3());
                var rkt = VcXForm2[".up.4"] || (VcXForm2[".up.4"] = new U1.Vector3());
                var front = VcXForm2[".up.5"] || (VcXForm2[".up.5"] = new U1.Vector3());
                var back = VcXForm2[".up.6"] || (VcXForm2[".up.6"] = new U1.Vector3());
                var left = VcXForm2[".up.7"] || (VcXForm2[".up.7"] = new U1.Vector3());
                var right = VcXForm2[".up.8"] || (VcXForm2[".up.8"] = new U1.Vector3());
                lft = this.m_curObb.LFT(lft);
                rft = this.m_curObb.RFT(rft);
                lkt = this.m_curObb.LKT(lkt);
                rkt = this.m_curObb.RKT(rkt);
                front.SetAdd(lft, rft).Scale(0.5);
                back.SetAdd(lkt, rkt).Scale(0.5);
                left.SetAdd(lft, lkt).Scale(0.5);
                right.SetAdd(rft, rkt).Scale(0.5);
                this.m_points.Box.UpdateBox(this, lft, lkt, rkt, rft);
            }
            Clear() {
                if (this.m_points != null) {
                    for (var idx in this.m_points) {
                        var node = this.m_points[idx];
                        node.Clear();
                    }
                }
            }
            OnMouseMove(ev) {
                if (this.m_active_hp != null &&
                    this.m_active_hp.OnMouseMove(this, ev)) {
                    return true;
                }
                if (this.m_mode == 1) {
                    this.Move();
                    return true;
                }
                return false;
            }
            OnMouseUp(ev) {
                if (this.m_active_hp != null &&
                    this.m_active_hp.OnMouseUp(this, ev)) {
                    return true;
                }
                if (this.m_mode > 0) {
                    if (this.EndTransform())
                        return true;
                    this.m_mode = 0;
                }
                return false;
            }
            OnMouseDown(ev) {
                if (ev.button == 0) {
                    if (this.PrepareTransform())
                        return true;
                    if (this.m_active_hp != null &&
                        this.m_active_hp.OnMouseDown(this, ev)) {
                        return true;
                    }
                }
                return false;
            }
            OnMouseWheel(ev) {
                return false;
            }
            OnPanMove(ev) {
                if (this.m_active_hp != null &&
                    this.m_active_hp.OnPanMove(this, ev)) {
                    return true;
                }
                if (this.m_mode == 1) {
                    this.Move();
                    return true;
                }
                return false;
            }
            OnPanStart(ev) {
                if (this.PrepareTransform())
                    return true;
                return false;
            }
            OnPanEnd(ev) {
                if (this.EndTransform())
                    return true;
                return false;
            }
            OnPinch(ev) {
                return false;
            }
            Move() {
                if (this.m_mode != 1)
                    return;
                var v1 = VcXForm2[".mv.v1"] || (VcXForm2[".mv.v1"] = new U1.Vector3());
                var m1 = VcXForm2[".mv.m1"] || (VcXForm2[".mv.m1"] = new U1.Matrix4());
                this.m_prev_loc.CopyFrom(this.m_cur_loc);
                this.View.Scene.Camera.ScreenToPlane(this.View.CurMv, this.View.WorkingPlane, this.m_cur_loc);
                var offset = U1.Vector3.Subtract(this.m_cur_loc, this.m_prev_loc, v1);
                var tm = U1.Matrix4.CreateTranslation(offset, m1);
                this.m_curObb.Transform(tm);
                for (var id in this.m_selected_nodes) {
                    var nd = this.m_selected_nodes[id];
                    nd.Node.Transform.Multiply(tm);
                }
                this.View.Invalidate();
                return true;
            }
            PrepareTransform() {
                if (this.m_mode != 0)
                    return false;
                var v1 = VcXForm2[".pt.v1"] || (VcXForm2[".pt.v1"] = new U1.Vector3());
                var screen_pos = v1.Set(this.View.CurDn.X, this.View.CurDn.Y, 0);
                var isect_node = this.GetIntersectNode(screen_pos);
                if (isect_node != null) {
                    this.m_active_hp = isect_node;
                    this.m_mode = 2;
                    this.BeginTransform();
                    return true;
                }
                var pkResult = this.View.Pick(this.View.CurDn);
                if (pkResult.Node != null && this.m_selected_nodes[pkResult.Node.Handle] != null) {
                    if (pkResult.Node.Presenter != null && pkResult.Node.Presenter.CanMove) {
                        this.m_mode = 1;
                        this.View.Scene.Camera.ScreenToPlane(this.View.CurDn, this.View.WorkingPlane, this.m_cur_loc);
                        this.BeginTransform();
                        return true;
                    }
                }
                return false;
            }
            BeginTransform() {
                this.m_oldObb.CopyFrom(this.m_curObb);
                if (this.m_active_hp != null)
                    this.m_active_hp.BeginTransform(this);
                return true;
            }
            Translate(matrix) {
                this.m_curObb.Transform(matrix);
                this.View.Invalidate();
            }
            Scale(center, p1, p2) {
                this.CurOBB.ScaleWithTwoPoints(center, p1, p2);
                this.View.Invalidate();
            }
            EndTransform() {
                var z = VcXForm2[".et.v1"] || (VcXForm2[".et.v1"] = new U1.Vector3());
                z.SetUnitZ();
                if (this.m_mode == 1 || this.m_active_hp != null) {
                    if (this.m_mode == 1) {
                        this.ApplyMove();
                    }
                    else if (this.m_active_hp == this.m_points.Rotate) {
                        var rot = this.m_points.Rotate;
                        var angle = U1.GeometryHelper3.AngleCCW(this.m_oldObb.Axes[0], z, this.m_curObb.Axes[0]);
                        this.ApplyRotate(this.m_oldObb.Center, z, angle);
                    }
                    else if (this.m_active_hp != null && this.m_active_hp != this.m_points.Box) {
                        var cent = this.m_active_hp.Opp;
                        var p1 = this.m_active_hp.DragStart;
                        var p2 = this.m_active_hp.CurPos;
                        this.ApplyScale(cent, p1, p2);
                    }
                }
                this.m_active_hp = null;
                this.m_mode = 0;
                return true;
            }
            ApplyMove() {
                this.View.Document.BeginTransaction();
                if (this.m_mode == 1) {
                    var v = VcXForm2[".am.v1"] || (VcXForm2[".am.v1"] = new U1.Vector3());
                    var m = VcXForm2[".am.m1"] || (VcXForm2[".am.m1"] = new U1.Matrix4());
                    v.SetSubtract(this.m_curObb.Center, this.m_oldObb.Center);
                    m.SetCreateTranslation(v);
                    for (var id in this.m_selected_nodes) {
                        var nd = this.m_selected_nodes[id];
                        if (!(nd.Node.Presenter instanceof Views.UElementPresenter3D)) {
                            continue;
                        }
                        nd.Node.Transform = nd.Transform;
                        nd.Node.Presenter.AddTransform(m);
                    }
                }
                this.View.Document.EndTransaction();
            }
            ApplyRotate(center, axis, angle) {
                var neg = VcXForm2[".ar.v1"] || (VcXForm2[".ar.v1"] = new U1.Vector3());
                var m = VcXForm2[".ar.m1"] || (VcXForm2[".ar.m1"] = new U1.Matrix4());
                var rm = VcXForm2[".ar.m2"] || (VcXForm2[".ar.m2"] = new U1.Matrix4());
                var tm1 = VcXForm2[".ar.m3"] || (VcXForm2[".ar.m3"] = new U1.Matrix4());
                neg.SetNegate(center);
                m.SetCreateTranslation(neg);
                rm.SetCreateFromAxisAngle(axis, angle);
                tm1.SetCreateTranslation(center);
                m.Multiply(rm).Multiply(tm1);
                this.View.Document.BeginTransaction();
                for (var id in this.m_selected_nodes) {
                    var nd = this.m_selected_nodes[id];
                    if (nd.Node.Presenter instanceof Views.UElementPresenter3D) {
                        nd.Node.Transform = nd.Transform;
                        nd.Node.Presenter.AddTransform(m);
                    }
                }
                this.View.Document.EndTransaction();
            }
            ApplyScale(center, p1, p2) {
                var obb = VcXForm2[".as.b1"] || (VcXForm2[".as.b1"] = new U1.OrientedBox3());
                var m = VcXForm2[".as.m1"] || (VcXForm2[".as.m1"] = new U1.Matrix4());
                obb.SetIdentity();
                obb.Axes[0].CopyFrom(this.m_oldObb.Axes[0]);
                obb.Axes[1].CopyFrom(this.m_oldObb.Axes[1]);
                obb.Axes[2].CopyFrom(this.m_oldObb.Axes[2]);
                m = this.CreateOBBScaleMatrix(obb, center, p1, p2, m);
                this.View.Document.BeginTransaction();
                for (var id in this.m_selected_nodes) {
                    var nd = this.m_selected_nodes[id];
                    if (nd.Node.Presenter instanceof Views.UElementPresenter3D) {
                        nd.Node.Transform = nd.Transform;
                        nd.Node.Presenter.AddTransform(m);
                    }
                }
                this.View.Document.EndTransaction();
            }
            CreateOBBScaleMatrix(obb, center, from, to, result) {
                var obb = VcXForm2[".cob.b1"] || (VcXForm2[".cob.b1"] = new U1.OrientedBox3());
                var v1 = VcXForm2[".cob.v1"] || (VcXForm2[".cob.v1"] = new U1.Vector3());
                var m1 = VcXForm2[".cob.v1"] || (VcXForm2[".cob.v1"] = new U1.Matrix4());
                var xformedOBB = obb.CopyFrom(obb).ScaleWithTwoPoints(center, from, to);
                var sx = xformedOBB.Extents[0] / obb.Extents[0];
                var sy = xformedOBB.Extents[1] / obb.Extents[1];
                var sz = xformedOBB.Extents[2] / obb.Extents[2];
                var loc = xformedOBB.Center;
                if (result == null)
                    result = new U1.Matrix4();
                var scl = v1.Set(sx, sy, sz);
                var m = result.SetCreateScale(scl);
                var tm = U1.Matrix4.CreateTranslation(loc, m1);
                m.Multiply(tm);
                return m;
            }
        }
        VcXForm2._tmp_m0 = U1.Matrix4.Identity;
        VcXForm2._tmp_m1 = U1.Matrix4.Identity;
        VcXForm2._tmp_v30 = U1.Vector3.Zero;
        VcXForm2._tmp_v31 = U1.Vector3.Zero;
        VcXForm2._tmp_v32 = U1.Vector3.Zero;
        VcXForm2._radius = 10;
        VcXForm2._fillcolor = U1.Colors.LightGray;
        Views.VcXForm2 = VcXForm2;
    })(Views = U1.Views || (U1.Views = {}));
})(U1 || (U1 = {}));
//# sourceMappingURL=U1.js.map